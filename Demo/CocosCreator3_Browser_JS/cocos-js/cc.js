
System.register(['./ammo-instantiated-993fd288.js'], function (exports) {
    'use strict';
    var Pool, RecyclePool, CachedArray, UniformProxyFactory, MorphWeightsValueProxy, MorphWeightsAllValueProxy, isPropertyPath, isCustomPath, HierarchyPath, ComponentPath, evaluatePath, CubicSplineVec2Value, CubicSplineVec3Value, CubicSplineVec4Value, CubicSplineQuatValue, CubicSplineNumberValue, _inheritsLoose, DESCRIPTOR_BUFFER_TYPE, DESCRIPTOR_SAMPLER_TYPE, _createClass, DescriptorSet, Format, Rect, ClearFlag, DrawInfo, MemoryUsageBit, BufferUsageBit, TextureType, errorID, FormatInfos, FormatSize, SampleCount, LoadOp, ColorMask, CullMode, error, DynamicStateFlagBit, StencilFace, TextureFlagBit, Type$1, ShaderStageFlagBit, IndirectBuffer, BufferFlagBit, Buffer, Viewport, CommandBufferType, CommandBuffer, Fence, Framebuffer, InputAssembler, DESCRIPTOR_DYNAMIC_TYPE, DescriptorSetLayout, PipelineLayout, PipelineState, Queue, RenderPass, Filter, Sampler, Shader, RasterizerState, DepthStencilState, BlendState, IsPowerOf2, FormatSurfaceSize, Texture, macro, API, _createForOfIteratorHelperLoose, sys, WECHAT, Feature, QueueInfo, QueueType, CommandBufferInfo, TextureInfo, TextureUsageBit, BufferTextureCopy, getTypedArrayConstructor, warnID, warn, BindingMappingInfo, Device, legacyCC, AttributeName, readBuffer, assertIsTrue, UBOMorph, assertIsNonNullable, ImageAsset, Texture2D, samplerLib, BufferInfo, nextPow2, log2, UNIFORM_TANGENT_MORPH_TEXTURE_BINDING, UNIFORM_NORMAL_MORPH_TEXTURE_BINDING, UNIFORM_POSITION_MORPH_TEXTURE_BINDING, Vec3, ccclass, _initializerDefineProperty, _assertThisInitialized, AABB, Quat, Asset, _applyDecoratedDescriptor, FormatType, murmurhash2_32_gc, Attribute, RenderingSubMesh, serializable, writeBuffer, PrimitiveMode, find, mapBuffer, Model, Enum, formerlySerializedAs, editable, type, executeInEditMode, TransformBit, builtinResMgr, RenderableComponent, disallowAnimation, Vec4, help, executionOrder, menu, tooltip, visible, Mat4, replaceProperty, removeProperty, CCString, js, LightType, Light$1, Component, slide, range, Color, DirectionalLight$1, unit, SphereLight$1, nt2lm, SpotLight$1, toRadian, genSamplerHash, Address, TextureBufferPool, getWorldTransformUntilRoot, SkelAnimDataHub, UBOSkinningAnimation, deleteTransform, getTransform, getWorldMatrix, AABBPool, AABBView, UBOSkinning, ModelType, UBOSkinningTexture, UNIFORM_JOINT_TEXTURE_BINDING, INST_JOINT_ANIM_INFO, Node, Material, Filter$1, PixelFormat, override, Vec2, AnimationState, Animation, Rect$1, Size, createMap, string, extname, mixin, Pool$1, director, Director, disallowMultiple, SystemEventType, displayOrder, ComparisonFunc, StencilOp, ccenum, BlendFactor, BlendTarget, requireComponent, displayName, multiline, MaterialInstance, Game, clamp$1, TextureBase, Camera, visibleRect, game, view, assetManager, PrivateNode, RenderPriority, InputAssemblerInfo, IAPool, NULL_HANDLE, Layers, BatchPool2D, BatchView2D, Pass, PassPool, clampf, addon, logID, SubModelPool, SubModelView, UBOLocal, DSPool, ModelLocalBindings, DescriptorSetInfo, downloader, factory, EventHandler, lerp, rangeMin, rangeMax, contains, screen, MINIGAME, JSB, RUNTIME_BASED, clamp01, EventTouch, Event, Scene, editorOnly, array, View, Ammo$1, equals$1, System, Eventify, readOnly, Sphere, absMax, fastRemoveAt, preTransforms;
    return {
        setters: [function (module) {
            Pool = module.P;
            RecyclePool = module.R;
            CachedArray = module.C;
            UniformProxyFactory = module.U;
            MorphWeightsValueProxy = module.M;
            MorphWeightsAllValueProxy = module.a;
            isPropertyPath = module.i;
            isCustomPath = module.b;
            HierarchyPath = module.H;
            ComponentPath = module.c;
            evaluatePath = module.e;
            CubicSplineVec2Value = module.d;
            CubicSplineVec3Value = module.f;
            CubicSplineVec4Value = module.g;
            CubicSplineQuatValue = module.h;
            CubicSplineNumberValue = module.j;
            _inheritsLoose = module._;
            DESCRIPTOR_BUFFER_TYPE = module.D;
            DESCRIPTOR_SAMPLER_TYPE = module.k;
            _createClass = module.l;
            DescriptorSet = module.m;
            Format = module.F;
            Rect = module.n;
            ClearFlag = module.o;
            DrawInfo = module.p;
            MemoryUsageBit = module.q;
            BufferUsageBit = module.B;
            TextureType = module.T;
            errorID = module.r;
            FormatInfos = module.s;
            FormatSize = module.t;
            SampleCount = module.S;
            LoadOp = module.L;
            ColorMask = module.u;
            CullMode = module.v;
            error = module.w;
            DynamicStateFlagBit = module.x;
            StencilFace = module.y;
            TextureFlagBit = module.z;
            Type$1 = module.A;
            ShaderStageFlagBit = module.E;
            IndirectBuffer = module.I;
            BufferFlagBit = module.G;
            Buffer = module.J;
            Viewport = module.V;
            CommandBufferType = module.K;
            CommandBuffer = module.N;
            Fence = module.O;
            Framebuffer = module.Q;
            InputAssembler = module.W;
            DESCRIPTOR_DYNAMIC_TYPE = module.X;
            DescriptorSetLayout = module.Y;
            PipelineLayout = module.Z;
            PipelineState = module.$;
            Queue = module.a0;
            RenderPass = module.a1;
            Filter = module.a2;
            Sampler = module.a3;
            Shader = module.a4;
            RasterizerState = module.a5;
            DepthStencilState = module.a6;
            BlendState = module.a7;
            IsPowerOf2 = module.a8;
            FormatSurfaceSize = module.a9;
            Texture = module.aa;
            macro = module.ab;
            API = module.ac;
            _createForOfIteratorHelperLoose = module.ad;
            sys = module.ae;
            WECHAT = module.af;
            Feature = module.ag;
            QueueInfo = module.ah;
            QueueType = module.ai;
            CommandBufferInfo = module.aj;
            TextureInfo = module.ak;
            TextureUsageBit = module.al;
            BufferTextureCopy = module.am;
            getTypedArrayConstructor = module.an;
            warnID = module.ao;
            warn = module.ap;
            BindingMappingInfo = module.aq;
            Device = module.ar;
            legacyCC = module.as;
            AttributeName = module.at;
            readBuffer = module.au;
            assertIsTrue = module.av;
            UBOMorph = module.aw;
            assertIsNonNullable = module.ax;
            ImageAsset = module.ay;
            Texture2D = module.az;
            samplerLib = module.aA;
            BufferInfo = module.aB;
            nextPow2 = module.aC;
            log2 = module.aD;
            UNIFORM_TANGENT_MORPH_TEXTURE_BINDING = module.aE;
            UNIFORM_NORMAL_MORPH_TEXTURE_BINDING = module.aF;
            UNIFORM_POSITION_MORPH_TEXTURE_BINDING = module.aG;
            Vec3 = module.aH;
            ccclass = module.aI;
            _initializerDefineProperty = module.aJ;
            _assertThisInitialized = module.aK;
            AABB = module.aL;
            Quat = module.aM;
            Asset = module.aN;
            _applyDecoratedDescriptor = module.aO;
            FormatType = module.aP;
            murmurhash2_32_gc = module.aQ;
            Attribute = module.aR;
            RenderingSubMesh = module.aS;
            serializable = module.aT;
            writeBuffer = module.aU;
            PrimitiveMode = module.aV;
            find = module.aW;
            mapBuffer = module.aX;
            Model = module.aY;
            Enum = module.aZ;
            formerlySerializedAs = module.a_;
            editable = module.a$;
            type = module.b0;
            executeInEditMode = module.b1;
            TransformBit = module.b2;
            builtinResMgr = module.b3;
            RenderableComponent = module.b4;
            disallowAnimation = module.b5;
            Vec4 = module.b6;
            help = module.b7;
            executionOrder = module.b8;
            menu = module.b9;
            tooltip = module.ba;
            visible = module.bb;
            Mat4 = module.bc;
            replaceProperty = module.bd;
            removeProperty = module.be;
            CCString = module.bf;
            js = module.bg;
            LightType = module.bh;
            Light$1 = module.bi;
            Component = module.bj;
            slide = module.bk;
            range = module.bl;
            Color = module.bm;
            DirectionalLight$1 = module.bn;
            unit = module.bo;
            SphereLight$1 = module.bp;
            nt2lm = module.bq;
            SpotLight$1 = module.br;
            toRadian = module.bs;
            genSamplerHash = module.bt;
            Address = module.bu;
            TextureBufferPool = module.bv;
            getWorldTransformUntilRoot = module.bw;
            SkelAnimDataHub = module.bx;
            UBOSkinningAnimation = module.by;
            deleteTransform = module.bz;
            getTransform = module.bA;
            getWorldMatrix = module.bB;
            AABBPool = module.bC;
            AABBView = module.bD;
            UBOSkinning = module.bE;
            ModelType = module.bF;
            UBOSkinningTexture = module.bG;
            UNIFORM_JOINT_TEXTURE_BINDING = module.bH;
            INST_JOINT_ANIM_INFO = module.bI;
            Node = module.bJ;
            Material = module.bK;
            Filter$1 = module.bL;
            PixelFormat = module.bM;
            override = module.bN;
            Vec2 = module.bO;
            AnimationState = module.bP;
            Animation = module.bQ;
            Rect$1 = module.bR;
            Size = module.bS;
            createMap = module.bT;
            string = module.bU;
            extname = module.bV;
            mixin = module.bW;
            Pool$1 = module.bX;
            director = module.bY;
            Director = module.bZ;
            disallowMultiple = module.b_;
            SystemEventType = module.b$;
            displayOrder = module.c0;
            ComparisonFunc = module.c1;
            StencilOp = module.c2;
            ccenum = module.c3;
            BlendFactor = module.c4;
            BlendTarget = module.c5;
            requireComponent = module.c6;
            displayName = module.c7;
            multiline = module.c8;
            MaterialInstance = module.c9;
            Game = module.ca;
            clamp$1 = module.cb;
            TextureBase = module.cc;
            Camera = module.cd;
            visibleRect = module.ce;
            game = module.cf;
            view = module.cg;
            assetManager = module.ch;
            PrivateNode = module.ci;
            RenderPriority = module.cj;
            InputAssemblerInfo = module.ck;
            IAPool = module.cl;
            NULL_HANDLE = module.cm;
            Layers = module.cn;
            BatchPool2D = module.co;
            BatchView2D = module.cp;
            Pass = module.cq;
            PassPool = module.cr;
            clampf = module.cs;
            addon = module.ct;
            logID = module.cu;
            SubModelPool = module.cv;
            SubModelView = module.cw;
            UBOLocal = module.cx;
            DSPool = module.cy;
            ModelLocalBindings = module.cz;
            DescriptorSetInfo = module.cA;
            downloader = module.cB;
            factory = module.cC;
            EventHandler = module.cD;
            lerp = module.cE;
            rangeMin = module.cF;
            rangeMax = module.cG;
            contains = module.cH;
            screen = module.cI;
            MINIGAME = module.cJ;
            JSB = module.cK;
            RUNTIME_BASED = module.cL;
            clamp01 = module.cM;
            EventTouch = module.cN;
            Event = module.cO;
            Scene = module.cP;
            editorOnly = module.cQ;
            array = module.cR;
            View = module.cS;
            Ammo$1 = module.cT;
            equals$1 = module.cU;
            System = module.cV;
            Eventify = module.cW;
            readOnly = module.cX;
            Sphere = module.cY;
            absMax = module.cZ;
            fastRemoveAt = module.c_;
            preTransforms = module.c$;
            var _setter = {};
            _setter.Acceleration = module.e9;
            _setter.AffineTransform = module.db;
            _setter.AnimCurve = module.fq;
            _setter.Animation = module.bQ;
            _setter.AnimationClip = module.fu;
            _setter.AnimationComponent = module.bQ;
            _setter.AnimationManager = module.fv;
            _setter.AnimationState = module.bP;
            _setter.Asset = module.aN;
            _setter.AssetLibrary = module.f9;
            _setter.AssetManager = module.f5;
            _setter.BaseNode = module.fb;
            _setter.BitMask = module.du;
            _setter.BufferAsset = module.dR;
            _setter.CCBoolean = module.dO;
            _setter.CCClass = module.dG;
            _setter.CCFloat = module.dN;
            _setter.CCInteger = module.dM;
            _setter.CCLoader = module.f7;
            _setter.CCObject = module.dH;
            _setter.CCString = module.bf;
            _setter.CachedArray = module.C;
            _setter.Camera = module.cd;
            _setter.CameraComponent = module.cd;
            _setter.Color = module.bm;
            _setter.CompactValueTypeArray = module.dP;
            _setter.Component = module.bj;
            _setter.ComponentModifier = module.fh;
            _setter.CubicSplineNumberValue = module.j;
            _setter.CubicSplineQuatValue = module.h;
            _setter.CubicSplineVec2Value = module.d;
            _setter.CubicSplineVec3Value = module.f;
            _setter.CubicSplineVec4Value = module.g;
            _setter.CurveValueAdapter = module.fi;
            _setter.DebugMode = module.e6;
            _setter.Details = module.dK;
            _setter.Director = module.bZ;
            _setter.EPSILON = module.df;
            _setter.EffectAsset = module.dX;
            _setter.Enum = module.aZ;
            _setter.Event = module.cO;
            _setter.EventAcceleration = module.ed;
            _setter.EventHandler = module.cD;
            _setter.EventInfo = module.fr;
            _setter.EventKeyboard = module.ee;
            _setter.EventMouse = module.ec;
            _setter.EventTarget = module.dQ;
            _setter.EventTouch = module.cN;
            _setter.Eventify = module.cW;
            _setter.ForwardFlow = module.e_;
            _setter.ForwardPipeline = module.eZ;
            _setter.ForwardStage = module.e$;
            _setter.GFXAPI = module.ac;
            _setter.GFXAddress = module.bu;
            _setter.GFXAttribute = module.aR;
            _setter.GFXAttributeName = module.at;
            _setter.GFXBindingMappingInfo = module.aq;
            _setter.GFXBlendFactor = module.c4;
            _setter.GFXBlendOp = module.ep;
            _setter.GFXBlendState = module.a7;
            _setter.GFXBlendTarget = module.c5;
            _setter.GFXBuffer = module.J;
            _setter.GFXBufferAccessBit = module.em;
            _setter.GFXBufferFlagBit = module.G;
            _setter.GFXBufferInfo = module.aB;
            _setter.GFXBufferTextureCopy = module.am;
            _setter.GFXBufferUsageBit = module.B;
            _setter.GFXBufferViewInfo = module.ei;
            _setter.GFXClearFlag = module.o;
            _setter.GFXColor = module.ex;
            _setter.GFXColorAttachment = module.eK;
            _setter.GFXColorMask = module.u;
            _setter.GFXCommandBuffer = module.N;
            _setter.GFXCommandBufferInfo = module.aj;
            _setter.GFXCommandBufferType = module.K;
            _setter.GFXComparisonFunc = module.c1;
            _setter.GFXCullMode = module.v;
            _setter.GFXDepthStencilAttachment = module.eL;
            _setter.GFXDepthStencilState = module.a6;
            _setter.GFXDescriptorSet = module.m;
            _setter.GFXDescriptorSetInfo = module.cA;
            _setter.GFXDescriptorSetLayout = module.Y;
            _setter.GFXDescriptorSetLayoutBinding = module.eE;
            _setter.GFXDescriptorSetLayoutInfo = module.eF;
            _setter.GFXDescriptorType = module.eq;
            _setter.GFXDevice = module.ar;
            _setter.GFXDeviceInfo = module.eC;
            _setter.GFXDrawInfo = module.p;
            _setter.GFXDynamicStateFlagBit = module.x;
            _setter.GFXExtent = module.ez;
            _setter.GFXFeature = module.ag;
            _setter.GFXFence = module.O;
            _setter.GFXFenceInfo = module.eJ;
            _setter.GFXFilter = module.a2;
            _setter.GFXFormat = module.F;
            _setter.GFXFormatInfo = module.ev;
            _setter.GFXFormatInfos = module.s;
            _setter.GFXFormatSize = module.t;
            _setter.GFXFormatSurfaceSize = module.a9;
            _setter.GFXFormatType = module.aP;
            _setter.GFXFramebuffer = module.Q;
            _setter.GFXFramebufferInfo = module.eD;
            _setter.GFXIndirectBuffer = module.I;
            _setter.GFXInputAssembler = module.W;
            _setter.GFXInputAssemblerInfo = module.ck;
            _setter.GFXInputState = module.eH;
            _setter.GFXLoadOp = module.L;
            _setter.GFXMemoryStatus = module.ew;
            _setter.GFXMemoryUsageBit = module.q;
            _setter.GFXObject = module.el;
            _setter.GFXObjectType = module.ek;
            _setter.GFXOffset = module.ey;
            _setter.GFXPipelineBindPoint = module.et;
            _setter.GFXPipelineLayout = module.Z;
            _setter.GFXPipelineLayoutInfo = module.eG;
            _setter.GFXPipelineState = module.$;
            _setter.GFXPipelineStateInfo = module.eI;
            _setter.GFXPolygonMode = module.en;
            _setter.GFXPrimitiveMode = module.aV;
            _setter.GFXQueue = module.a0;
            _setter.GFXQueueInfo = module.ah;
            _setter.GFXQueueType = module.ai;
            _setter.GFXRasterizerState = module.a5;
            _setter.GFXRect = module.n;
            _setter.GFXRenderPass = module.a1;
            _setter.GFXRenderPassInfo = module.eN;
            _setter.GFXSampleCount = module.S;
            _setter.GFXSampler = module.a3;
            _setter.GFXSamplerInfo = module.eO;
            _setter.GFXShadeModel = module.eo;
            _setter.GFXShader = module.a4;
            _setter.GFXShaderInfo = module.eT;
            _setter.GFXShaderStage = module.eP;
            _setter.GFXShaderStageFlagBit = module.E;
            _setter.GFXStencilFace = module.y;
            _setter.GFXStencilOp = module.c2;
            _setter.GFXStoreOp = module.er;
            _setter.GFXSubPassInfo = module.eM;
            _setter.GFXSurfaceTransform = module.eu;
            _setter.GFXTexture = module.aa;
            _setter.GFXTextureCopy = module.eB;
            _setter.GFXTextureFlagBit = module.z;
            _setter.GFXTextureInfo = module.ak;
            _setter.GFXTextureLayout = module.es;
            _setter.GFXTextureSubres = module.eA;
            _setter.GFXTextureType = module.T;
            _setter.GFXTextureUsageBit = module.al;
            _setter.GFXTextureViewInfo = module.eU;
            _setter.GFXType = module.A;
            _setter.GFXUniform = module.eQ;
            _setter.GFXUniformBlock = module.eR;
            _setter.GFXUniformSampler = module.eS;
            _setter.GFXViewport = module.V;
            _setter.GFX_DESCRIPTOR_BUFFER_TYPE = module.D;
            _setter.GFX_DESCRIPTOR_DYNAMIC_TYPE = module.X;
            _setter.GFX_DESCRIPTOR_SAMPLER_TYPE = module.k;
            _setter.GFX_DRAW_INFO_SIZE = module.eh;
            _setter.GFX_MAX_ATTACHMENTS = module.ej;
            _setter.Game = module.ca;
            _setter.HierachyModifier = module.fg;
            _setter.ImageAsset = module.ay;
            _setter.InstancedBuffer = module.f2;
            _setter.JavaScript = module.d_;
            _setter.JsonAsset = module.dV;
            _setter.Layers = module.cn;
            _setter.Mat3 = module.d9;
            _setter.Mat4 = module.bc;
            _setter.Material = module.bK;
            _setter.MissingScript = module.fd;
            _setter.Node = module.bJ;
            _setter.NodeActivator = module.fc;
            _setter.NodePool = module.fx;
            _setter.PipelineStateManager = module.f3;
            _setter.Pool = module.P;
            _setter.Prefab = module.dS;
            _setter.PrefabLink = module.dz;
            _setter.PrivateNode = module.ci;
            _setter.Quat = module.aM;
            _setter.RatioSampler = module.fp;
            _setter.Rect = module.bR;
            _setter.RecyclePool = module.R;
            _setter.RenderFlow = module.eX;
            _setter.RenderPipeline = module.eW;
            _setter.RenderStage = module.eY;
            _setter.RenderTexture = module.dY;
            _setter.RenderableComponent = module.b4;
            _setter.RenderingSubMesh = module.aS;
            _setter.ResolutionPolicy = module.e7;
            _setter.Scene = module.cP;
            _setter.SceneAsset = module.dT;
            _setter.Scheduler = module.eg;
            _setter.Script = module.dZ;
            _setter.ShadowFlow = module.f0;
            _setter.ShadowStage = module.f1;
            _setter.Size = module.bS;
            _setter.SkelAnimDataHub = module.bx;
            _setter.System = module.cV;
            _setter.SystemEvent = module.ea;
            _setter.SystemEventType = module.b$;
            _setter.TextAsset = module.dU;
            _setter.Texture2D = module.az;
            _setter.TextureCube = module.dW;
            _setter.Touch = module.ef;
            _setter.TypeScript = module.d$;
            _setter.UniformCurveValueAdapter = module.fj;
            _setter.ValueType = module.dv;
            _setter.Vec2 = module.bO;
            _setter.Vec3 = module.aH;
            _setter.Vec4 = module.b6;
            _setter.View = module.cS;
            _setter.WorldNode3DToLocalNodeUI = module.dC;
            _setter.WorldNode3DToWorldNodeUI = module.dD;
            _setter._decorator = module.dF;
            _setter.absMax = module.cZ;
            _setter.absMaxComponent = module.dt;
            _setter.approx = module.dg;
            _setter.assert = module.e1;
            _setter.assertID = module.e2;
            _setter.assetManager = module.ch;
            _setter.bezier = module.fn;
            _setter.bezierByTime = module.fo;
            _setter.bits = module.d4;
            _setter.builtinResMgr = module.b3;
            _setter.ccenum = module.c3;
            _setter.cclegacy = module.as;
            _setter.clamp = module.cb;
            _setter.clamp01 = module.cM;
            _setter.color = module.de;
            _setter.computeRatioByType = module.ft;
            _setter.convertUtils = module.dE;
            _setter.deserialize = module.dJ;
            _setter.director = module.bY;
            _setter.easing = module.ff;
            _setter.effects = module.fe;
            _setter.equals = module.cU;
            _setter.error = module.w;
            _setter.errorID = module.r;
            _setter.eventManager = module.e8;
            _setter.find = module.aW;
            _setter.game = module.cf;
            _setter.geometry = module.d2;
            _setter.getError = module.e5;
            _setter.getPathFromRoot = module.fw;
            _setter.getPhaseID = module.f4;
            _setter.getWorldTransformUntilRoot = module.bw;
            _setter.gfx = module.d3;
            _setter.instantiate = module.dL;
            _setter.inverseLerp = module.ds;
            _setter.isCustomTargetModifier = module.fm;
            _setter.isDisplayStats = module.e3;
            _setter.isElementModifier = module.fl;
            _setter.isPropertyModifier = module.fk;
            _setter.isValid = module.dI;
            _setter.js = module.dw;
            _setter.lerp = module.cE;
            _setter.loader = module.f8;
            _setter.log = module.e0;
            _setter.logID = module.cu;
            _setter.macro = module.ab;
            _setter.markAsWarning = module.dB;
            _setter.mat4 = module.da;
            _setter.math = module.d1;
            _setter.misc = module.dx;
            _setter.murmurhash2_32_gc = module.aQ;
            _setter.nextPow2 = module.dp;
            _setter.path = module.dy;
            _setter.pingPong = module.dr;
            _setter.pipeline = module.eV;
            _setter.pseudoRandom = module.dl;
            _setter.pseudoRandomRange = module.dm;
            _setter.pseudoRandomRangeInt = module.dn;
            _setter.quat = module.d8;
            _setter.random = module.di;
            _setter.randomRange = module.dj;
            _setter.randomRangeInt = module.dk;
            _setter.rect = module.dd;
            _setter.removeProperty = module.be;
            _setter.renderer = module.d0;
            _setter.repeat = module.dq;
            _setter.replaceProperty = module.bd;
            _setter.resources = module.f6;
            _setter.sampleAnimationCurve = module.fs;
            _setter.screen = module.cI;
            _setter.setDefaultLogTimes = module.dA;
            _setter.setDisplayStats = module.e4;
            _setter.size = module.dc;
            _setter.sys = module.ae;
            _setter.systemEvent = module.eb;
            _setter.toDegree = module.dh;
            _setter.toRadian = module.bs;
            _setter.url = module.fa;
            _setter.v2 = module.d5;
            _setter.v3 = module.d6;
            _setter.v4 = module.d7;
            _setter.view = module.cg;
            _setter.warn = module.ap;
            _setter.warnID = module.ao;
            exports(_setter);
        }],
        execute: function () {

            exports({
                CacheMode: void 0,
                EAxisDirection: void 0,
                ERigidBodyType: void 0,
                HorizontalTextAlignment: void 0,
                InstanceMaterialType: void 0,
                Overflow: void 0,
                VerticalTextAlignment: void 0,
                earcut: earcut,
                fragmentText: fragmentText,
                getBaselineOffset: getBaselineOffset,
                isUnicodeCJK: isUnicodeCJK,
                isUnicodeSpace: isUnicodeSpace,
                safeMeasureText: safeMeasureText
            });

            var index = /*#__PURE__*/Object.freeze({
                __proto__: null,
                Pool: Pool,
                RecyclePool: RecyclePool,
                CachedArray: CachedArray
            });
            exports('memop', index);

            var animation = /*#__PURE__*/Object.freeze({
                __proto__: null,
                UniformProxyFactory: UniformProxyFactory,
                MorphWeightsValueProxy: MorphWeightsValueProxy,
                MorphWeightsAllValueProxy: MorphWeightsAllValueProxy,
                isPropertyPath: isPropertyPath,
                isCustomPath: isCustomPath,
                HierarchyPath: HierarchyPath,
                ComponentPath: ComponentPath,
                evaluatePath: evaluatePath,
                CubicSplineVec2Value: CubicSplineVec2Value,
                CubicSplineVec3Value: CubicSplineVec3Value,
                CubicSplineVec4Value: CubicSplineVec4Value,
                CubicSplineQuatValue: CubicSplineQuatValue,
                CubicSplineNumberValue: CubicSplineNumberValue
            });
            exports('animation', animation);

            var WebGLDescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGLDescriptorSet, _DescriptorSet);

              function WebGLDescriptorSet() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }

              var _proto = WebGLDescriptorSet.prototype;

              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
                    bindings = _gpuDescriptorSetLayo.bindings,
                    descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
                    descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };

                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];

                  for (var j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    });
                  }
                }

                return true;
              };

              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };

              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      var buffer = this._buffers[i];

                      if (buffer) {
                        descriptors[i].gpuBuffer = buffer.gpuBuffer || buffer.gpuBufferView;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              };

              _createClass(WebGLDescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);

              return WebGLDescriptorSet;
            }(DescriptorSet);

            var WebGLEXT;

            (function (WebGLEXT) {
              WebGLEXT[WebGLEXT["RGBA16F_EXT"] = 34842] = "RGBA16F_EXT";
              WebGLEXT[WebGLEXT["RGB16F_EXT"] = 34843] = "RGB16F_EXT";
              WebGLEXT[WebGLEXT["RGBA32F_EXT"] = 34836] = "RGBA32F_EXT";
              WebGLEXT[WebGLEXT["FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT"] = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_NORMALIZED_EXT"] = 35863] = "UNSIGNED_NORMALIZED_EXT";
              WebGLEXT[WebGLEXT["UNSIGNED_INT_24_8_WEBGL"] = 34042] = "UNSIGNED_INT_24_8_WEBGL";
              WebGLEXT[WebGLEXT["HALF_FLOAT_OES"] = 36193] = "HALF_FLOAT_OES";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_S3TC_DXT1_EXT"] = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT1_EXT"] = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT3_EXT"] = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_S3TC_DXT5_EXT"] = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_S3TC_DXT1_EXT"] = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT"] = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT"] = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT"] = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_4BPPV1_IMG"] = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_PVRTC_2BPPV1_IMG"] = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_4BPPV1_IMG"] = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_PVRTC_2BPPV1_IMG"] = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB_ETC1_WEBGL"] = 36196] = "COMPRESSED_RGB_ETC1_WEBGL";
              WebGLEXT[WebGLEXT["COMPRESSED_R11_EAC"] = 37488] = "COMPRESSED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_R11_EAC"] = 37489] = "COMPRESSED_SIGNED_R11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RG11_EAC"] = 37490] = "COMPRESSED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SIGNED_RG11_EAC"] = 37491] = "COMPRESSED_SIGNED_RG11_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_ETC2"] = 37492] = "COMPRESSED_RGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ETC2"] = 37493] = "COMPRESSED_SRGB8_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2"] = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA8_ETC2_EAC"] = 37496] = "COMPRESSED_RGBA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ETC2_EAC"] = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_4x4_KHR"] = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x4_KHR"] = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_5x5_KHR"] = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x5_KHR"] = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_6x6_KHR"] = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x5_KHR"] = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x6_KHR"] = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_8x8_KHR"] = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x5_KHR"] = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x6_KHR"] = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x8_KHR"] = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_10x10_KHR"] = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x10_KHR"] = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_RGBA_ASTC_12x12_KHR"] = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR"] = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR"] = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR"] = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR"] = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR"] = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR"] = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR"] = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR"] = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR"] = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR"] = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR"] = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR"] = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR"] = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR";
              WebGLEXT[WebGLEXT["COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR"] = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR";
            })(WebGLEXT || (WebGLEXT = {}));

            function GFXFormatToWebGLType(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return WebGLEXT.HALF_FLOAT_OES;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.FLOAT;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB9E5:
                  return gl.UNSIGNED_BYTE;

                case Format.D16:
                  return gl.UNSIGNED_SHORT;

                case Format.D16S8:
                  return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                case Format.D24:
                  return gl.UNSIGNED_INT;

                case Format.D24S8:
                  return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                case Format.D32F:
                  return gl.UNSIGNED_INT;

                case Format.D32F_S8:
                  return WebGLEXT.UNSIGNED_INT_24_8_WEBGL;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4x4:
                case Format.ASTC_RGBA_5x4:
                case Format.ASTC_RGBA_5x5:
                case Format.ASTC_RGBA_6x5:
                case Format.ASTC_RGBA_6x6:
                case Format.ASTC_RGBA_8x5:
                case Format.ASTC_RGBA_8x6:
                case Format.ASTC_RGBA_8x8:
                case Format.ASTC_RGBA_10x5:
                case Format.ASTC_RGBA_10x6:
                case Format.ASTC_RGBA_10x8:
                case Format.ASTC_RGBA_10x10:
                case Format.ASTC_RGBA_12x10:
                case Format.ASTC_RGBA_12x12:
                case Format.ASTC_SRGBA_4x4:
                case Format.ASTC_SRGBA_5x4:
                case Format.ASTC_SRGBA_5x5:
                case Format.ASTC_SRGBA_6x5:
                case Format.ASTC_SRGBA_6x6:
                case Format.ASTC_SRGBA_8x5:
                case Format.ASTC_SRGBA_8x6:
                case Format.ASTC_SRGBA_8x8:
                case Format.ASTC_SRGBA_10x5:
                case Format.ASTC_SRGBA_10x6:
                case Format.ASTC_SRGBA_10x8:
                case Format.ASTC_SRGBA_10x10:
                case Format.ASTC_SRGBA_12x10:
                case Format.ASTC_SRGBA_12x12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.RGB8:
                  return gl.RGB;

                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGB32F:
                  return gl.RGB;

                case Format.BGRA8:
                  return gl.RGBA;

                case Format.RGBA8:
                  return gl.RGBA;

                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.D16:
                  return gl.DEPTH_COMPONENT;

                case Format.D16S8:
                  return gl.DEPTH_STENCIL;

                case Format.D24:
                  return gl.DEPTH_COMPONENT;

                case Format.D24S8:
                  return gl.DEPTH_STENCIL;

                case Format.D32F:
                  return gl.DEPTH_COMPONENT;

                case Format.D32F_S8:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12x12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12x12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.RGB8:
                  return gl.RGB;

                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGB32F:
                  return gl.RGB;

                case Format.BGRA8:
                  return gl.RGBA;

                case Format.RGBA8:
                  return gl.RGBA;

                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.D16:
                  return gl.DEPTH_COMPONENT;

                case Format.D16S8:
                  return gl.DEPTH_STENCIL;

                case Format.D24:
                  return gl.DEPTH_COMPONENT;

                case Format.D24S8:
                  return gl.DEPTH_STENCIL;

                case Format.D32F:
                  return gl.DEPTH_COMPONENT;

                case Format.D32F_S8:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12x12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12x12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function GFXTypeToTypedArrayCtor(type) {
              switch (type) {
                case Type$1.BOOL:
                case Type$1.BOOL2:
                case Type$1.BOOL3:
                case Type$1.BOOL4:
                case Type$1.INT:
                case Type$1.INT2:
                case Type$1.INT3:
                case Type$1.INT4:
                case Type$1.UINT:
                  return Int32Array;

                case Type$1.FLOAT:
                case Type$1.FLOAT2:
                case Type$1.FLOAT3:
                case Type$1.FLOAT4:
                case Type$1.MAT2:
                case Type$1.MAT3:
                case Type$1.MAT4:
                  return Float32Array;

                default:
                  {
                    console.error('Unsupported GLType, convert to TypedArrayConstructor failed.');
                    return Float32Array;
                  }
              }
            }

            function WebGLTypeToGFXType(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            var WebGLCmpFuncs = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            var WebGLStencilOps = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            var WebGLBlendOps = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            var WebGLBlendFactors = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            var WebGLCmd;

            (function (WebGLCmd) {
              WebGLCmd[WebGLCmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGLCmd[WebGLCmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGLCmd[WebGLCmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGLCmd[WebGLCmd["DRAW"] = 3] = "DRAW";
              WebGLCmd[WebGLCmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGLCmd[WebGLCmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGLCmd[WebGLCmd["COUNT"] = 6] = "COUNT";
            })(WebGLCmd || (WebGLCmd = {}));

            var WebGLCmdObject = function WebGLCmdObject(type) {
              this.cmdType = void 0;
              this.refCount = 0;
              this.cmdType = type;
            };
            var WebGLCmdBeginRenderPass = function (_WebGLCmdObject) {
              _inheritsLoose(WebGLCmdBeginRenderPass, _WebGLCmdObject);

              function WebGLCmdBeginRenderPass() {
                var _this;

                _this = _WebGLCmdObject.call(this, WebGLCmd.BEGIN_RENDER_PASS) || this;
                _this.gpuRenderPass = null;
                _this.gpuFramebuffer = null;
                _this.renderArea = new Rect();
                _this.clearFlag = ClearFlag.NONE;
                _this.clearColors = [];
                _this.clearDepth = 1.0;
                _this.clearStencil = 0;
                return _this;
              }

              var _proto = WebGLCmdBeginRenderPass.prototype;

              _proto.clear = function clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              };

              return WebGLCmdBeginRenderPass;
            }(WebGLCmdObject);
            var WebGLCmdBindStates = function (_WebGLCmdObject2) {
              _inheritsLoose(WebGLCmdBindStates, _WebGLCmdObject2);

              function WebGLCmdBindStates() {
                var _this2;

                _this2 = _WebGLCmdObject2.call(this, WebGLCmd.BIND_STATES) || this;
                _this2.gpuPipelineState = null;
                _this2.gpuInputAssembler = null;
                _this2.gpuDescriptorSets = [];
                _this2.dynamicOffsets = [];
                _this2.viewport = null;
                _this2.scissor = null;
                _this2.lineWidth = null;
                _this2.depthBias = null;
                _this2.blendConstants = [];
                _this2.depthBounds = null;
                _this2.stencilWriteMask = null;
                _this2.stencilCompareMask = null;
                return _this2;
              }

              var _proto2 = WebGLCmdBindStates.prototype;

              _proto2.clear = function clear() {
                this.gpuPipelineState = null;
                this.gpuDescriptorSets.length = 0;
                this.gpuInputAssembler = null;
                this.dynamicOffsets.length = 0;
                this.viewport = null;
                this.scissor = null;
                this.lineWidth = null;
                this.depthBias = null;
                this.blendConstants.length = 0;
                this.depthBounds = null;
                this.stencilWriteMask = null;
                this.stencilCompareMask = null;
              };

              return WebGLCmdBindStates;
            }(WebGLCmdObject);
            var WebGLCmdDraw = function (_WebGLCmdObject3) {
              _inheritsLoose(WebGLCmdDraw, _WebGLCmdObject3);

              function WebGLCmdDraw() {
                var _this3;

                _this3 = _WebGLCmdObject3.call(this, WebGLCmd.DRAW) || this;
                _this3.drawInfo = new DrawInfo();
                return _this3;
              }

              var _proto3 = WebGLCmdDraw.prototype;

              _proto3.clear = function clear() {};

              return WebGLCmdDraw;
            }(WebGLCmdObject);
            var WebGLCmdUpdateBuffer = function (_WebGLCmdObject4) {
              _inheritsLoose(WebGLCmdUpdateBuffer, _WebGLCmdObject4);

              function WebGLCmdUpdateBuffer() {
                var _this4;

                _this4 = _WebGLCmdObject4.call(this, WebGLCmd.UPDATE_BUFFER) || this;
                _this4.gpuBuffer = null;
                _this4.buffer = null;
                _this4.offset = 0;
                _this4.size = 0;
                return _this4;
              }

              var _proto4 = WebGLCmdUpdateBuffer.prototype;

              _proto4.clear = function clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              };

              return WebGLCmdUpdateBuffer;
            }(WebGLCmdObject);
            var WebGLCmdCopyBufferToTexture = function (_WebGLCmdObject5) {
              _inheritsLoose(WebGLCmdCopyBufferToTexture, _WebGLCmdObject5);

              function WebGLCmdCopyBufferToTexture() {
                var _this5;

                _this5 = _WebGLCmdObject5.call(this, WebGLCmd.COPY_BUFFER_TO_TEXTURE) || this;
                _this5.gpuTexture = null;
                _this5.buffers = [];
                _this5.regions = [];
                return _this5;
              }

              var _proto5 = WebGLCmdCopyBufferToTexture.prototype;

              _proto5.clear = function clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              };

              return WebGLCmdCopyBufferToTexture;
            }(WebGLCmdObject);
            var WebGLCmdPackage = function () {
              function WebGLCmdPackage() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
              }

              var _proto6 = WebGLCmdPackage.prototype;

              _proto6.clearCmds = function clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                this.cmds.clear();
              };

              return WebGLCmdPackage;
            }();
            function WebGLCmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                var glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.useVAO) {
                      if (cache.glVAO) {
                        device.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                      }
                    }

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

                var _glBuffer = gl.createBuffer();

                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.useVAO) {
                      if (cache.glVAO) {
                        device.OES_vertex_array_object.bindVertexArrayOES(null);
                        cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                      }
                    }

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.NONE;

                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncDestroyBuffer(device, gpuBuffer) {
              if (gpuBuffer.glBuffer) {
                device.gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGLCmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.useVAO) {
                  if (cache.glVAO) {
                    device.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                  }
                }

                if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                device.stateCache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.useVAO) {
                  if (cache.glVAO) {
                    device.OES_vertex_array_object.bindVertexArrayOES(null);
                    cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                  }
                }

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (gpuBuffer.buffer) {
                  gpuBuffer.vf32 = new Float32Array(gpuBuffer.buffer.buffer);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGLCmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (ArrayBuffer.isView(buffer)) {
                  gpuBuffer.vf32.set(buffer, offset / Float32Array.BYTES_PER_ELEMENT);
                } else {
                  gpuBuffer.vf32.set(new Float32Array(buffer), offset / Float32Array.BYTES_PER_ELEMENT);
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.length = offset;
                Array.prototype.push.apply(gpuBuffer.indirects, buffer.drawInfos);
              } else {
                var buff = buffer;
                var gl = device.gl;
                var cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (device.useVAO) {
                        if (cache.glVAO) {
                          device.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                        }
                      }

                      if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (device.useVAO) {
                        if (cache.glVAO) {
                          device.OES_vertex_array_object.bindVertexArrayOES(null);
                          cache.glVAO = gfxStateCache.gpuInputAssembler = null;
                        }
                      }

                      if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                      return;
                    }
                }

                if (size === buff.byteLength) {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                } else {
                  gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                }
              }
            }
            function WebGLCmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.maxTextureSize) {
                      errorID(9100, maxSize, device.maxTextureSize);
                    }

                    if (!device.WEBGL_depth_texture && FormatInfos[gpuTexture.format].hasDepth) {
                      var glRenderbuffer = gl.createRenderbuffer();

                      if (glRenderbuffer && gpuTexture.size > 0) {
                        gpuTexture.glRenderbuffer = glRenderbuffer;

                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        if (gpuTexture.glInternalFmt === gl.DEPTH_COMPONENT) {
                          gpuTexture.glInternalFmt = gl.DEPTH_COMPONENT16;
                        }

                        gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                      }
                    } else if (gpuTexture.samples === SampleCount.X1) {
                      var glTexture = gl.createTexture();

                      if (glTexture && gpuTexture.size > 0) {
                        gpuTexture.glTexture = glTexture;
                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (!FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          var _imgSize = FormatSize(gpuTexture.format, 2, 2, 1);

                          var _view = new Uint8Array(_imgSize);

                          gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view);
                        }

                        if (gpuTexture.isPowerOf2) {
                          gpuTexture.glWrapS = gl.REPEAT;
                          gpuTexture.glWrapT = gl.REPEAT;
                        } else {
                          gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                          gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                        }

                        gpuTexture.glMinFilter = gl.LINEAR;
                        gpuTexture.glMagFilter = gl.LINEAR;
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                      } else {
                        gl.deleteTexture(glTexture);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize = Math.max(w, h);

                    if (_maxSize > device.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize, device.maxTextureSize);
                    }

                    var _glTexture = gl.createTexture();

                    if (_glTexture && gpuTexture.size > 0) {
                      gpuTexture.glTexture = _glTexture;
                      var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (!FormatInfos[gpuTexture.format].isCompressed) {
                        for (var f = 0; f < 6; ++f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        for (var _f = 0; _f < 6; ++_f) {
                          w = gpuTexture.width;
                          h = gpuTexture.height;

                          for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                            var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                            var _view2 = new Uint8Array(_imgSize2);

                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, _view2);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        }
                      } else {
                        for (var _f2 = 0; _f2 < 6; ++_f2) {
                          var _imgSize3 = FormatSize(gpuTexture.format, 2, 2, 1);

                          var _view3 = new Uint8Array(_imgSize3);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view3);
                        }
                      }

                      if (gpuTexture.isPowerOf2) {
                        gpuTexture.glWrapS = gl.REPEAT;
                        gpuTexture.glWrapT = gl.REPEAT;
                      } else {
                        gpuTexture.glWrapS = gl.CLAMP_TO_EDGE;
                        gpuTexture.glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      gpuTexture.glMinFilter = gl.LINEAR;
                      gpuTexture.glMagFilter = gl.LINEAR;
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, gpuTexture.glWrapS);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, gpuTexture.glWrapT);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, gpuTexture.glMinFilter);
                      gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuTexture.glMagFilter);
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncDestroyTexture(device, gpuTexture) {
              if (gpuTexture.glTexture) {
                device.gl.deleteTexture(gpuTexture.glTexture);
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGLCmdFuncResizeTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.maxTextureSize) {
                      errorID(9100, maxSize, device.maxTextureSize);
                    }

                    if (gpuTexture.glRenderbuffer) {
                      if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                        gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                        device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                      }

                      gl.renderbufferStorage(gl.RENDERBUFFER, gpuTexture.glInternalFmt, w, h);
                    } else if (gpuTexture.glTexture) {
                      var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (!FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize2 = Math.max(w, h);

                    if (_maxSize2 > device.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize2, device.maxTextureSize);
                    }

                    var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      _glTexUnit2.glTexture = gpuTexture.glTexture;
                    }

                    if (!FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                      for (var _f3 = 0; _f3 < 6; ++_f3) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          var _imgSize4 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view4 = new Uint8Array(_imgSize4);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternalFmt, w, h, 0, _view4);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGLCmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              if (!gpuFramebuffer.gpuColorTextures.length && !gpuFramebuffer.gpuDepthStencilTexture) {
                return;
              }

              var gl = device.gl;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                  var gpuTexture = gpuFramebuffer.gpuColorTextures[i];

                  if (gpuTexture) {
                    if (gpuTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gpuTexture.glTarget, gpuTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + i);
                  }
                }

                var dst = gpuFramebuffer.gpuDepthStencilTexture;

                if (dst) {
                  var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }
                }

                if (device.WEBGL_draw_buffers) {
                  device.WEBGL_draw_buffers.drawBuffersWEBGL(attachments);
                }

                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGLCmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGLCmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl;

              var _loop = function _loop(k) {
                var gpuStage = gpuShader.gpuStages[k];
                var glShaderType = 0;
                var shaderTypeStr = '';
                var lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return {
                        v: void 0
                      };
                    }
                }

                var glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, gpuStage.source);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                      return "\n" + lineNumber++ + " ";
                    }));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                      var stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return {
                      v: void 0
                    };
                  }
                }
              };

              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                var _ret = _loop(k);

                if (typeof _ret === "object") return _ret.v;
              }

              var glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;

              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              if (device.destroyShadersImmediately) {
                for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                  var _gpuStage = gpuShader.gpuStages[_k2];

                  if (_gpuStage.glShader) {
                    gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                    gl.deleteShader(_gpuStage.glShader);
                    _gpuStage.glShader = null;
                  }
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                console.info("Shader '" + gpuShader.name + "' compilation succeeded.");
              } else {
                console.error("Failed to link shader '" + gpuShader.name + "'.");
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  var varName = void 0;
                  var nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var type = WebGLTypeToGFXType(attribInfo.type, gl);
                  var stride = WebGLGetTypeSize(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    binding: glLoc,
                    name: varName,
                    type: type,
                    stride: stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc: glLoc
                  };
                }
              }

              if (gpuShader.blocks.length > 0) {
                gpuShader.glBlocks = new Array(gpuShader.blocks.length);

                for (var _i7 = 0; _i7 < gpuShader.blocks.length; ++_i7) {
                  var block = gpuShader.blocks[_i7];
                  var glBlock = {
                    set: block.set,
                    binding: block.binding,
                    name: block.name,
                    size: 0,
                    glUniforms: new Array(block.members.length),
                    glActiveUniforms: []
                  };
                  gpuShader.glBlocks[_i7] = glBlock;

                  for (var u = 0; u < block.members.length; ++u) {
                    var uniform = block.members[u];
                    var glType = GFXTypeToWebGLType(uniform.type, gl);
                    var ctor = GFXTypeToTypedArrayCtor(uniform.type);

                    var _stride = WebGLGetTypeSize(glType, gl);

                    var size = _stride * uniform.count;
                    var begin = glBlock.size / 4;
                    var count = size / 4;
                    var array = new ctor(count);
                    glBlock.glUniforms[u] = {
                      binding: -1,
                      name: uniform.name,
                      type: uniform.type,
                      stride: _stride,
                      count: uniform.count,
                      size: size,
                      offset: glBlock.size,
                      glType: glType,
                      glLoc: -1,
                      array: array,
                      begin: begin
                    };
                    glBlock.size += size;
                  }
                }
              }

              if (gpuShader.samplers.length > 0) {
                gpuShader.glSamplers = new Array(gpuShader.samplers.length);

                for (var _i8 = 0; _i8 < gpuShader.samplers.length; ++_i8) {
                  var sampler = gpuShader.samplers[_i8];
                  gpuShader.glSamplers[_i8] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              var activeUniformCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORMS);

              for (var _i9 = 0; _i9 < activeUniformCount; ++_i9) {
                var uniformInfo = gl.getActiveUniform(gpuShader.glProgram, _i9);

                if (uniformInfo) {
                  var isSampler = uniformInfo.type === gl.SAMPLER_2D || uniformInfo.type === gl.SAMPLER_CUBE;

                  if (!isSampler) {
                    var _glLoc = gl.getUniformLocation(gpuShader.glProgram, uniformInfo.name);

                    if (_glLoc !== null && (typeof _glLoc === 'number' || _glLoc.id !== -1)) {
                      var _varName = void 0;

                      var _nameOffset = uniformInfo.name.indexOf('[');

                      if (_nameOffset !== -1) {
                        _varName = uniformInfo.name.substr(0, _nameOffset);
                      } else {
                        _varName = uniformInfo.name;
                      }

                      for (var j = 0; j < gpuShader.glBlocks.length; j++) {
                        var _glBlock = gpuShader.glBlocks[j];

                        for (var _k3 = 0; _k3 < _glBlock.glUniforms.length; _k3++) {
                          var glUniform = _glBlock.glUniforms[_k3];

                          if (glUniform.name === _varName) {
                            glUniform.glLoc = _glLoc;

                            _glBlock.glActiveUniforms.push(glUniform);

                            break;
                          }
                        }
                      }
                    }
                  }
                }
              }

              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var bindingMappingInfo = device.bindingMappingInfo;
              var texUnitCacheMap = device.stateCache.texUnitCacheMap;
              var flexibleSetBaseOffset = 0;

              for (var _i10 = 0; _i10 < gpuShader.blocks.length; ++_i10) {
                if (gpuShader.blocks[_i10].set === bindingMappingInfo.flexibleSet) {
                  flexibleSetBaseOffset++;
                }
              }

              var arrayOffset = 0;

              for (var _i11 = 0; _i11 < gpuShader.samplers.length; ++_i11) {
                var _sampler = gpuShader.samplers[_i11];

                var _glLoc2 = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

                if (_glLoc2 !== null && (typeof _glLoc2 === 'number' || _glLoc2.id !== -1)) {
                  glActiveSamplers.push(gpuShader.glSamplers[_i11]);
                  glActiveSamplerLocations.push(_glLoc2);
                }

                if (texUnitCacheMap[_sampler.name] === undefined) {
                  var binding = _sampler.binding + bindingMappingInfo.samplerOffsets[_sampler.set] + arrayOffset;

                  if (_sampler.set === bindingMappingInfo.flexibleSet) {
                    binding -= flexibleSetBaseOffset;
                  }

                  texUnitCacheMap[_sampler.name] = binding % device.maxTextureUnits;
                  arrayOffset += _sampler.count - 1;
                }
              }

              if (glActiveSamplers.length) {
                var usedTexUnits = [];

                for (var _i12 = 0; _i12 < glActiveSamplers.length; ++_i12) {
                  var glSampler = glActiveSamplers[_i12];
                  var cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i12];

                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                var unitIdx = 0;

                for (var _i13 = 0; _i13 < glActiveSamplers.length; ++_i13) {
                  var _glSampler = glActiveSamplers[_i13];

                  if (!_glSampler.glLoc) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i13];

                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.maxTextureUnits;
                      }

                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }

                      _glSampler.units.push(unitIdx);

                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (var _i14 = 0; _i14 < glActiveSamplers.length; _i14++) {
                  var _glSampler2 = glActiveSamplers[_i14];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              for (var _i15 = 0; _i15 < gpuShader.glBlocks.length;) {
                if (gpuShader.glBlocks[_i15].glActiveUniforms.length) {
                  _i15++;
                } else {
                  gpuShader.glBlocks[_i15] = gpuShader.glBlocks[gpuShader.glBlocks.length - 1];
                  gpuShader.glBlocks.length--;
                }
              }

              gpuShader.glSamplers = glActiveSamplers;
            }
            function WebGLCmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                var gl = device.gl;

                if (!device.destroyShadersImmediately) {
                  for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                    var gpuStage = gpuShader.gpuStages[k];

                    if (gpuStage.glShader) {
                      gl.detachShader(gpuShader.glProgram, gpuStage.glShader);
                      gl.deleteShader(gpuStage.glShader);
                      gpuStage.glShader = null;
                    }
                  }
                }

                gl.deleteProgram(gpuShader.glProgram);
                gpuShader.glProgram = null;
              }
            }
            function WebGLCmdFuncCreateInputAssember(device, gpuInputAssembler) {
              var gl = device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType(attrib.format, gl);
                var size = FormatInfos[attrib.format].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGLCmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();

              while (!res.done) {
                device.OES_vertex_array_object.deleteVertexArrayOES(res.value);
                res = it.next();
              }

              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              reverseCW: false,
              glPrimitive: 0
            };
            function WebGLCmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.stateCache;
              var clears = 0;

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                  var reverseCW = !!gpuFramebuffer.glFramebuffer;

                  if (reverseCW !== gfxStateCache.reverseCW) {
                    gfxStateCache.reverseCW = reverseCW;
                    var isCCW = !device.stateCache.rs.isFrontFaceCCW;
                    gl.frontFace(isCCW ? gl.CCW : gl.CW);
                    device.stateCache.rs.isFrontFaceCCW = isCCW;
                  }
                }

                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }

                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }

                var clearCount = clearColors.length;

                if (!device.WEBGL_draw_buffers) {
                  clearCount = 1;
                }

                for (var j = 0; j < clearCount; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          var clearColor = clearColors[0];
                          gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                          clears |= gl.COLOR_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            break;
                          }
                      }
                    }
                  }
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  var colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGLCmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, viewport, scissor, lineWidth, depthBias, blendConstants, depthBounds, stencilWriteMask, stencilCompareMask) {
              var gl = device.gl;
              var cache = device.stateCache;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;
              var glWrapS;
              var glWrapT;
              var glMinFilter;

              if (gpuPipelineState && gfxStateCache.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache.gpuPipelineState = gpuPipelineState;
                gfxStateCache.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuPipelineState.gpuShader) {
                  var glProgram = gpuPipelineState.gpuShader.glProgram;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                var rs = gpuPipelineState.rs;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    cache.rs.cullMode = rs.cullMode;
                  }

                  var isFrontFaceCCW = gfxStateCache.reverseCW ? !rs.isFrontFaceCCW : rs.isFrontFaceCCW;

                  if (cache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    cache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (cache.rs.depthBias !== rs.depthBias || cache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    cache.rs.depthBias = rs.depthBias;
                    cache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (cache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    cache.rs.lineWidth = rs.lineWidth;
                  }
                }

                var dss = gpuPipelineState.dss;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps[dss.stencilFailOpFront], WebGLStencilOps[dss.stencilZFailOpFront], WebGLStencilOps[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps[dss.stencilFailOpBack], WebGLStencilOps[dss.stencilZFailOpBack], WebGLStencilOps[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                var bs = gpuPipelineState.bs;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  var target0 = bs.targets[0];
                  var target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps[target0.blendEq], WebGLBlendOps[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors[target0.blendSrc], WebGLBlendFactors[target0.blendDst], WebGLBlendFactors[target0.blendSrcAlpha], WebGLBlendFactors[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIdx = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIdx >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIdx];
                  var vf32 = null;
                  var offset = 0;

                  if (gpuDescriptor && gpuDescriptor.gpuBuffer) {
                    var gpuBuffer = gpuDescriptor.gpuBuffer;
                    var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                    var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];

                    if (dynamicOffsetIndex >= 0) {
                      offset = dynamicOffsets[dynamicOffsetIndex];
                    }

                    if ('vf32' in gpuBuffer) {
                      vf32 = gpuBuffer.vf32;
                    } else {
                      offset += gpuBuffer.offset;
                      vf32 = gpuBuffer.gpuBuffer.vf32;
                    }

                    offset >>= 2;
                  }

                  if (!vf32) {
                    error("Buffer binding '" + glBlock.name + "' at set " + glBlock.set + " binding " + glBlock.binding + " is not bounded");
                    continue;
                  }

                  var uniformLen = glBlock.glActiveUniforms.length;

                  for (var l = 0; l < uniformLen; l++) {
                    var glUniform = glBlock.glActiveUniforms[l];

                    switch (glUniform.glType) {
                      case gl.BOOL:
                      case gl.INT:
                        {
                          for (var u = 0; u < glUniform.array.length; ++u) {
                            var idx = glUniform.begin + offset + u;

                            if (vf32[idx] !== glUniform.array[u]) {
                              for (var n = u, m = idx; n < glUniform.array.length; ++n, ++m) {
                                glUniform.array[n] = vf32[m];
                              }

                              gl.uniform1iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC2:
                      case gl.INT_VEC2:
                        {
                          for (var _u = 0; _u < glUniform.array.length; ++_u) {
                            var _idx = glUniform.begin + offset + _u;

                            if (vf32[_idx] !== glUniform.array[_u]) {
                              for (var _n = _u, _m = _idx; _n < glUniform.array.length; ++_n, ++_m) {
                                glUniform.array[_n] = vf32[_m];
                              }

                              gl.uniform2iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC3:
                      case gl.INT_VEC3:
                        {
                          for (var _u2 = 0; _u2 < glUniform.array.length; ++_u2) {
                            var _idx2 = glUniform.begin + offset + _u2;

                            if (vf32[_idx2] !== glUniform.array[_u2]) {
                              for (var _n2 = _u2, _m2 = _idx2; _n2 < glUniform.array.length; ++_n2, ++_m2) {
                                glUniform.array[_n2] = vf32[_m2];
                              }

                              gl.uniform3iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.BOOL_VEC4:
                      case gl.INT_VEC4:
                        {
                          for (var _u3 = 0; _u3 < glUniform.array.length; ++_u3) {
                            var _idx3 = glUniform.begin + offset + _u3;

                            if (vf32[_idx3] !== glUniform.array[_u3]) {
                              for (var _n3 = _u3, _m3 = _idx3; _n3 < glUniform.array.length; ++_n3, ++_m3) {
                                glUniform.array[_n3] = vf32[_m3];
                              }

                              gl.uniform4iv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT:
                        {
                          for (var _u4 = 0; _u4 < glUniform.array.length; ++_u4) {
                            var _idx4 = glUniform.begin + offset + _u4;

                            if (vf32[_idx4] !== glUniform.array[_u4]) {
                              for (var _n4 = _u4, _m4 = _idx4; _n4 < glUniform.array.length; ++_n4, ++_m4) {
                                glUniform.array[_n4] = vf32[_m4];
                              }

                              gl.uniform1fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC2:
                        {
                          for (var _u5 = 0; _u5 < glUniform.array.length; ++_u5) {
                            var _idx5 = glUniform.begin + offset + _u5;

                            if (vf32[_idx5] !== glUniform.array[_u5]) {
                              for (var _n5 = _u5, _m5 = _idx5; _n5 < glUniform.array.length; ++_n5, ++_m5) {
                                glUniform.array[_n5] = vf32[_m5];
                              }

                              gl.uniform2fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC3:
                        {
                          for (var _u6 = 0; _u6 < glUniform.array.length; ++_u6) {
                            var _idx6 = glUniform.begin + offset + _u6;

                            if (vf32[_idx6] !== glUniform.array[_u6]) {
                              for (var _n6 = _u6, _m6 = _idx6; _n6 < glUniform.array.length; ++_n6, ++_m6) {
                                glUniform.array[_n6] = vf32[_m6];
                              }

                              gl.uniform3fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_VEC4:
                        {
                          for (var _u7 = 0; _u7 < glUniform.array.length; ++_u7) {
                            var _idx7 = glUniform.begin + offset + _u7;

                            if (vf32[_idx7] !== glUniform.array[_u7]) {
                              for (var _n7 = _u7, _m7 = _idx7; _n7 < glUniform.array.length; ++_n7, ++_m7) {
                                glUniform.array[_n7] = vf32[_m7];
                              }

                              gl.uniform4fv(glUniform.glLoc, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT2:
                        {
                          for (var _u8 = 0; _u8 < glUniform.array.length; ++_u8) {
                            var _idx8 = glUniform.begin + offset + _u8;

                            if (vf32[_idx8] !== glUniform.array[_u8]) {
                              for (var _n8 = _u8, _m8 = _idx8; _n8 < glUniform.array.length; ++_n8, ++_m8) {
                                glUniform.array[_n8] = vf32[_m8];
                              }

                              gl.uniformMatrix2fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT3:
                        {
                          for (var _u9 = 0; _u9 < glUniform.array.length; ++_u9) {
                            var _idx9 = glUniform.begin + offset + _u9;

                            if (vf32[_idx9] !== glUniform.array[_u9]) {
                              for (var _n9 = _u9, _m9 = _idx9; _n9 < glUniform.array.length; ++_n9, ++_m9) {
                                glUniform.array[_n9] = vf32[_m9];
                              }

                              gl.uniformMatrix3fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }

                      case gl.FLOAT_MAT4:
                        {
                          for (var _u10 = 0; _u10 < glUniform.array.length; ++_u10) {
                            var _idx10 = glUniform.begin + offset + _u10;

                            if (vf32[_idx10] !== glUniform.array[_u10]) {
                              for (var _n10 = _u10, _m10 = _idx10; _n10 < glUniform.array.length; ++_n10, ++_m10) {
                                glUniform.array[_n10] = vf32[_m10];
                              }

                              gl.uniformMatrix4fv(glUniform.glLoc, false, glUniform.array);
                              break;
                            }
                          }

                          break;
                        }
                    }
                  }

                  continue;
                }

                var samplerLen = gpuShader.glSamplers.length;

                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplers[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];
                  var descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

                  var _gpuDescriptor = descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  var texUnitLen = glSampler.units.length;

                  for (var _l = 0; _l < texUnitLen; _l++) {
                    var texUnit = glSampler.units[_l];

                    if (!_gpuDescriptor || !_gpuDescriptor.gpuSampler) {
                      error("Sampler binding '" + glSampler.name + "' at set " + glSampler.set + " binding " + glSampler.binding + " index " + _l + " is not bounded");
                      continue;
                    }

                    if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                      var _gpuDescriptor2 = _gpuDescriptor,
                          gpuTexture = _gpuDescriptor2.gpuTexture;
                      var glTexUnit = cache.glTexUnits[texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      var _gpuDescriptor3 = _gpuDescriptor,
                          gpuSampler = _gpuDescriptor3.gpuSampler;

                      if (gpuTexture.isPowerOf2) {
                        glWrapS = gpuSampler.glWrapS;
                        glWrapT = gpuSampler.glWrapT;
                      } else {
                        glWrapS = gl.CLAMP_TO_EDGE;
                        glWrapT = gl.CLAMP_TO_EDGE;
                      }

                      if (gpuTexture.isPowerOf2) {
                        if (gpuTexture.mipLevel <= 1 && (gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR)) {
                          glMinFilter = gl.LINEAR;
                        } else {
                          glMinFilter = gpuSampler.glMinFilter;
                        }
                      } else if (gpuSampler.glMinFilter === gl.LINEAR || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_NEAREST || gpuSampler.glMinFilter === gl.LINEAR_MIPMAP_LINEAR) {
                        glMinFilter = gl.LINEAR;
                      } else {
                        glMinFilter = gl.NEAREST;
                      }

                      if (gpuTexture.glWrapS !== glWrapS) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_S, glWrapS);
                        gpuTexture.glWrapS = glWrapS;
                      }

                      if (gpuTexture.glWrapT !== glWrapT) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_WRAP_T, glWrapT);
                        gpuTexture.glWrapT = glWrapT;
                      }

                      if (gpuTexture.glMinFilter !== glMinFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MIN_FILTER, glMinFilter);
                        gpuTexture.glMinFilter = glMinFilter;
                      }

                      if (gpuTexture.glMagFilter !== gpuSampler.glMagFilter) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        gl.texParameteri(gpuTexture.glTarget, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                        gpuTexture.glMagFilter = gpuSampler.glMagFilter;
                      }
                    }

                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache.gpuInputAssembler = gpuInputAssembler;
                var ia = device.ANGLE_instanced_arrays;

                if (device.useVAO) {
                  var vao = device.OES_vertex_array_object;
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = vao.createVertexArrayOES();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    vao.bindVertexArrayOES(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;
                    var inputLen = gpuShader.glInputs.length;

                    for (var _j = 0; _j < inputLen; _j++) {
                      var glInput = gpuShader.glInputs[_j];
                      glAttrib = null;
                      var attribLen = gpuInputAssembler.glAttribs.length;

                      for (var k = 0; k < attribLen; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);

                          if (ia) {
                            ia.vertexAttribDivisorANGLE(glLoc, glAttrib.isInstanced ? 1 : 0);
                          }
                        }
                      }
                    }

                    var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (_gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
                    }

                    vao.bindVertexArrayOES(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    vao.bindVertexArrayOES(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < device.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  var _inputLen = gpuShader.glInputs.length;

                  for (var _j2 = 0; _j2 < _inputLen; _j2++) {
                    var _glInput = gpuShader.glInputs[_j2];
                    var _glAttrib = null;
                    var _attribLen = gpuInputAssembler.glAttribs.length;

                    for (var _k4 = 0; _k4 < _attribLen; _k4++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k4];

                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }

                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }

                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc3 = _glInput.glLoc + _c;

                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                        if (!cache.glEnabledAttribLocs[_glLoc3] && _glLoc3 >= 0) {
                          gl.enableVertexAttribArray(_glLoc3);
                          cache.glEnabledAttribLocs[_glLoc3] = true;
                        }

                        cache.glCurrentAttribLocs[_glLoc3] = true;
                        gl.vertexAttribPointer(_glLoc3, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);

                        if (ia) {
                          ia.vertexAttribDivisorANGLE(_glLoc3, _glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }
                  }

                  var _gpuBuffer2 = gpuInputAssembler.gpuIndexBuffer;

                  if (_gpuBuffer2) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer2.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer2.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer2.glBuffer;
                    }
                  }

                  for (var _a = 0; _a < device.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;

                for (var _j3 = 0; _j3 < dsLen; _j3++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_j3];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.VIEWPORT:
                      {
                        if (viewport) {
                          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                            cache.viewport.left = viewport.left;
                            cache.viewport.top = viewport.top;
                            cache.viewport.width = viewport.width;
                            cache.viewport.height = viewport.height;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.SCISSOR:
                      {
                        if (scissor) {
                          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                            cache.scissorRect.x = scissor.x;
                            cache.scissorRect.y = scissor.y;
                            cache.scissorRect.width = scissor.width;
                            cache.scissorRect.height = scissor.height;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (lineWidth) {
                          if (cache.rs.lineWidth !== lineWidth) {
                            gl.lineWidth(lineWidth);
                            cache.rs.lineWidth = lineWidth;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (depthBias) {
                          if (cache.rs.depthBias !== depthBias.constantFactor || cache.rs.depthBiasSlop !== depthBias.slopeFactor) {
                            gl.polygonOffset(depthBias.constantFactor, depthBias.slopeFactor);
                            cache.rs.depthBias = depthBias.constantFactor;
                            cache.rs.depthBiasSlop = depthBias.slopeFactor;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        if (cache.bs.blendColor.x !== blendConstants[0] || cache.bs.blendColor.y !== blendConstants[1] || cache.bs.blendColor.z !== blendConstants[2] || cache.bs.blendColor.w !== blendConstants[3]) {
                          gl.blendColor(blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3]);
                          cache.bs.blendColor.x = blendConstants[0];
                          cache.bs.blendColor.y = blendConstants[1];
                          cache.bs.blendColor.z = blendConstants[2];
                          cache.bs.blendColor.w = blendConstants[3];
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        if (stencilWriteMask) {
                          switch (stencilWriteMask.face) {
                            case StencilFace.FRONT:
                              {
                                if (cache.dss.stencilWriteMaskFront !== stencilWriteMask.writeMask) {
                                  gl.stencilMaskSeparate(gl.FRONT, stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask;
                                }

                                break;
                              }

                            case StencilFace.BACK:
                              {
                                if (cache.dss.stencilWriteMaskBack !== stencilWriteMask.writeMask) {
                                  gl.stencilMaskSeparate(gl.BACK, stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask;
                                }

                                break;
                              }

                            case StencilFace.ALL:
                              {
                                if (cache.dss.stencilWriteMaskFront !== stencilWriteMask.writeMask || cache.dss.stencilWriteMaskBack !== stencilWriteMask.writeMask) {
                                  gl.stencilMask(stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask;
                                  cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask;
                                }

                                break;
                              }
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        if (stencilCompareMask) {
                          switch (stencilCompareMask.face) {
                            case StencilFace.FRONT:
                              {
                                if (cache.dss.stencilRefFront !== stencilCompareMask.reference || cache.dss.stencilReadMaskFront !== stencilCompareMask.compareMask) {
                                  gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs[cache.dss.stencilFuncFront], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefFront = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask;
                                }

                                break;
                              }

                            case StencilFace.BACK:
                              {
                                if (cache.dss.stencilRefBack !== stencilCompareMask.reference || cache.dss.stencilReadMaskBack !== stencilCompareMask.compareMask) {
                                  gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefBack = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask;
                                }

                                break;
                              }

                            case StencilFace.ALL:
                              {
                                if (cache.dss.stencilRefFront !== stencilCompareMask.reference || cache.dss.stencilReadMaskFront !== stencilCompareMask.compareMask || cache.dss.stencilRefBack !== stencilCompareMask.reference || cache.dss.stencilReadMaskBack !== stencilCompareMask.compareMask) {
                                  gl.stencilFunc(WebGLCmpFuncs[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefFront = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask;
                                  cache.dss.stencilRefBack = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask;
                                }

                                break;
                              }
                          }
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGLCmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var ia = device.ANGLE_instanced_arrays;
              var gpuInputAssembler = gfxStateCache.gpuInputAssembler,
                  glPrimitive = gfxStateCache.glPrimitive;

              if (gpuInputAssembler) {
                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var diLen = gpuInputAssembler.gpuIndirectBuffer.indirects.length;

                  for (var j = 0; j < diLen; j++) {
                    var subDrawInfo = gpuInputAssembler.gpuIndirectBuffer.indirects[j];
                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (subDrawInfo.instanceCount && ia) {
                      if (gpuBuffer) {
                        if (subDrawInfo.indexCount > 0) {
                          var offset = subDrawInfo.firstIndex * gpuBuffer.stride;
                          ia.drawElementsInstancedANGLE(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, offset, subDrawInfo.instanceCount);
                        }
                      } else if (subDrawInfo.vertexCount > 0) {
                        ia.drawArraysInstancedANGLE(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount, subDrawInfo.instanceCount);
                      }
                    } else if (gpuBuffer) {
                      if (subDrawInfo.indexCount > 0) {
                        var _offset = subDrawInfo.firstIndex * gpuBuffer.stride;

                        gl.drawElements(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                      }
                    } else if (subDrawInfo.vertexCount > 0) {
                      gl.drawArrays(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount);
                    }
                  }
                } else {
                  var _gpuBuffer3 = gpuInputAssembler.gpuIndexBuffer;

                  if (drawInfo.instanceCount && ia) {
                    if (_gpuBuffer3) {
                      if (drawInfo.indexCount > 0) {
                        var _offset2 = drawInfo.firstIndex * _gpuBuffer3.stride;

                        ia.drawElementsInstancedANGLE(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset2, drawInfo.instanceCount);
                      }
                    } else if (drawInfo.vertexCount > 0) {
                      ia.drawArraysInstancedANGLE(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                    }
                  } else if (_gpuBuffer3) {
                    if (drawInfo.indexCount > 0) {
                      var _offset3 = drawInfo.firstIndex * _gpuBuffer3.stride;

                      gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset3);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                  }
                }
              }
            }
            var cmdIds = new Array(WebGLCmd.COUNT);
            function WebGLCmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds.fill(0);

              for (var i = 0; i < cmdPackage.cmds.length; ++i) {
                var cmd = cmdPackage.cmds.array[i];
                var cmdId = cmdIds[cmd]++;

                switch (cmd) {
                  case WebGLCmd.BEGIN_RENDER_PASS:
                    {
                      var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGLCmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGLCmd.BIND_STATES:
                    {
                      var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGLCmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.viewport, cmd2.scissor, cmd2.lineWidth, cmd2.depthBias, cmd2.blendConstants, cmd2.depthBounds, cmd2.stencilWriteMask, cmd2.stencilCompareMask);
                      break;
                    }

                  case WebGLCmd.DRAW:
                    {
                      var cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGLCmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGLCmd.UPDATE_BUFFER:
                    {
                      var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGLCmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGLCmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGLCmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }
                }
              }
            }
            function WebGLCmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _i16 = 0; _i16 < regions.length; _i16++) {
                      var _region = regions[_i16];
                      var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                      for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP && gpuTexture.isPowerOf2) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGLCmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var w = 1;
              var h = 1;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var isCompressed = fmtInfo.isCompressed;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var i = 0; i < regions.length; i++) {
                      var region = regions[i];
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      var pixels = buffers[n++];

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt === WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL || device.noCompressedTexSubImage2D) {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                      } else {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _i17 = 0; _i17 < regions.length; _i17++) {
                      var _region2 = regions[_i17];
                      var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                      for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                        w = _region2.texExtent.width;
                        h = _region2.texExtent.height;
                        var _pixels = buffers[n++];

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt === WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL || device.noCompressedTexSubImage2D) {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, _pixels);
                        } else {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }

            var WebGLBuffer = function (_Buffer) {
              _inheritsLoose(WebGLBuffer, _Buffer);

              function WebGLBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
                _this._gpuBuffer = null;
                _this._gpuBufferView = null;
                _this._uniformBuffer = null;
                return _this;
              }

              var _proto = WebGLBuffer.prototype;

              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBufferView = {
                    gpuBuffer: buffer.gpuBuffer,
                    offset: info.offset,
                    range: info.range
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;

                  if (this._usage & BufferUsageBit.INDIRECT) {
                    this._indirectBuffer = new IndirectBuffer();
                  }

                  if (this._flags & BufferFlagBit.BAKUP_BUFFER) {
                    this._bakcupBuffer = new Uint8Array(this._size);
                    this._device.memoryStatus.bufferSize += this._size;
                  }

                  if (this._usage & BufferUsageBit.UNIFORM && this._size > 0) {
                    this._uniformBuffer = new Uint8Array(this._size);
                  }

                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: this._bakcupBuffer,
                    vf32: null,
                    indirects: [],
                    glTarget: 0,
                    glBuffer: null
                  };

                  if (info.usage & BufferUsageBit.INDIRECT) {
                    this._gpuBuffer.indirects = this._indirectBuffer.drawInfos;
                  }

                  if (this._usage & BufferUsageBit.UNIFORM) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  }

                  WebGLCmdFuncCreateBuffer(this._device, this._gpuBuffer);
                  this._device.memoryStatus.bufferSize += this._size;
                }

                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  WebGLCmdFuncDestroyBuffer(this._device, this._gpuBuffer);
                  this._device.memoryStatus.bufferSize -= this._size;
                  this._gpuBuffer = null;
                }

                if (this._gpuBufferView) {
                  this._gpuBufferView = null;
                }

                this._bakcupBuffer = null;
              };

              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                var oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._bakcupBuffer) {
                  var oldView = this._bakcupBuffer;
                  this._bakcupBuffer = new Uint8Array(this._size);

                  this._bakcupBuffer.set(oldView);

                  this._device.memoryStatus.bufferSize -= oldSize;
                  this._device.memoryStatus.bufferSize += size;
                }

                if (this._uniformBuffer) {
                  this._uniformBuffer = new Uint8Array(size);
                }

                if (this._gpuBuffer) {
                  if (this._uniformBuffer) {
                    this._gpuBuffer.buffer = this._uniformBuffer;
                  } else if (this._bakcupBuffer) {
                    this._gpuBuffer.buffer = this._bakcupBuffer;
                  }

                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGLCmdFuncResizeBuffer(this._device, this._gpuBuffer);
                    this._device.memoryStatus.bufferSize -= oldSize;
                    this._device.memoryStatus.bufferSize += size;
                  }
                }
              };

              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                var buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                if (this._bakcupBuffer && buffer !== this._bakcupBuffer.buffer) {
                  var view = new Uint8Array(buffer, 0, size);

                  this._bakcupBuffer.set(view);
                }

                WebGLCmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, 0, buffSize);
              };

              _createClass(WebGLBuffer, [{
                key: "gpuBuffer",
                get: function get() {
                  return this._gpuBuffer;
                }
              }, {
                key: "gpuBufferView",
                get: function get() {
                  return this._gpuBufferView;
                }
              }]);

              return WebGLBuffer;
            }(Buffer);

            var WebGLCommandPool = function () {
              function WebGLCommandPool(clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (var i = 0; i < count; ++i) {
                  this._frees[i] = new clazz();
                }

                this._freeIdx = count - 1;
              }

              var _proto = WebGLCommandPool.prototype;

              _proto.alloc = function alloc(clazz) {
                if (this._freeIdx < 0) {
                  var size = this._frees.length * 2;
                  var temp = this._frees;
                  this._frees = new Array(size);
                  var increase = size - temp.length;

                  for (var i = 0; i < increase; ++i) {
                    this._frees[i] = new clazz();
                  }

                  for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
                    this._frees[_i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                var cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              };

              _proto.free = function free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              };

              _proto.freeCmds = function freeCmds(cmds) {
                for (var i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              };

              _proto.release = function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                  var cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              };

              return WebGLCommandPool;
            }();
            var WebGLCommandAllocator = function () {
              function WebGLCommandAllocator() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGLCommandPool(WebGLCmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGLCommandPool(WebGLCmdBindStates, 1);
                this.drawCmdPool = new WebGLCommandPool(WebGLCmdDraw, 1);
                this.updateBufferCmdPool = new WebGLCommandPool(WebGLCmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGLCommandPool(WebGLCmdCopyBufferToTexture, 1);
              }

              var _proto2 = WebGLCommandAllocator.prototype;

              _proto2.clearCmds = function clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              };

              _proto2.releaseCmds = function releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
              };

              return WebGLCommandAllocator;
            }();

            var WebGLCommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGLCommandBuffer, _CommandBuffer);

              function WebGLCommandBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
                _this.cmdPackage = new WebGLCmdPackage();
                _this._webGLAllocator = null;
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUInputAssembler = null;
                _this._curGPUDescriptorSets = [];
                _this._curDynamicOffsets = [];
                _this._curViewport = null;
                _this._curScissor = null;
                _this._curLineWidth = null;
                _this._curDepthBias = null;
                _this._curBlendConstants = [];
                _this._curDepthBounds = null;
                _this._curStencilWriteMask = null;
                _this._curStencilCompareMask = null;
                _this._isStateInvalied = false;
                return _this;
              }

              var _proto = WebGLCommandBuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                this._webGLAllocator = this._device.cmdAllocator;
                var setCount = this._device.bindingMappingInfo.bufferOffsets.length;

                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);

                  this._curDynamicOffsets.push([]);
                }

                return true;
              };

              _proto.destroy = function destroy() {
                if (this._webGLAllocator) {
                  this._webGLAllocator.clearCmds(this.cmdPackage);

                  this._webGLAllocator = null;
                }
              };

              _proto.begin = function begin(renderPass, subpass, frameBuffer) {

                this._webGLAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;

                for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                  this._curDynamicOffsets[i].length = 0;
                }

                this._curViewport = null;
                this._curScissor = null;
                this._curLineWidth = null;
                this._curDepthBias = null;
                this._curBlendConstants.length = 0;
                this._curDepthBounds = null;
                this._curStencilWriteMask = null;
                this._curStencilCompareMask = null;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };

              _proto.end = function end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              };

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGLCmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea = renderArea;
                cmd.clearColors.length = clearColors.length;

                for (var i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGLCmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              };

              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };

              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSet = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSet !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSet;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var offsets = this._curDynamicOffsets[set];

                  for (var i = 0; i < dynamicOffsets.length; i++) {
                    offsets[i] = dynamicOffsets[i];
                  }

                  offsets.length = dynamicOffsets.length;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              };

              _proto.setViewport = function setViewport(viewport) {
                if (!this._curViewport) {
                  this._curViewport = new Viewport(viewport.left, viewport.top, viewport.width, viewport.height, viewport.minDepth, viewport.maxDepth);
                } else if (this._curViewport.left !== viewport.left || this._curViewport.top !== viewport.top || this._curViewport.width !== viewport.width || this._curViewport.height !== viewport.height || this._curViewport.minDepth !== viewport.minDepth || this._curViewport.maxDepth !== viewport.maxDepth) {
                  this._curViewport.left = viewport.left;
                  this._curViewport.top = viewport.top;
                  this._curViewport.width = viewport.width;
                  this._curViewport.height = viewport.height;
                  this._curViewport.minDepth = viewport.minDepth;
                  this._curViewport.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                if (!this._curScissor) {
                  this._curScissor = new Rect(scissor.x, scissor.y, scissor.width, scissor.height);
                } else if (this._curScissor.x !== scissor.x || this._curScissor.y !== scissor.y || this._curScissor.width !== scissor.width || this._curScissor.height !== scissor.height) {
                  this._curScissor.x = scissor.x;
                  this._curScissor.y = scissor.y;
                  this._curScissor.width = scissor.width;
                  this._curScissor.height = scissor.height;
                  this._isStateInvalied = true;
                }
              };

              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curLineWidth !== lineWidth) {
                  this._curLineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                if (!this._curDepthBias) {
                  this._curDepthBias = {
                    constantFactor: depthBiasConstantFactor,
                    clamp: depthBiasClamp,
                    slopeFactor: depthBiasSlopeFactor
                  };
                  this._isStateInvalied = true;
                } else if (this._curDepthBias.constantFactor !== depthBiasConstantFactor || this._curDepthBias.clamp !== depthBiasClamp || this._curDepthBias.slopeFactor !== depthBiasSlopeFactor) {
                  this._curDepthBias.constantFactor = depthBiasConstantFactor;
                  this._curDepthBias.clamp = depthBiasClamp;
                  this._curDepthBias.slopeFactor = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              };

              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                if (blendConstants.length === 4 && (this._curBlendConstants[0] !== blendConstants[0] || this._curBlendConstants[1] !== blendConstants[1] || this._curBlendConstants[2] !== blendConstants[2] || this._curBlendConstants[3] !== blendConstants[3])) {
                  this._curBlendConstants.length = 0;
                  Array.prototype.push.apply(this._curBlendConstants, blendConstants);
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                if (!this._curDepthBounds) {
                  this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                  };
                  this._isStateInvalied = true;
                } else if (this._curDepthBounds.minBounds !== minDepthBounds || this._curDepthBounds.maxBounds !== maxDepthBounds) {
                  this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                  };
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                if (!this._curStencilWriteMask) {
                  this._curStencilWriteMask = {
                    face: face,
                    writeMask: writeMask
                  };
                  this._isStateInvalied = true;
                } else if (this._curStencilWriteMask.face !== face || this._curStencilWriteMask.writeMask !== writeMask) {
                  this._curStencilWriteMask.face = face;
                  this._curStencilWriteMask.writeMask = writeMask;
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                if (!this._curStencilCompareMask) {
                  this._curStencilCompareMask = {
                    face: face,
                    reference: reference,
                    compareMask: compareMask
                  };
                  this._isStateInvalied = true;
                } else if (this._curStencilCompareMask.face !== face || this._curStencilCompareMask.reference !== reference || this._curStencilCompareMask.compareMask !== compareMask) {
                  this._curStencilCompareMask.face = face;
                  this._curStencilCompareMask.reference = reference;
                  this._curStencilCompareMask.compareMask = compareMask;
                  this._isStateInvalied = true;
                }
              };

              _proto.draw = function draw(inputAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var cmd = this._webGLAllocator.drawCmdPool.alloc(WebGLCmdDraw);

                  cmd.drawInfo.vertexCount = inputAssembler.vertexCount;
                  cmd.drawInfo.firstVertex = inputAssembler.firstVertex;
                  cmd.drawInfo.indexCount = inputAssembler.indexCount;
                  cmd.drawInfo.firstIndex = inputAssembler.firstIndex;
                  cmd.drawInfo.vertexOffset = inputAssembler.vertexOffset;
                  cmd.drawInfo.instanceCount = inputAssembler.instanceCount;
                  cmd.drawInfo.firstInstance = inputAssembler.firstInstance;
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGLCmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += inputAssembler.instanceCount;
                  var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGLCmdUpdateBuffer);

                    var buffSize = 0;
                    var buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGLCmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGLCmdCopyBufferToTexture);

                    if (cmd) {
                      cmd.gpuTexture = gpuTexture;
                      cmd.regions = regions;
                      cmd.buffers = buffers;
                      this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                      this.cmdPackage.cmds.push(WebGLCmd.COPY_BUFFER_TO_TEXTURE);
                    }
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGLCmdBuff = cmdBuffs[i];

                  for (var c = 0; c < webGLCmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGLCmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (var _c = 0; _c < webGLCmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGLCmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(_cmd);
                  }

                  for (var _c2 = 0; _c2 < webGLCmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGLCmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount;
                    this.cmdPackage.drawCmds.push(_cmd2);
                  }

                  for (var _c3 = 0; _c3 < webGLCmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGLCmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount;
                    this.cmdPackage.updateBufferCmds.push(_cmd3);
                  }

                  for (var _c4 = 0; _c4 < webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGLCmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                  }

                  this.cmdPackage.cmds.concat(webGLCmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGLCmdBindStates);

                if (bindStatesCmd) {
                  bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                  Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);

                  for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                    Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets[i]);
                  }

                  bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                  bindStatesCmd.viewport = this._curViewport;
                  bindStatesCmd.scissor = this._curScissor;
                  bindStatesCmd.lineWidth = this._curLineWidth;
                  bindStatesCmd.depthBias = this._curDepthBias;
                  Array.prototype.push.apply(bindStatesCmd.blendConstants, this._curBlendConstants);
                  bindStatesCmd.depthBounds = this._curDepthBounds;
                  bindStatesCmd.stencilWriteMask = this._curStencilWriteMask;
                  bindStatesCmd.stencilCompareMask = this._curStencilCompareMask;
                  this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                  this.cmdPackage.cmds.push(WebGLCmd.BIND_STATES);
                  this._isStateInvalied = false;
                }
              };

              _createClass(WebGLCommandBuffer, [{
                key: "webGLDevice",
                get: function get() {
                  return this._device;
                }
              }]);

              return WebGLCommandBuffer;
            }(CommandBuffer);

            var WebGLFence = function (_Fence) {
              _inheritsLoose(WebGLFence, _Fence);

              function WebGLFence() {
                return _Fence.apply(this, arguments) || this;
              }

              var _proto = WebGLFence.prototype;

              _proto.initialize = function initialize(info) {
                return true;
              };

              _proto.destroy = function destroy() {};

              _proto.wait = function wait() {};

              _proto.reset = function reset() {};

              return WebGLFence;
            }(Fence);

            var WebGLFramebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGLFramebuffer, _Framebuffer);

              function WebGLFramebuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
                _this._gpuFramebuffer = null;
                return _this;
              }

              var _proto = WebGLFramebuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;

                if (info.depStencilMipmapLevel !== 0) {
                  console.warn('The mipmap level of th texture image to be attached of depth stencil attachment should be 0. Convert to 0.');
                }

                for (var i = 0; i < info.colorMipmapLevels.length; ++i) {
                  if (info.colorMipmapLevels[i] !== 0) {
                    console.warn("The mipmap level of th texture image to be attached of color attachment " + i + " should be 0. Convert to 0.");
                  }
                }

                var gpuColorTextures = [];

                for (var _i = 0; _i < info.colorTextures.length; ++_i) {
                  var colorTexture = info.colorTextures[_i];

                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                  }
                }

                var gpuDepthStencilTexture = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
                }

                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures: gpuColorTextures,
                  gpuDepthStencilTexture: gpuDepthStencilTexture,
                  glFramebuffer: null
                };
                WebGLCmdFuncCreateFramebuffer(this._device, this._gpuFramebuffer);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGLCmdFuncDestroyFramebuffer(this._device, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              };

              _createClass(WebGLFramebuffer, [{
                key: "gpuFramebuffer",
                get: function get() {
                  return this._gpuFramebuffer;
                }
              }]);

              return WebGLFramebuffer;
            }(Framebuffer);

            var WebGLInputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGLInputAssembler, _InputAssembler);

              function WebGLInputAssembler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }

              var _proto = WebGLInputAssembler.prototype;

              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return false;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._vertexCount = vertBuff.size / vertBuff.stride;
                  this._firstVertex = 0;
                  this._vertexOffset = 0;
                }

                this._instanceCount = 0;
                this._firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                var gpuIndexBuffer = null;
                var glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Error index buffer stride.');
                        }
                    }
                  }
                }

                var gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGLCmdFuncCreateInputAssember(this._device, this._gpuInputAssembler);
                return true;
              };

              _proto.destroy = function destroy() {
                var webglDev = this._device;

                if (this._gpuInputAssembler && webglDev.useVAO) {
                  WebGLCmdFuncDestroyInputAssembler(webglDev, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              };

              _createClass(WebGLInputAssembler, [{
                key: "gpuInputAssembler",
                get: function get() {
                  return this._gpuInputAssembler;
                }
              }]);

              return WebGLInputAssembler;
            }(InputAssembler);

            var WebGLDescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGLDescriptorSetLayout, _DescriptorSetLayout);

              function WebGLDescriptorSetLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }

              var _proto = WebGLDescriptorSetLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];

                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }

                var dynamicBindings = [];

                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];

                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };

              _createClass(WebGLDescriptorSetLayout, [{
                key: "gpuDescriptorSetLayout",
                get: function get() {
                  return this._gpuDescriptorSetLayout;
                }
              }]);

              return WebGLDescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGLPipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGLPipelineLayout, _PipelineLayout);

              function WebGLPipelineLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }

              var _proto = WebGLPipelineLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;

                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };

              _createClass(WebGLPipelineLayout, [{
                key: "gpuPipelineLayout",
                get: function get() {
                  return this._gpuPipelineLayout;
                }
              }]);

              return WebGLPipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            var WebGLPipelineState = function (_PipelineState) {
              _inheritsLoose(WebGLPipelineState, _PipelineState);

              function WebGLPipelineState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
                _this._gpuPipelineState = null;
                return _this;
              }

              var _proto = WebGLPipelineState.prototype;

              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;

                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;

                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];

                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates: dynamicStates
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };

              _createClass(WebGLPipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);

              return WebGLPipelineState;
            }(PipelineState);

            var _dynamicOffsets = [];
            var WebGLPrimaryCommandBuffer = function (_WebGLCommandBuffer) {
              _inheritsLoose(WebGLPrimaryCommandBuffer, _WebGLCommandBuffer);

              function WebGLPrimaryCommandBuffer() {
                return _WebGLCommandBuffer.apply(this, arguments) || this;
              }

              var _proto = WebGLPrimaryCommandBuffer.prototype;

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGLCmdFuncBeginRenderPass(this._device, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };

              _proto.draw = function draw(inputAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  WebGLCmdFuncDraw(this._device, inputAssembler);
                  ++this._numDrawCalls;
                  this._numInstances += inputAssembler.instanceCount;
                  var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGLCmdFuncUpdateBuffer(this._device, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGLCmdFuncCopyBuffersToTexture(this._device, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGLCmdBuff = cmdBuffs[i];
                  WebGLCmdFuncExecuteCmds(this._device, webGLCmdBuff.cmdPackage);
                  this._numDrawCalls += webGLCmdBuff._numDrawCalls;
                  this._numInstances += webGLCmdBuff._numInstances;
                  this._numTris += webGLCmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                _dynamicOffsets.length = 0;

                for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                  Array.prototype.push.apply(_dynamicOffsets, this._curDynamicOffsets[i]);
                }

                WebGLCmdFuncBindStates(this._device, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, _dynamicOffsets, this._curViewport, this._curScissor, this._curLineWidth, this._curDepthBias, this._curBlendConstants, this._curDepthBounds, this._curStencilWriteMask, this._curStencilCompareMask);
                this._isStateInvalied = false;
              };

              return WebGLPrimaryCommandBuffer;
            }(WebGLCommandBuffer);

            var WebGLQueue = function (_Queue) {
              _inheritsLoose(WebGLQueue, _Queue);

              function WebGLQueue() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }

              var _proto = WebGLQueue.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                return true;
              };

              _proto.destroy = function destroy() {};

              _proto.submit = function submit(cmdBuffs, fence) {
                if (!this._isAsync) {
                  var len = cmdBuffs.length;

                  for (var i = 0; i < len; i++) {
                    var cmdBuff = cmdBuffs[i];
                    this.numDrawCalls += cmdBuff.numDrawCalls;
                    this.numInstances += cmdBuff.numInstances;
                    this.numTris += cmdBuff.numTris;
                  }
                }
              };

              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };

              return WebGLQueue;
            }(Queue);

            var WebGLRenderPass = function (_RenderPass) {
              _inheritsLoose(WebGLRenderPass, _RenderPass);

              function WebGLRenderPass() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
                _this._gpuRenderPass = null;
                return _this;
              }

              var _proto = WebGLRenderPass.prototype;

              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;

                if (info.subPasses) {
                  this._subPasses = info.subPasses;
                }

                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
                return true;
              };

              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };

              _createClass(WebGLRenderPass, [{
                key: "gpuRenderPass",
                get: function get() {
                  return this._gpuRenderPass;
                }
              }]);

              return WebGLRenderPass;
            }(RenderPass);

            var WebGLWraps = [0x2901, 0x8370, 0x812F, 0x812F];
            var WebGLSampler = function (_Sampler) {
              _inheritsLoose(WebGLSampler, _Sampler);

              function WebGLSampler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Sampler.call.apply(_Sampler, [this].concat(args)) || this;
                _this._gpuSampler = null;
                return _this;
              }

              var _proto = WebGLSampler.prototype;

              _proto.initialize = function initialize(info) {
                this._minFilter = info.minFilter;
                this._magFilter = info.magFilter;
                this._mipFilter = info.mipFilter;
                this._addressU = info.addressU;
                this._addressV = info.addressV;
                this._addressW = info.addressW;
                this._maxAnisotropy = info.maxAnisotropy;
                this._cmpFunc = info.cmpFunc;
                this._borderColor = info.borderColor;
                this._minLOD = info.minLOD;
                this._maxLOD = info.maxLOD;
                this._mipLODBias = info.mipLODBias;
                var glMinFilter = 0;
                var glMagFilter = 0;
                var minFilter = this._minFilter;
                var magFilter = this._magFilter;
                var mipFilter = this._mipFilter;

                if (minFilter === Filter.LINEAR || minFilter === Filter.ANISOTROPIC) {
                  if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                    glMinFilter = 0x2703;
                  } else if (mipFilter === Filter.POINT) {
                    glMinFilter = 0x2701;
                  } else {
                    glMinFilter = 0x2601;
                  }
                } else if (mipFilter === Filter.LINEAR || mipFilter === Filter.ANISOTROPIC) {
                  glMinFilter = 0x2702;
                } else if (mipFilter === Filter.POINT) {
                  glMinFilter = 0x2700;
                } else {
                  glMinFilter = 0x2600;
                }

                if (magFilter === Filter.LINEAR || magFilter === Filter.ANISOTROPIC) {
                  glMagFilter = 0x2601;
                } else {
                  glMagFilter = 0x2600;
                }

                var glWrapS = WebGLWraps[this._addressU];
                var glWrapT = WebGLWraps[this._addressV];
                var glWrapR = WebGLWraps[this._addressW];
                this._gpuSampler = {
                  glMinFilter: glMinFilter,
                  glMagFilter: glMagFilter,
                  glWrapS: glWrapS,
                  glWrapT: glWrapT,
                  glWrapR: glWrapR
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._gpuSampler = null;
              };

              _createClass(WebGLSampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);

              return WebGLSampler;
            }(Sampler);

            var WebGLShader = function (_Shader) {
              _inheritsLoose(WebGLShader, _Shader);

              function WebGLShader() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
                _this._gpuShader = null;
                return _this;
              }

              var _proto = WebGLShader.prototype;

              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks,
                  samplers: info.samplers,
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplers: []
                };

                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }

                WebGLCmdFuncCreateShader(this._device, this._gpuShader);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGLCmdFuncDestroyShader(this._device, this._gpuShader);
                  this._gpuShader = null;
                }
              };

              _createClass(WebGLShader, [{
                key: "gpuShader",
                get: function get() {
                  return this._gpuShader;
                }
              }]);

              return WebGLShader;
            }(Shader);

            var WebGLStateCache = function () {
              function WebGLStateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              var _proto = WebGLStateCache.prototype;

              _proto.initialize = function initialize(texUnit, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  this.glTexUnits.push({
                    glTexture: null
                  });
                }

                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };

              return WebGLStateCache;
            }();

            var WebGLTexture = function (_Texture) {
              _inheritsLoose(WebGLTexture, _Texture);

              function WebGLTexture() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
                _this._gpuTexture = null;
                return _this;
              }

              var _proto = WebGLTexture.prototype;

              _proto.initialize = function initialize(info) {
                if ('texture' in info) {
                  console.log('WebGL does not support texture view.');
                  return false;
                }

                this._type = info.type;
                this._usage = info.usage;
                this._format = info.format;
                this._width = info.width;
                this._height = info.height;
                this._depth = info.depth;
                this._layerCount = info.layerCount;
                this._levelCount = info.levelCount;
                this._samples = info.samples;
                this._flags = info.flags;
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height);
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._flags & TextureFlagBit.BAKUP_BUFFER) {
                  this._buffer = new ArrayBuffer(this._size);
                }

                this._gpuTexture = {
                  type: this._type,
                  format: this._format,
                  usage: this._usage,
                  width: this._width,
                  height: this._height,
                  depth: this._depth,
                  size: this._size,
                  arrayLayer: this._layerCount,
                  mipLevel: this._levelCount,
                  samples: this._samples,
                  flags: this._flags,
                  isPowerOf2: this._isPowerOf2,
                  glTarget: 0,
                  glInternalFmt: 0,
                  glFormat: 0,
                  glType: 0,
                  glUsage: 0,
                  glTexture: null,
                  glRenderbuffer: null,
                  glWrapS: 0,
                  glWrapT: 0,
                  glMinFilter: 0,
                  glMagFilter: 0
                };
                WebGLCmdFuncCreateTexture(this._device, this._gpuTexture);
                this._device.memoryStatus.textureSize += this._size;
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuTexture) {
                  WebGLCmdFuncDestroyTexture(this._device, this._gpuTexture);
                  this._device.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }

                this._buffer = null;
              };

              _proto.resize = function resize(width, height) {
                var oldSize = this._size;
                this._width = width;
                this._height = height;
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;
                  WebGLCmdFuncResizeTexture(this._device, this._gpuTexture);
                  this._device.memoryStatus.textureSize -= oldSize;
                  this._device.memoryStatus.textureSize += this._size;
                }
              };

              _createClass(WebGLTexture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }]);

              return WebGLTexture;
            }(Texture);

            var eventWebGLContextLost = 'webglcontextlost';
            var WebGLDevice = exports('WebGLDevice', function (_Device) {
              _inheritsLoose(WebGLDevice, _Device);

              function WebGLDevice() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Device.call.apply(_Device, [this].concat(args)) || this;
                _this.stateCache = new WebGLStateCache();
                _this.cmdAllocator = new WebGLCommandAllocator();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._webGLRC = null;
                _this._isAntialias = true;
                _this._isPremultipliedAlpha = true;
                _this._useVAO = false;
                _this._destroyShadersImmediately = true;
                _this._noCompressedTexSubImage2D = false;
                _this._bindingMappingInfo = new BindingMappingInfo();
                _this._webGLContextLostHandler = null;
                _this._extensions = null;
                _this._EXT_texture_filter_anisotropic = null;
                _this._EXT_blend_minmax = null;
                _this._EXT_frag_depth = null;
                _this._EXT_shader_texture_lod = null;
                _this._EXT_sRGB = null;
                _this._OES_vertex_array_object = null;
                _this._EXT_color_buffer_half_float = null;
                _this._WEBGL_color_buffer_float = null;
                _this._WEBGL_compressed_texture_etc1 = null;
                _this._WEBGL_compressed_texture_etc = null;
                _this._WEBGL_compressed_texture_pvrtc = null;
                _this._WEBGL_compressed_texture_astc = null;
                _this._WEBGL_compressed_texture_s3tc = null;
                _this._WEBGL_compressed_texture_s3tc_srgb = null;
                _this._WEBGL_debug_shaders = null;
                _this._WEBGL_draw_buffers = null;
                _this._WEBGL_lose_context = null;
                _this._WEBGL_depth_texture = null;
                _this._WEBGL_debug_renderer_info = null;
                _this._OES_texture_half_float = null;
                _this._OES_texture_half_float_linear = null;
                _this._OES_texture_float = null;
                _this._OES_texture_float_linear = null;
                _this._OES_standard_derivatives = null;
                _this._OES_element_index_uint = null;
                _this._ANGLE_instanced_arrays = null;
                return _this;
              }

              var _proto = WebGLDevice.prototype;

              _proto.initialize = function initialize(info) {
                this._canvas = info.canvasElm;
                this._isAntialias = info.isAntialias;
                this._isPremultipliedAlpha = info.isPremultipliedAlpha;
                this._bindingMappingInfo = info.bindingMappingInfo;
                if (!this._bindingMappingInfo.bufferOffsets.length) this._bindingMappingInfo.bufferOffsets.push(0);
                if (!this._bindingMappingInfo.samplerOffsets.length) this._bindingMappingInfo.samplerOffsets.push(0);

                try {
                  var webGLCtxAttribs = {
                    alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                    antialias: this._isAntialias,
                    depth: true,
                    stencil: true,
                    premultipliedAlpha: this._isPremultipliedAlpha,
                    preserveDrawingBuffer: false,
                    powerPreference: 'default',
                    failIfMajorPerformanceCaveat: false
                  };
                  this._webGLRC = this._canvas.getContext('webgl', webGLCtxAttribs);
                } catch (err) {
                  console.error(err);
                  return false;
                }

                if (!this._webGLRC) {
                  console.error('This device does not support WebGL.');
                  return false;
                }

                this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost, this._onWebGLContextLost);

                this._canvas2D = document.createElement('canvas');
                console.info('WebGL device initialized.');
                this._gfxAPI = API.WEBGL;
                this._deviceName = 'WebGL';
                var gl = this._webGLRC;
                this._WEBGL_debug_renderer_info = this.getExtension('WEBGL_debug_renderer_info');

                if (this._WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                this._version = gl.getParameter(gl.VERSION);
                this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._depthBits = gl.getParameter(gl.DEPTH_BITS);
                this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
                this.stateCache.initialize(this._maxTextureUnits, this._maxVertexAttributes);

                this._devicePixelRatio = info.devicePixelRatio || 1.0;
                this._width = this._canvas.width;
                this._height = this._canvas.height;
                this._nativeWidth = Math.max(info.nativeWidth || this._width, 0);
                this._nativeHeight = Math.max(info.nativeHeight || this._height, 0);
                this._colorFmt = Format.RGBA8;

                if (this._depthBits === 24) {
                  if (this._stencilBits === 8) {
                    this._depthStencilFmt = Format.D24S8;
                  } else {
                    this._depthStencilFmt = Format.D24;
                  }
                } else if (this._stencilBits === 8) {
                  this._depthStencilFmt = Format.D16S8;
                } else {
                  this._depthStencilFmt = Format.D16;
                }

                this._extensions = gl.getSupportedExtensions();
                var extensions = '';

                if (this._extensions) {
                  for (var _iterator = _createForOfIteratorHelperLoose(this._extensions), _step; !(_step = _iterator()).done;) {
                    var ext = _step.value;
                    extensions += ext + " ";
                  }

                  console.debug("EXTENSIONS: " + extensions);
                }

                this._EXT_texture_filter_anisotropic = this.getExtension('EXT_texture_filter_anisotropic');
                this._EXT_blend_minmax = this.getExtension('EXT_blend_minmax');
                this._EXT_frag_depth = this.getExtension('EXT_frag_depth');
                this._EXT_shader_texture_lod = this.getExtension('EXT_shader_texture_lod');
                this._EXT_sRGB = this.getExtension('EXT_sRGB');
                this._OES_vertex_array_object = this.getExtension('OES_vertex_array_object');
                this._EXT_color_buffer_half_float = this.getExtension('EXT_color_buffer_half_float');
                this._WEBGL_color_buffer_float = this.getExtension('WEBGL_color_buffer_float');
                this._WEBGL_compressed_texture_etc1 = this.getExtension('WEBGL_compressed_texture_etc1');
                this._WEBGL_compressed_texture_etc = this.getExtension('WEBGL_compressed_texture_etc');
                this._WEBGL_compressed_texture_pvrtc = this.getExtension('WEBGL_compressed_texture_pvrtc');
                this._WEBGL_compressed_texture_s3tc = this.getExtension('WEBGL_compressed_texture_s3tc');
                this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension('WEBGL_compressed_texture_s3tc_srgb');
                this._WEBGL_debug_shaders = this.getExtension('WEBGL_debug_shaders');
                this._WEBGL_draw_buffers = this.getExtension('WEBGL_draw_buffers');
                this._WEBGL_lose_context = this.getExtension('WEBGL_lose_context');
                this._WEBGL_depth_texture = this.getExtension('WEBGL_depth_texture');
                this._OES_texture_half_float = this.getExtension('OES_texture_half_float');
                this._OES_texture_half_float_linear = this.getExtension('OES_texture_half_float_linear');
                this._OES_texture_float = this.getExtension('OES_texture_float');
                this._OES_texture_float_linear = this.getExtension('OES_texture_float_linear');
                this._OES_standard_derivatives = this.getExtension('OES_standard_derivatives');
                this._OES_element_index_uint = this.getExtension('OES_element_index_uint');
                this._ANGLE_instanced_arrays = this.getExtension('ANGLE_instanced_arrays');
                {
                  if (sys.os !== sys.OS_IOS || sys.osMainVersion !== 14 || !sys.isBrowser) {
                    this._WEBGL_compressed_texture_astc = this.getExtension('WEBGL_compressed_texture_astc');
                  }

                  if (sys.browserType === sys.BROWSER_TYPE_UC) {
                    this._ANGLE_instanced_arrays = null;
                  }

                  if (sys.os === sys.OS_IOS && sys.osMainVersion <= 10 || WECHAT ) {
                    this._destroyShadersImmediately = false;
                  }
                }

                this._features.fill(false);

                if (this._EXT_blend_minmax) {
                  this._features[Feature.BLEND_MINMAX] = true;
                }

                if (this._WEBGL_color_buffer_float) {
                  this._features[Feature.COLOR_FLOAT] = true;
                }

                if (this._EXT_color_buffer_half_float) {
                  this._features[Feature.COLOR_HALF_FLOAT] = true;
                }

                if (this._OES_texture_float) {
                  this._features[Feature.TEXTURE_FLOAT] = true;
                }

                if (this._OES_texture_half_float) {
                  this._features[Feature.TEXTURE_HALF_FLOAT] = true;
                }

                if (this._OES_texture_float_linear) {
                  this._features[Feature.TEXTURE_FLOAT_LINEAR] = true;
                }

                if (this._OES_texture_half_float_linear) {
                  this._features[Feature.TEXTURE_HALF_FLOAT_LINEAR] = true;
                }

                this._features[Feature.FORMAT_RGB8] = true;

                if (this._WEBGL_depth_texture) {
                  this._features[Feature.FORMAT_D16] = true;
                  this._features[Feature.FORMAT_D24] = true;
                  this._features[Feature.FORMAT_D24S8] = true;
                }

                if (this._OES_element_index_uint) {
                  this._features[Feature.ELEMENT_INDEX_UINT] = true;
                }

                if (this._ANGLE_instanced_arrays) {
                  this._features[Feature.INSTANCED_ARRAYS] = true;
                }

                if (this._WEBGL_draw_buffers) {
                  this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                }

                var compressedFormat = '';

                if (this._WEBGL_compressed_texture_etc1) {
                  this._features[Feature.FORMAT_ETC1] = true;
                  compressedFormat += 'etc1 ';
                }

                if (this._WEBGL_compressed_texture_etc) {
                  this._features[Feature.FORMAT_ETC2] = true;
                  compressedFormat += 'etc2 ';
                }

                if (this._WEBGL_compressed_texture_s3tc) {
                  this._features[Feature.FORMAT_DXT] = true;
                  compressedFormat += 'dxt ';
                }

                if (this._WEBGL_compressed_texture_pvrtc) {
                  this._features[Feature.FORMAT_PVRTC] = true;
                  compressedFormat += 'pvrtc ';
                }

                if (this._WEBGL_compressed_texture_astc) {
                  this._features[Feature.FORMAT_ASTC] = true;
                  compressedFormat += 'astc ';
                }

                if (this._OES_vertex_array_object) {
                  this._useVAO = true;
                }

                console.info("RENDERER: " + this._renderer);
                console.info("VENDOR: " + this._vendor);
                console.info("VERSION: " + this._version);
                console.info("DPR: " + this._devicePixelRatio);
                console.info("SCREEN_SIZE: " + this._width + " x " + this._height);
                console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight);
                console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors);
                console.info("DEPTH_BITS: " + this._depthBits);
                console.info("STENCIL_BITS: " + this._stencilBits);

                if (this._EXT_texture_filter_anisotropic) {
                  console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                }

                console.info("USE_VAO: " + this._useVAO);
                console.info("COMPRESSED_FORMAT: " + compressedFormat);
                this.initStates(gl);
                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this.nullTex2D = this.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
                this.nullTexCube = this.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.CUBEMAP | TextureFlagBit.GEN_MIPMAP, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                this.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                this.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._canvas && this._webGLContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost, this._webGLContextLostHandler);

                  this._webGLContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }

                this._extensions = null;
                this._webGLRC = null;
              };

              _proto.resize = function resize(width, height) {
                if (this._width !== width || this._height !== height) {
                  console.info("Resizing device: " + width + "x" + height);
                  this._canvas.width = width;
                  this._canvas.height = height;
                  this._width = width;
                  this._height = height;
                }
              };

              _proto.acquire = function acquire() {
                this.cmdAllocator.releaseCmds();
              };

              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };

              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var ctor = info.type === CommandBufferType.PRIMARY ? WebGLPrimaryCommandBuffer : WebGLCommandBuffer;
                var cmdBuff = new ctor(this);
                cmdBuff.initialize(info);
                return cmdBuff;
              };

              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGLBuffer(this);

                if (buffer.initialize(info)) {
                  return buffer;
                }

                return null;
              };

              _proto.createTexture = function createTexture(info) {
                var texture = new WebGLTexture(this);

                if (texture.initialize(info)) {
                  return texture;
                }

                return null;
              };

              _proto.createSampler = function createSampler(info) {
                var sampler = new WebGLSampler(this);

                if (sampler.initialize(info)) {
                  return sampler;
                }

                return null;
              };

              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGLDescriptorSet(this);

                if (descriptorSet.initialize(info)) {
                  return descriptorSet;
                }

                return null;
              };

              _proto.createShader = function createShader(info) {
                var shader = new WebGLShader(this);

                if (shader.initialize(info)) {
                  return shader;
                }

                return null;
              };

              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGLInputAssembler(this);

                if (inputAssembler.initialize(info)) {
                  return inputAssembler;
                }

                return null;
              };

              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGLRenderPass(this);

                if (renderPass.initialize(info)) {
                  return renderPass;
                }

                return null;
              };

              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGLFramebuffer(this);

                if (framebuffer.initialize(info)) {
                  return framebuffer;
                }

                return null;
              };

              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGLDescriptorSetLayout(this);

                if (descriptorSetLayout.initialize(info)) {
                  return descriptorSetLayout;
                }

                return null;
              };

              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGLPipelineLayout(this);

                if (pipelineLayout.initialize(info)) {
                  return pipelineLayout;
                }

                return null;
              };

              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGLPipelineState(this);

                if (pipelineState.initialize(info)) {
                  return pipelineState;
                }

                return null;
              };

              _proto.createFence = function createFence(info) {
                var fence = new WebGLFence(this);

                if (fence.initialize(info)) {
                  return fence;
                }

                return null;
              };

              _proto.createQueue = function createQueue(info) {
                var queue = new WebGLQueue(this);

                if (queue.initialize(info)) {
                  return queue;
                }

                return null;
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGLCmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };

              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGLCmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };

              _proto.copyFramebufferToBuffer = function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                var gl = this._webGLRC;
                var gpuFramebuffer = srcFramebuffer.gpuFramebuffer;
                var format = gpuFramebuffer.gpuColorTextures[0].format;
                var glFormat = GFXFormatToWebGLFormat(format, gl);
                var glType = GFXFormatToWebGLType(format, gl);
                var ctor = getTypedArrayConstructor(FormatInfos[format]);
                var curFBO = this.stateCache.glFramebuffer;

                if (this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                var view = new ctor(dstBuffer);

                for (var _iterator2 = _createForOfIteratorHelperLoose(regions), _step2; !(_step2 = _iterator2()).done;) {
                  var region = _step2.value;
                  var w = region.texExtent.width;
                  var h = region.texExtent.height;
                  gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, glFormat, glType, view);
                }

                if (this.stateCache.glFramebuffer !== curFBO) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO);
                  this.stateCache.glFramebuffer = curFBO;
                }
              };

              _proto.blitFramebuffer = function blitFramebuffer(src, dst, srcRect, dstRect, filter) {};

              _proto.getExtension = function getExtension(ext) {
                var prefixes = ['', 'WEBKIT_', 'MOZ_'];

                for (var i = 0; i < prefixes.length; ++i) {
                  var _ext = this.gl.getExtension(prefixes[i] + ext);

                  if (_ext) {
                    return _ext;
                  }
                }

                return null;
              };

              _proto.initStates = function initStates(gl) {
                gl.activeTexture(gl.TEXTURE0);
                gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.enable(gl.SCISSOR_TEST);
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                gl.frontFace(gl.CCW);
                gl.disable(gl.POLYGON_OFFSET_FILL);
                gl.polygonOffset(0.0, 0.0);
                gl.enable(gl.DEPTH_TEST);
                gl.depthMask(true);
                gl.depthFunc(gl.LESS);
                gl.depthRange(0.0, 1.0);
                gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMaskSeparate(gl.BACK, 0xffff);
                gl.disable(gl.STENCIL_TEST);
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                gl.disable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
                gl.colorMask(true, true, true, true);
                gl.blendColor(0.0, 0.0, 0.0, 0.0);
              };

              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };

              _createClass(WebGLDevice, [{
                key: "gl",
                get: function get() {
                  return this._webGLRC;
                }
              }, {
                key: "webGLQueue",
                get: function get() {
                  return this._queue;
                }
              }, {
                key: "isAntialias",
                get: function get() {
                  return this._isAntialias;
                }
              }, {
                key: "isPremultipliedAlpha",
                get: function get() {
                  return this._isPremultipliedAlpha;
                }
              }, {
                key: "useVAO",
                get: function get() {
                  return this._useVAO;
                }
              }, {
                key: "destroyShadersImmediately",
                get: function get() {
                  return this._destroyShadersImmediately;
                }
              }, {
                key: "noCompressedTexSubImage2D",
                get: function get() {
                  return this._noCompressedTexSubImage2D;
                }
              }, {
                key: "bindingMappingInfo",
                get: function get() {
                  return this._bindingMappingInfo;
                }
              }, {
                key: "EXT_texture_filter_anisotropic",
                get: function get() {
                  return this._EXT_texture_filter_anisotropic;
                }
              }, {
                key: "EXT_blend_minmax",
                get: function get() {
                  return this._EXT_blend_minmax;
                }
              }, {
                key: "EXT_frag_depth",
                get: function get() {
                  return this._EXT_frag_depth;
                }
              }, {
                key: "EXT_shader_texture_lod",
                get: function get() {
                  return this._EXT_shader_texture_lod;
                }
              }, {
                key: "EXT_sRGB",
                get: function get() {
                  return this._EXT_sRGB;
                }
              }, {
                key: "OES_vertex_array_object",
                get: function get() {
                  return this._OES_vertex_array_object;
                }
              }, {
                key: "WEBGL_color_buffer_float",
                get: function get() {
                  return this._WEBGL_color_buffer_float;
                }
              }, {
                key: "WEBGL_compressed_texture_etc1",
                get: function get() {
                  return this._WEBGL_compressed_texture_etc1;
                }
              }, {
                key: "WEBGL_compressed_texture_pvrtc",
                get: function get() {
                  return this._WEBGL_compressed_texture_pvrtc;
                }
              }, {
                key: "WEBGL_compressed_texture_astc",
                get: function get() {
                  return this._WEBGL_compressed_texture_astc;
                }
              }, {
                key: "WEBGL_compressed_texture_s3tc",
                get: function get() {
                  return this._WEBGL_compressed_texture_s3tc;
                }
              }, {
                key: "WEBGL_compressed_texture_s3tc_srgb",
                get: function get() {
                  return this._WEBGL_compressed_texture_s3tc_srgb;
                }
              }, {
                key: "WEBGL_debug_shaders",
                get: function get() {
                  return this._WEBGL_debug_shaders;
                }
              }, {
                key: "WEBGL_draw_buffers",
                get: function get() {
                  return this._WEBGL_draw_buffers;
                }
              }, {
                key: "WEBGL_lose_context",
                get: function get() {
                  return this._WEBGL_lose_context;
                }
              }, {
                key: "WEBGL_depth_texture",
                get: function get() {
                  return this._WEBGL_depth_texture;
                }
              }, {
                key: "WEBGL_debug_renderer_info",
                get: function get() {
                  return this._WEBGL_debug_renderer_info;
                }
              }, {
                key: "OES_texture_half_float",
                get: function get() {
                  return this._OES_texture_half_float;
                }
              }, {
                key: "OES_texture_half_float_linear",
                get: function get() {
                  return this._OES_texture_half_float_linear;
                }
              }, {
                key: "OES_texture_float",
                get: function get() {
                  return this._OES_texture_float;
                }
              }, {
                key: "OES_standard_derivatives",
                get: function get() {
                  return this._OES_standard_derivatives;
                }
              }, {
                key: "OES_element_index_uint",
                get: function get() {
                  return this._OES_element_index_uint;
                }
              }, {
                key: "ANGLE_instanced_arrays",
                get: function get() {
                  return this._ANGLE_instanced_arrays;
                }
              }]);

              return WebGLDevice;
            }(Device));

            legacyCC.WebGLDevice = WebGLDevice;

            var WebGL2DescriptorSet = function (_DescriptorSet) {
              _inheritsLoose(WebGL2DescriptorSet, _DescriptorSet);

              function WebGL2DescriptorSet() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSet.call.apply(_DescriptorSet, [this].concat(args)) || this;
                _this._gpuDescriptorSet = null;
                return _this;
              }

              var _proto = WebGL2DescriptorSet.prototype;

              _proto.initialize = function initialize(info) {
                this._layout = info.layout;
                var _gpuDescriptorSetLayo = info.layout.gpuDescriptorSetLayout,
                    bindings = _gpuDescriptorSetLayo.bindings,
                    descriptorIndices = _gpuDescriptorSetLayo.descriptorIndices,
                    descriptorCount = _gpuDescriptorSetLayo.descriptorCount;
                this._buffers = Array(descriptorCount).fill(null);
                this._textures = Array(descriptorCount).fill(null);
                this._samplers = Array(descriptorCount).fill(null);
                var gpuDescriptors = [];
                this._gpuDescriptorSet = {
                  gpuDescriptors: gpuDescriptors,
                  descriptorIndices: descriptorIndices
                };

                for (var i = 0; i < bindings.length; ++i) {
                  var binding = bindings[i];

                  for (var j = 0; j < binding.count; j++) {
                    gpuDescriptors.push({
                      type: binding.descriptorType,
                      gpuBuffer: null,
                      gpuTexture: null,
                      gpuSampler: null
                    });
                  }
                }

                return true;
              };

              _proto.destroy = function destroy() {
                this._layout = null;
                this._gpuDescriptorSet = null;
              };

              _proto.update = function update() {
                if (this._isDirty && this._gpuDescriptorSet) {
                  var descriptors = this._gpuDescriptorSet.gpuDescriptors;

                  for (var i = 0; i < descriptors.length; ++i) {
                    if (descriptors[i].type & DESCRIPTOR_BUFFER_TYPE) {
                      if (this._buffers[i]) {
                        descriptors[i].gpuBuffer = this._buffers[i].gpuBuffer;
                      }
                    } else if (descriptors[i].type & DESCRIPTOR_SAMPLER_TYPE) {
                      if (this._textures[i]) {
                        descriptors[i].gpuTexture = this._textures[i].gpuTexture;
                      }

                      if (this._samplers[i]) {
                        descriptors[i].gpuSampler = this._samplers[i].gpuSampler;
                      }
                    }
                  }

                  this._isDirty = false;
                }
              };

              _createClass(WebGL2DescriptorSet, [{
                key: "gpuDescriptorSet",
                get: function get() {
                  return this._gpuDescriptorSet;
                }
              }]);

              return WebGL2DescriptorSet;
            }(DescriptorSet);

            var WebGLWraps$1 = [0x2901, 0x8370, 0x812F, 0x812F];
            var SAMPLES = [1, 2, 4, 8, 16, 32, 64];

            var _f32v4 = new Float32Array(4);

            function GFXFormatToWebGLType$1(format, gl) {
              switch (format) {
                case Format.R8:
                  return gl.UNSIGNED_BYTE;

                case Format.R8SN:
                  return gl.BYTE;

                case Format.R8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.R8I:
                  return gl.BYTE;

                case Format.R16F:
                  return gl.HALF_FLOAT;

                case Format.R16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.R16I:
                  return gl.SHORT;

                case Format.R32F:
                  return gl.FLOAT;

                case Format.R32UI:
                  return gl.UNSIGNED_INT;

                case Format.R32I:
                  return gl.INT;

                case Format.RG8:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8SN:
                  return gl.BYTE;

                case Format.RG8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RG8I:
                  return gl.BYTE;

                case Format.RG16F:
                  return gl.HALF_FLOAT;

                case Format.RG16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RG16I:
                  return gl.SHORT;

                case Format.RG32F:
                  return gl.FLOAT;

                case Format.RG32UI:
                  return gl.UNSIGNED_INT;

                case Format.RG32I:
                  return gl.INT;

                case Format.RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8SN:
                  return gl.BYTE;

                case Format.RGB8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGB8I:
                  return gl.BYTE;

                case Format.RGB16F:
                  return gl.HALF_FLOAT;

                case Format.RGB16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGB16I:
                  return gl.SHORT;

                case Format.RGB32F:
                  return gl.FLOAT;

                case Format.RGB32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGB32I:
                  return gl.INT;

                case Format.BGRA8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8:
                  return gl.UNSIGNED_BYTE;

                case Format.SRGB8_A8:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8SN:
                  return gl.BYTE;

                case Format.RGBA8UI:
                  return gl.UNSIGNED_BYTE;

                case Format.RGBA8I:
                  return gl.BYTE;

                case Format.RGBA16F:
                  return gl.HALF_FLOAT;

                case Format.RGBA16UI:
                  return gl.UNSIGNED_SHORT;

                case Format.RGBA16I:
                  return gl.SHORT;

                case Format.RGBA32F:
                  return gl.FLOAT;

                case Format.RGBA32UI:
                  return gl.UNSIGNED_INT;

                case Format.RGBA32I:
                  return gl.INT;

                case Format.R5G6B5:
                  return gl.UNSIGNED_SHORT_5_6_5;

                case Format.R11G11B10F:
                  return gl.UNSIGNED_INT_10F_11F_11F_REV;

                case Format.RGB5A1:
                  return gl.UNSIGNED_SHORT_5_5_5_1;

                case Format.RGBA4:
                  return gl.UNSIGNED_SHORT_4_4_4_4;

                case Format.RGB10A2:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB10A2UI:
                  return gl.UNSIGNED_INT_2_10_10_10_REV;

                case Format.RGB9E5:
                  return gl.FLOAT;

                case Format.D16:
                  return gl.UNSIGNED_SHORT;

                case Format.D16S8:
                  return gl.UNSIGNED_INT_24_8;

                case Format.D24:
                  return gl.UNSIGNED_INT;

                case Format.D24S8:
                  return gl.UNSIGNED_INT_24_8;

                case Format.D32F:
                  return gl.FLOAT;

                case Format.D32F_S8:
                  return gl.FLOAT_32_UNSIGNED_INT_24_8_REV;

                case Format.BC1:
                  return gl.UNSIGNED_BYTE;

                case Format.BC1_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2:
                  return gl.UNSIGNED_BYTE;

                case Format.BC2_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3:
                  return gl.UNSIGNED_BYTE;

                case Format.BC3_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4:
                  return gl.UNSIGNED_BYTE;

                case Format.BC4_SNORM:
                  return gl.BYTE;

                case Format.BC5:
                  return gl.UNSIGNED_BYTE;

                case Format.BC5_SNORM:
                  return gl.BYTE;

                case Format.BC6H_SF16:
                  return gl.FLOAT;

                case Format.BC6H_UF16:
                  return gl.FLOAT;

                case Format.BC7:
                  return gl.UNSIGNED_BYTE;

                case Format.BC7_SRGB:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_RGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.ETC2_SRGB8_A1:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_R11SN:
                  return gl.BYTE;

                case Format.EAC_RG11:
                  return gl.UNSIGNED_BYTE;

                case Format.EAC_RG11SN:
                  return gl.BYTE;

                case Format.PVRTC_RGB2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA2:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGB4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC_RGBA4:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_2BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.PVRTC2_4BPP:
                  return gl.UNSIGNED_BYTE;

                case Format.ASTC_RGBA_4x4:
                case Format.ASTC_RGBA_5x4:
                case Format.ASTC_RGBA_5x5:
                case Format.ASTC_RGBA_6x5:
                case Format.ASTC_RGBA_6x6:
                case Format.ASTC_RGBA_8x5:
                case Format.ASTC_RGBA_8x6:
                case Format.ASTC_RGBA_8x8:
                case Format.ASTC_RGBA_10x5:
                case Format.ASTC_RGBA_10x6:
                case Format.ASTC_RGBA_10x8:
                case Format.ASTC_RGBA_10x10:
                case Format.ASTC_RGBA_12x10:
                case Format.ASTC_RGBA_12x12:
                case Format.ASTC_SRGBA_4x4:
                case Format.ASTC_SRGBA_5x4:
                case Format.ASTC_SRGBA_5x5:
                case Format.ASTC_SRGBA_6x5:
                case Format.ASTC_SRGBA_6x6:
                case Format.ASTC_SRGBA_8x5:
                case Format.ASTC_SRGBA_8x6:
                case Format.ASTC_SRGBA_8x8:
                case Format.ASTC_SRGBA_10x5:
                case Format.ASTC_SRGBA_10x6:
                case Format.ASTC_SRGBA_10x8:
                case Format.ASTC_SRGBA_10x10:
                case Format.ASTC_SRGBA_12x10:
                case Format.ASTC_SRGBA_12x12:
                  return gl.UNSIGNED_BYTE;

                default:
                  {
                    return gl.UNSIGNED_BYTE;
                  }
              }
            }
            function GFXFormatToWebGLInternalFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                  return gl.R8;

                case Format.R8SN:
                  return gl.R8_SNORM;

                case Format.R8UI:
                  return gl.R8UI;

                case Format.R8I:
                  return gl.R8I;

                case Format.RG8:
                  return gl.RG8;

                case Format.RG8SN:
                  return gl.RG8_SNORM;

                case Format.RG8UI:
                  return gl.RG8UI;

                case Format.RG8I:
                  return gl.RG8I;

                case Format.RGB8:
                  return gl.RGB8;

                case Format.RGB8SN:
                  return gl.RGB8_SNORM;

                case Format.RGB8UI:
                  return gl.RGB8UI;

                case Format.RGB8I:
                  return gl.RGB8I;

                case Format.BGRA8:
                  return gl.RGBA8;

                case Format.RGBA8:
                  return gl.RGBA8;

                case Format.RGBA8SN:
                  return gl.RGBA8_SNORM;

                case Format.RGBA8UI:
                  return gl.RGBA8UI;

                case Format.RGBA8I:
                  return gl.RGBA8I;

                case Format.R16I:
                  return gl.R16I;

                case Format.R16UI:
                  return gl.R16UI;

                case Format.R16F:
                  return gl.R16F;

                case Format.RG16I:
                  return gl.RG16I;

                case Format.RG16UI:
                  return gl.RG16UI;

                case Format.RG16F:
                  return gl.RG16F;

                case Format.RGB16I:
                  return gl.RGB16I;

                case Format.RGB16UI:
                  return gl.RGB16UI;

                case Format.RGB16F:
                  return gl.RGB16F;

                case Format.RGBA16I:
                  return gl.RGBA16I;

                case Format.RGBA16UI:
                  return gl.RGBA16UI;

                case Format.RGBA16F:
                  return gl.RGBA16F;

                case Format.R32I:
                  return gl.R32I;

                case Format.R32UI:
                  return gl.R32UI;

                case Format.R32F:
                  return gl.R32F;

                case Format.RG32I:
                  return gl.RG32I;

                case Format.RG32UI:
                  return gl.RG32UI;

                case Format.RG32F:
                  return gl.RG32F;

                case Format.RGB32I:
                  return gl.RGB32I;

                case Format.RGB32UI:
                  return gl.RGB32UI;

                case Format.RGB32F:
                  return gl.RGB32F;

                case Format.RGBA32I:
                  return gl.RGBA32I;

                case Format.RGBA32UI:
                  return gl.RGBA32UI;

                case Format.RGBA32F:
                  return gl.RGBA32F;

                case Format.R5G6B5:
                  return gl.RGB565;

                case Format.RGB5A1:
                  return gl.RGB5_A1;

                case Format.RGBA4:
                  return gl.RGBA4;

                case Format.RGB10A2:
                  return gl.RGB10_A2;

                case Format.RGB10A2UI:
                  return gl.RGB10_A2UI;

                case Format.R11G11B10F:
                  return gl.R11F_G11F_B10F;

                case Format.D16:
                  return gl.DEPTH_COMPONENT16;

                case Format.D16S8:
                  return gl.DEPTH24_STENCIL8;

                case Format.D24:
                  return gl.DEPTH_COMPONENT24;

                case Format.D24S8:
                  return gl.DEPTH24_STENCIL8;

                case Format.D32F:
                  return gl.DEPTH_COMPONENT32F;

                case Format.D32F_S8:
                  return gl.DEPTH32F_STENCIL8;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12x12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12x12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL internal format failed.');
                    return gl.RGBA;
                  }
              }
            }
            function GFXFormatToWebGLFormat$1(format, gl) {
              switch (format) {
                case Format.A8:
                  return gl.ALPHA;

                case Format.L8:
                  return gl.LUMINANCE;

                case Format.LA8:
                  return gl.LUMINANCE_ALPHA;

                case Format.R8:
                case Format.R8SN:
                  return gl.RED;

                case Format.R8UI:
                case Format.R8I:
                  return gl.RED;

                case Format.RG8:
                case Format.RG8SN:
                case Format.RG8UI:
                case Format.RG8I:
                  return gl.RG;

                case Format.RGB8:
                case Format.RGB8SN:
                case Format.RGB8UI:
                case Format.RGB8I:
                  return gl.RGB;

                case Format.BGRA8:
                case Format.RGBA8:
                case Format.RGBA8SN:
                case Format.RGBA8UI:
                case Format.RGBA8I:
                  return gl.RGBA;

                case Format.R16UI:
                case Format.R16I:
                case Format.R16F:
                  return gl.RED;

                case Format.RG16UI:
                case Format.RG16I:
                case Format.RG16F:
                  return gl.RG;

                case Format.RGB16UI:
                case Format.RGB16I:
                case Format.RGB16F:
                  return gl.RGB;

                case Format.RGBA16UI:
                case Format.RGBA16I:
                case Format.RGBA16F:
                  return gl.RGBA;

                case Format.R32UI:
                case Format.R32I:
                case Format.R32F:
                  return gl.RED;

                case Format.RG32UI:
                case Format.RG32I:
                case Format.RG32F:
                  return gl.RG;

                case Format.RGB32UI:
                case Format.RGB32I:
                case Format.RGB32F:
                  return gl.RGB;

                case Format.RGBA32UI:
                case Format.RGBA32I:
                case Format.RGBA32F:
                  return gl.RGBA;

                case Format.RGB10A2:
                  return gl.RGBA;

                case Format.R11G11B10F:
                  return gl.RGB;

                case Format.R5G6B5:
                  return gl.RGB;

                case Format.RGB5A1:
                  return gl.RGBA;

                case Format.RGBA4:
                  return gl.RGBA;

                case Format.D16:
                  return gl.DEPTH_COMPONENT;

                case Format.D16S8:
                  return gl.DEPTH_STENCIL;

                case Format.D24:
                  return gl.DEPTH_COMPONENT;

                case Format.D24S8:
                  return gl.DEPTH_STENCIL;

                case Format.D32F:
                  return gl.DEPTH_COMPONENT;

                case Format.D32F_S8:
                  return gl.DEPTH_STENCIL;

                case Format.BC1:
                  return WebGLEXT.COMPRESSED_RGB_S3TC_DXT1_EXT;

                case Format.BC1_ALPHA:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT1_EXT;

                case Format.BC1_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_S3TC_DXT1_EXT;

                case Format.BC1_SRGB_ALPHA:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;

                case Format.BC2:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT3_EXT;

                case Format.BC2_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;

                case Format.BC3:
                  return WebGLEXT.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                case Format.BC3_SRGB:
                  return WebGLEXT.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;

                case Format.ETC_RGB8:
                  return WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL;

                case Format.ETC2_RGB8:
                  return WebGLEXT.COMPRESSED_RGB8_ETC2;

                case Format.ETC2_SRGB8:
                  return WebGLEXT.COMPRESSED_SRGB8_ETC2;

                case Format.ETC2_RGB8_A1:
                  return WebGLEXT.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_SRGB8_A1:
                  return WebGLEXT.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2;

                case Format.ETC2_RGBA8:
                  return WebGLEXT.COMPRESSED_RGBA8_ETC2_EAC;

                case Format.ETC2_SRGB8_A8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;

                case Format.EAC_R11:
                  return WebGLEXT.COMPRESSED_R11_EAC;

                case Format.EAC_R11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_R11_EAC;

                case Format.EAC_RG11:
                  return WebGLEXT.COMPRESSED_RG11_EAC;

                case Format.EAC_RG11SN:
                  return WebGLEXT.COMPRESSED_SIGNED_RG11_EAC;

                case Format.PVRTC_RGB2:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGBA2:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

                case Format.PVRTC_RGB4:
                  return WebGLEXT.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;

                case Format.PVRTC_RGBA4:
                  return WebGLEXT.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                case Format.ASTC_RGBA_4x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_4x4_KHR;

                case Format.ASTC_RGBA_5x4:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x4_KHR;

                case Format.ASTC_RGBA_5x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_5x5_KHR;

                case Format.ASTC_RGBA_6x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x5_KHR;

                case Format.ASTC_RGBA_6x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_6x6_KHR;

                case Format.ASTC_RGBA_8x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x5_KHR;

                case Format.ASTC_RGBA_8x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x6_KHR;

                case Format.ASTC_RGBA_8x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_8x8_KHR;

                case Format.ASTC_RGBA_10x5:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x5_KHR;

                case Format.ASTC_RGBA_10x6:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x6_KHR;

                case Format.ASTC_RGBA_10x8:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x8_KHR;

                case Format.ASTC_RGBA_10x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_10x10_KHR;

                case Format.ASTC_RGBA_12x10:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x10_KHR;

                case Format.ASTC_RGBA_12x12:
                  return WebGLEXT.COMPRESSED_RGBA_ASTC_12x12_KHR;

                case Format.ASTC_SRGBA_4x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;

                case Format.ASTC_SRGBA_5x4:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR;

                case Format.ASTC_SRGBA_5x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR;

                case Format.ASTC_SRGBA_6x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR;

                case Format.ASTC_SRGBA_6x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR;

                case Format.ASTC_SRGBA_8x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR;

                case Format.ASTC_SRGBA_8x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR;

                case Format.ASTC_SRGBA_8x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR;

                case Format.ASTC_SRGBA_10x5:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR;

                case Format.ASTC_SRGBA_10x6:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR;

                case Format.ASTC_SRGBA_10x8:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR;

                case Format.ASTC_SRGBA_10x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR;

                case Format.ASTC_SRGBA_12x10:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR;

                case Format.ASTC_SRGBA_12x12:
                  return WebGLEXT.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR;

                default:
                  {
                    console.error('Unsupported Format, convert to WebGL format failed.');
                    return gl.RGBA;
                  }
              }
            }

            function GFXTypeToWebGLType$1(type, gl) {
              switch (type) {
                case Type$1.BOOL:
                  return gl.BOOL;

                case Type$1.BOOL2:
                  return gl.BOOL_VEC2;

                case Type$1.BOOL3:
                  return gl.BOOL_VEC3;

                case Type$1.BOOL4:
                  return gl.BOOL_VEC4;

                case Type$1.INT:
                  return gl.INT;

                case Type$1.INT2:
                  return gl.INT_VEC2;

                case Type$1.INT3:
                  return gl.INT_VEC3;

                case Type$1.INT4:
                  return gl.INT_VEC4;

                case Type$1.UINT:
                  return gl.UNSIGNED_INT;

                case Type$1.FLOAT:
                  return gl.FLOAT;

                case Type$1.FLOAT2:
                  return gl.FLOAT_VEC2;

                case Type$1.FLOAT3:
                  return gl.FLOAT_VEC3;

                case Type$1.FLOAT4:
                  return gl.FLOAT_VEC4;

                case Type$1.MAT2:
                  return gl.FLOAT_MAT2;

                case Type$1.MAT2X3:
                  return gl.FLOAT_MAT2x3;

                case Type$1.MAT2X4:
                  return gl.FLOAT_MAT2x4;

                case Type$1.MAT3X2:
                  return gl.FLOAT_MAT3x2;

                case Type$1.MAT3:
                  return gl.FLOAT_MAT3;

                case Type$1.MAT3X4:
                  return gl.FLOAT_MAT3x4;

                case Type$1.MAT4X2:
                  return gl.FLOAT_MAT4x2;

                case Type$1.MAT4X3:
                  return gl.FLOAT_MAT4x3;

                case Type$1.MAT4:
                  return gl.FLOAT_MAT4;

                case Type$1.SAMPLER2D:
                  return gl.SAMPLER_2D;

                case Type$1.SAMPLER2D_ARRAY:
                  return gl.SAMPLER_2D_ARRAY;

                case Type$1.SAMPLER3D:
                  return gl.SAMPLER_3D;

                case Type$1.SAMPLER_CUBE:
                  return gl.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to GL type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLTypeToGFXType$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return Type$1.BOOL;

                case gl.BOOL_VEC2:
                  return Type$1.BOOL2;

                case gl.BOOL_VEC3:
                  return Type$1.BOOL3;

                case gl.BOOL_VEC4:
                  return Type$1.BOOL4;

                case gl.INT:
                  return Type$1.INT;

                case gl.INT_VEC2:
                  return Type$1.INT2;

                case gl.INT_VEC3:
                  return Type$1.INT3;

                case gl.INT_VEC4:
                  return Type$1.INT4;

                case gl.UNSIGNED_INT:
                  return Type$1.UINT;

                case gl.UNSIGNED_INT_VEC2:
                  return Type$1.UINT2;

                case gl.UNSIGNED_INT_VEC3:
                  return Type$1.UINT3;

                case gl.UNSIGNED_INT_VEC4:
                  return Type$1.UINT4;

                case gl.FLOAT:
                  return Type$1.FLOAT;

                case gl.FLOAT_VEC2:
                  return Type$1.FLOAT2;

                case gl.FLOAT_VEC3:
                  return Type$1.FLOAT3;

                case gl.FLOAT_VEC4:
                  return Type$1.FLOAT4;

                case gl.FLOAT_MAT2:
                  return Type$1.MAT2;

                case gl.FLOAT_MAT2x3:
                  return Type$1.MAT2X3;

                case gl.FLOAT_MAT2x4:
                  return Type$1.MAT2X4;

                case gl.FLOAT_MAT3x2:
                  return Type$1.MAT3X2;

                case gl.FLOAT_MAT3:
                  return Type$1.MAT3;

                case gl.FLOAT_MAT3x4:
                  return Type$1.MAT3X4;

                case gl.FLOAT_MAT4x2:
                  return Type$1.MAT4X2;

                case gl.FLOAT_MAT4x3:
                  return Type$1.MAT4X3;

                case gl.FLOAT_MAT4:
                  return Type$1.MAT4;

                case gl.SAMPLER_2D:
                  return Type$1.SAMPLER2D;

                case gl.SAMPLER_2D_ARRAY:
                  return Type$1.SAMPLER2D_ARRAY;

                case gl.SAMPLER_3D:
                  return Type$1.SAMPLER3D;

                case gl.SAMPLER_CUBE:
                  return Type$1.SAMPLER_CUBE;

                default:
                  {
                    console.error('Unsupported GLType, convert to Type failed.');
                    return Type$1.UNKNOWN;
                  }
              }
            }

            function WebGLGetTypeSize$1(glType, gl) {
              switch (glType) {
                case gl.BOOL:
                  return 4;

                case gl.BOOL_VEC2:
                  return 8;

                case gl.BOOL_VEC3:
                  return 12;

                case gl.BOOL_VEC4:
                  return 16;

                case gl.INT:
                  return 4;

                case gl.INT_VEC2:
                  return 8;

                case gl.INT_VEC3:
                  return 12;

                case gl.INT_VEC4:
                  return 16;

                case gl.UNSIGNED_INT:
                  return 4;

                case gl.UNSIGNED_INT_VEC2:
                  return 8;

                case gl.UNSIGNED_INT_VEC3:
                  return 12;

                case gl.UNSIGNED_INT_VEC4:
                  return 16;

                case gl.FLOAT:
                  return 4;

                case gl.FLOAT_VEC2:
                  return 8;

                case gl.FLOAT_VEC3:
                  return 12;

                case gl.FLOAT_VEC4:
                  return 16;

                case gl.FLOAT_MAT2:
                  return 16;

                case gl.FLOAT_MAT2x3:
                  return 24;

                case gl.FLOAT_MAT2x4:
                  return 32;

                case gl.FLOAT_MAT3x2:
                  return 24;

                case gl.FLOAT_MAT3:
                  return 36;

                case gl.FLOAT_MAT3x4:
                  return 48;

                case gl.FLOAT_MAT4x2:
                  return 32;

                case gl.FLOAT_MAT4x3:
                  return 48;

                case gl.FLOAT_MAT4:
                  return 64;

                case gl.SAMPLER_2D:
                  return 4;

                case gl.SAMPLER_2D_ARRAY:
                  return 4;

                case gl.SAMPLER_2D_ARRAY_SHADOW:
                  return 4;

                case gl.SAMPLER_3D:
                  return 4;

                case gl.SAMPLER_CUBE:
                  return 4;

                case gl.INT_SAMPLER_2D:
                  return 4;

                case gl.INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.INT_SAMPLER_3D:
                  return 4;

                case gl.INT_SAMPLER_CUBE:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_3D:
                  return 4;

                case gl.UNSIGNED_INT_SAMPLER_CUBE:
                  return 4;

                default:
                  {
                    console.error('Unsupported GLType, get type failed.');
                    return 0;
                  }
              }
            }

            function WebGLGetComponentCount$1(glType, gl) {
              switch (glType) {
                case gl.FLOAT_MAT2:
                  return 2;

                case gl.FLOAT_MAT2x3:
                  return 2;

                case gl.FLOAT_MAT2x4:
                  return 2;

                case gl.FLOAT_MAT3x2:
                  return 3;

                case gl.FLOAT_MAT3:
                  return 3;

                case gl.FLOAT_MAT3x4:
                  return 3;

                case gl.FLOAT_MAT4x2:
                  return 4;

                case gl.FLOAT_MAT4x3:
                  return 4;

                case gl.FLOAT_MAT4:
                  return 4;

                default:
                  {
                    return 1;
                  }
              }
            }

            var WebGLCmpFuncs$1 = [0x0200, 0x0201, 0x0202, 0x0203, 0x0204, 0x0205, 0x0206, 0x0207];
            var WebGLStencilOps$1 = [0x0000, 0x1E00, 0x1E01, 0x1E02, 0x1E03, 0x150A, 0x8507, 0x8508];
            var WebGLBlendOps$1 = [0x8006, 0x800A, 0x800B, 0x8007, 0x8008];
            var WebGLBlendFactors$1 = [0x0000, 0x0001, 0x0302, 0x0304, 0x0303, 0x0305, 0x0300, 0x0306, 0x0301, 0x0307, 0x0308, 0x8001, 0x8002, 0x8003, 0x8004];
            var WebGL2Cmd;

            (function (WebGL2Cmd) {
              WebGL2Cmd[WebGL2Cmd["BEGIN_RENDER_PASS"] = 0] = "BEGIN_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["END_RENDER_PASS"] = 1] = "END_RENDER_PASS";
              WebGL2Cmd[WebGL2Cmd["BIND_STATES"] = 2] = "BIND_STATES";
              WebGL2Cmd[WebGL2Cmd["DRAW"] = 3] = "DRAW";
              WebGL2Cmd[WebGL2Cmd["UPDATE_BUFFER"] = 4] = "UPDATE_BUFFER";
              WebGL2Cmd[WebGL2Cmd["COPY_BUFFER_TO_TEXTURE"] = 5] = "COPY_BUFFER_TO_TEXTURE";
              WebGL2Cmd[WebGL2Cmd["COUNT"] = 6] = "COUNT";
            })(WebGL2Cmd || (WebGL2Cmd = {}));

            var WebGL2CmdObject = function WebGL2CmdObject(type) {
              this.cmdType = void 0;
              this.refCount = 0;
              this.cmdType = type;
            };
            var WebGL2CmdBeginRenderPass = function (_WebGL2CmdObject) {
              _inheritsLoose(WebGL2CmdBeginRenderPass, _WebGL2CmdObject);

              function WebGL2CmdBeginRenderPass() {
                var _this;

                _this = _WebGL2CmdObject.call(this, WebGL2Cmd.BEGIN_RENDER_PASS) || this;
                _this.gpuRenderPass = null;
                _this.gpuFramebuffer = null;
                _this.renderArea = new Rect();
                _this.clearColors = [];
                _this.clearDepth = 1.0;
                _this.clearStencil = 0;
                return _this;
              }

              var _proto = WebGL2CmdBeginRenderPass.prototype;

              _proto.clear = function clear() {
                this.gpuFramebuffer = null;
                this.clearColors.length = 0;
              };

              return WebGL2CmdBeginRenderPass;
            }(WebGL2CmdObject);
            var WebGL2CmdBindStates = function (_WebGL2CmdObject2) {
              _inheritsLoose(WebGL2CmdBindStates, _WebGL2CmdObject2);

              function WebGL2CmdBindStates() {
                var _this2;

                _this2 = _WebGL2CmdObject2.call(this, WebGL2Cmd.BIND_STATES) || this;
                _this2.gpuPipelineState = null;
                _this2.gpuInputAssembler = null;
                _this2.gpuDescriptorSets = [];
                _this2.dynamicOffsets = [];
                _this2.viewport = null;
                _this2.scissor = null;
                _this2.lineWidth = null;
                _this2.depthBias = null;
                _this2.blendConstants = [];
                _this2.depthBounds = null;
                _this2.stencilWriteMask = null;
                _this2.stencilCompareMask = null;
                return _this2;
              }

              var _proto2 = WebGL2CmdBindStates.prototype;

              _proto2.clear = function clear() {
                this.gpuPipelineState = null;
                this.gpuInputAssembler = null;
                this.gpuDescriptorSets.length = 0;
                this.dynamicOffsets.length = 0;
                this.viewport = null;
                this.scissor = null;
                this.lineWidth = null;
                this.depthBias = null;
                this.blendConstants.length = 0;
                this.depthBounds = null;
                this.stencilWriteMask = null;
                this.stencilCompareMask = null;
              };

              return WebGL2CmdBindStates;
            }(WebGL2CmdObject);
            var WebGL2CmdDraw = function (_WebGL2CmdObject3) {
              _inheritsLoose(WebGL2CmdDraw, _WebGL2CmdObject3);

              function WebGL2CmdDraw() {
                var _this3;

                _this3 = _WebGL2CmdObject3.call(this, WebGL2Cmd.DRAW) || this;
                _this3.drawInfo = new DrawInfo();
                return _this3;
              }

              var _proto3 = WebGL2CmdDraw.prototype;

              _proto3.clear = function clear() {};

              return WebGL2CmdDraw;
            }(WebGL2CmdObject);
            var WebGL2CmdUpdateBuffer = function (_WebGL2CmdObject4) {
              _inheritsLoose(WebGL2CmdUpdateBuffer, _WebGL2CmdObject4);

              function WebGL2CmdUpdateBuffer() {
                var _this4;

                _this4 = _WebGL2CmdObject4.call(this, WebGL2Cmd.UPDATE_BUFFER) || this;
                _this4.gpuBuffer = null;
                _this4.buffer = null;
                _this4.offset = 0;
                _this4.size = 0;
                return _this4;
              }

              var _proto4 = WebGL2CmdUpdateBuffer.prototype;

              _proto4.clear = function clear() {
                this.gpuBuffer = null;
                this.buffer = null;
              };

              return WebGL2CmdUpdateBuffer;
            }(WebGL2CmdObject);
            var WebGL2CmdCopyBufferToTexture = function (_WebGL2CmdObject5) {
              _inheritsLoose(WebGL2CmdCopyBufferToTexture, _WebGL2CmdObject5);

              function WebGL2CmdCopyBufferToTexture() {
                var _this5;

                _this5 = _WebGL2CmdObject5.call(this, WebGL2Cmd.COPY_BUFFER_TO_TEXTURE) || this;
                _this5.gpuTexture = null;
                _this5.buffers = [];
                _this5.regions = [];
                return _this5;
              }

              var _proto5 = WebGL2CmdCopyBufferToTexture.prototype;

              _proto5.clear = function clear() {
                this.gpuTexture = null;
                this.buffers.length = 0;
                this.regions.length = 0;
              };

              return WebGL2CmdCopyBufferToTexture;
            }(WebGL2CmdObject);
            var WebGL2CmdPackage = function () {
              function WebGL2CmdPackage() {
                this.cmds = new CachedArray(1);
                this.beginRenderPassCmds = new CachedArray(1);
                this.bindStatesCmds = new CachedArray(1);
                this.drawCmds = new CachedArray(1);
                this.updateBufferCmds = new CachedArray(1);
                this.copyBufferToTextureCmds = new CachedArray(1);
              }

              var _proto6 = WebGL2CmdPackage.prototype;

              _proto6.clearCmds = function clearCmds(allocator) {
                if (this.beginRenderPassCmds.length) {
                  allocator.beginRenderPassCmdPool.freeCmds(this.beginRenderPassCmds);
                  this.beginRenderPassCmds.clear();
                }

                if (this.bindStatesCmds.length) {
                  allocator.bindStatesCmdPool.freeCmds(this.bindStatesCmds);
                  this.bindStatesCmds.clear();
                }

                if (this.drawCmds.length) {
                  allocator.drawCmdPool.freeCmds(this.drawCmds);
                  this.drawCmds.clear();
                }

                if (this.updateBufferCmds.length) {
                  allocator.updateBufferCmdPool.freeCmds(this.updateBufferCmds);
                  this.updateBufferCmds.clear();
                }

                if (this.copyBufferToTextureCmds.length) {
                  allocator.copyBufferToTextureCmdPool.freeCmds(this.copyBufferToTextureCmds);
                  this.copyBufferToTextureCmds.clear();
                }

                this.cmds.clear();
              };

              return WebGL2CmdPackage;
            }();
            function WebGL2CmdFuncCreateBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                gpuBuffer.glTarget = gl.ARRAY_BUFFER;
                var glBuffer = gl.createBuffer();

                if (glBuffer) {
                  gpuBuffer.glBuffer = glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                      }
                    }

                    if (device.stateCache.glArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                gpuBuffer.glTarget = gl.ELEMENT_ARRAY_BUFFER;

                var _glBuffer = gl.createBuffer();

                if (_glBuffer) {
                  gpuBuffer.glBuffer = _glBuffer;

                  if (gpuBuffer.size > 0) {
                    if (device.useVAO) {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                      }
                    }

                    if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                      device.stateCache.glElementArrayBuffer = gpuBuffer.glBuffer;
                    }

                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                  }
                }
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                gpuBuffer.glTarget = gl.UNIFORM_BUFFER;

                var _glBuffer2 = gl.createBuffer();

                if (_glBuffer2 && gpuBuffer.size > 0) {
                  gpuBuffer.glBuffer = _glBuffer2;

                  if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                    gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                    device.stateCache.glUniformBuffer = gpuBuffer.glBuffer;
                  }

                  gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                  gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                  device.stateCache.glUniformBuffer = null;
                }
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_DST) {
                gpuBuffer.glTarget = gl.NONE;
              } else if (gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncDestroyBuffer(device, gpuBuffer) {
              var gl = device.gl;

              if (gpuBuffer.glBuffer) {
                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    if (device.useVAO && device.stateCache.glVAO) {
                      gl.bindVertexArray(null);
                      device.stateCache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                    }

                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    device.stateCache.glArrayBuffer = null;
                    break;

                  case gl.ELEMENT_ARRAY_BUFFER:
                    if (device.useVAO && device.stateCache.glVAO) {
                      gl.bindVertexArray(null);
                      device.stateCache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                    }

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    device.stateCache.glElementArrayBuffer = null;
                    break;

                  case gl.UNIFORM_BUFFER:
                    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                    device.stateCache.glUniformBuffer = null;
                    break;
                }

                gl.deleteBuffer(gpuBuffer.glBuffer);
                gpuBuffer.glBuffer = null;
              }
            }
            function WebGL2CmdFuncResizeBuffer(device, gpuBuffer) {
              var gl = device.gl;
              var cache = device.stateCache;
              var glUsage = gpuBuffer.memUsage & MemoryUsageBit.HOST ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

              if (gpuBuffer.usage & BufferUsageBit.VERTEX) {
                if (device.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                  }
                }

                if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, null);
                cache.glArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDEX) {
                if (device.useVAO) {
                  if (cache.glVAO) {
                    gl.bindVertexArray(null);
                    cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                  }
                }

                if (device.stateCache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                }

                if (gpuBuffer.buffer) {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.buffer, glUsage);
                } else {
                  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.size, glUsage);
                }

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                device.stateCache.glElementArrayBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.UNIFORM) {
                if (device.stateCache.glUniformBuffer !== gpuBuffer.glBuffer) {
                  gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                }

                gl.bufferData(gl.UNIFORM_BUFFER, gpuBuffer.size, glUsage);
                gl.bindBuffer(gl.UNIFORM_BUFFER, null);
                device.stateCache.glUniformBuffer = null;
              } else if (gpuBuffer.usage & BufferUsageBit.INDIRECT || gpuBuffer.usage & BufferUsageBit.TRANSFER_DST || gpuBuffer.usage & BufferUsageBit.TRANSFER_SRC) {
                gpuBuffer.glTarget = gl.NONE;
              } else {
                console.error('Unsupported BufferType, create buffer failed.');
                gpuBuffer.glTarget = gl.NONE;
              }
            }
            function WebGL2CmdFuncUpdateBuffer(device, gpuBuffer, buffer, offset, size) {
              if (gpuBuffer.usage & BufferUsageBit.INDIRECT) {
                gpuBuffer.indirects.length = offset;
                Array.prototype.push.apply(gpuBuffer.indirects, buffer.drawInfos);
              } else {
                var buff = buffer;
                var gl = device.gl;
                var cache = device.stateCache;

                switch (gpuBuffer.glTarget) {
                  case gl.ARRAY_BUFFER:
                    {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                      }

                      if (cache.glArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.ELEMENT_ARRAY_BUFFER:
                    {
                      if (cache.glVAO) {
                        gl.bindVertexArray(null);
                        cache.glVAO = gfxStateCache$1.gpuInputAssembler = null;
                      }

                      if (cache.glElementArrayBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                        cache.glElementArrayBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff.slice(0, size));
                      }

                      break;
                    }

                  case gl.UNIFORM_BUFFER:
                    {
                      if (cache.glUniformBuffer !== gpuBuffer.glBuffer) {
                        gl.bindBuffer(gl.UNIFORM_BUFFER, gpuBuffer.glBuffer);
                        cache.glUniformBuffer = gpuBuffer.glBuffer;
                      }

                      if (size === buff.byteLength) {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, buff);
                      } else {
                        gl.bufferSubData(gpuBuffer.glTarget, offset, new Float32Array(buff, 0, size / 4));
                      }

                      break;
                    }

                  default:
                    {
                      console.error('Unsupported BufferType, update buffer failed.');
                    }
                }
              }
            }
            function WebGL2CmdFuncCreateTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.maxTextureSize) {
                      errorID(9100, maxSize, device.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.X1) {
                      var glTexture = gl.createTexture();

                      if (glTexture && gpuTexture.size > 0) {
                        gpuTexture.glTexture = glTexture;
                        var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                        if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                          gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                          glTexUnit.glTexture = gpuTexture.glTexture;
                        }

                        if (gpuTexture.flags & TextureFlagBit.IMMUTABLE) {
                          gl.texStorage2D(gl.TEXTURE_2D, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                        } else if (!FormatInfos[gpuTexture.format].isCompressed) {
                          for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                            gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          for (var _i = 0; _i < gpuTexture.mipLevel; ++_i) {
                            var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                            var view = new Uint8Array(imgSize);
                            gl.compressedTexImage2D(gl.TEXTURE_2D, _i, gpuTexture.glInternalFmt, w, h, 0, view);
                            w = Math.max(1, w >> 1);
                            h = Math.max(1, h >> 1);
                          }
                        } else {
                          var _imgSize = FormatSize(gpuTexture.format, 2, 2, 1);

                          var _view = new Uint8Array(_imgSize);

                          gl.compressedTexImage2D(gl.TEXTURE_2D, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view);
                        }
                      } else {
                        gl.deleteTexture(glTexture);
                      }
                    } else {
                      var glRenderbuffer = gl.createRenderbuffer();

                      if (glRenderbuffer && gpuTexture.size > 0) {
                        gpuTexture.glRenderbuffer = glRenderbuffer;

                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize = Math.max(w, h);

                    if (_maxSize > device.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize, device.maxTextureSize);
                    }

                    var _glTexture = gl.createTexture();

                    if (_glTexture && gpuTexture.size > 0) {
                      gpuTexture.glTexture = _glTexture;
                      var _glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (_glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                        _glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (gpuTexture.flags & TextureFlagBit.IMMUTABLE) {
                        gl.texStorage2D(gl.TEXTURE_CUBE_MAP, gpuTexture.mipLevel, gpuTexture.glInternalFmt, w, h);
                      } else if (!FormatInfos[gpuTexture.format].isCompressed) {
                        for (var _i2 = 0; _i2 < gpuTexture.mipLevel; ++_i2) {
                          for (var f = 0; f < 6; ++f) {
                            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i2, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          }

                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        for (var _i3 = 0; _i3 < gpuTexture.mipLevel; ++_i3) {
                          var _imgSize2 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view2 = new Uint8Array(_imgSize2);

                          for (var _f = 0; _f < 6; ++_f) {
                            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f, _i3, gpuTexture.glInternalFmt, w, h, 0, _view2);
                          }

                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else {
                        for (var _f2 = 0; _f2 < 6; ++_f2) {
                          var _imgSize3 = FormatSize(gpuTexture.format, 2, 2, 1);

                          var _view3 = new Uint8Array(_imgSize3);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f2, 0, gpuTexture.glInternalFmt, 2, 2, 0, _view3);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncDestroyTexture(device, gpuTexture) {
              if (gpuTexture.glTexture) {
                device.gl.deleteTexture(gpuTexture.glTexture);
                gpuTexture.glTexture = null;
              }

              if (gpuTexture.glRenderbuffer) {
                device.gl.deleteRenderbuffer(gpuTexture.glRenderbuffer);
                gpuTexture.glRenderbuffer = null;
              }
            }
            function WebGL2CmdFuncResizeTexture(device, gpuTexture) {
              var gl = device.gl;
              gpuTexture.glInternalFmt = GFXFormatToWebGLInternalFormat$1(gpuTexture.format, gl);
              gpuTexture.glFormat = GFXFormatToWebGLFormat$1(gpuTexture.format, gl);
              gpuTexture.glType = GFXFormatToWebGLType$1(gpuTexture.format, gl);
              var w = gpuTexture.width;
              var h = gpuTexture.height;

              switch (gpuTexture.type) {
                case TextureType.TEX2D:
                  {
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                    var maxSize = Math.max(w, h);

                    if (maxSize > device.maxTextureSize) {
                      errorID(9100, maxSize, device.maxTextureSize);
                    }

                    if (gpuTexture.samples === SampleCount.X1) {
                      var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        gl.bindTexture(gl.TEXTURE_2D, gpuTexture.glTexture);
                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      if (!FormatInfos[gpuTexture.format].isCompressed) {
                        for (var i = 0; i < gpuTexture.mipLevel; ++i) {
                          gl.texImage2D(gl.TEXTURE_2D, i, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        for (var _i4 = 0; _i4 < gpuTexture.mipLevel; ++_i4) {
                          var imgSize = FormatSize(gpuTexture.format, w, h, 1);
                          var view = new Uint8Array(imgSize);
                          gl.compressedTexImage2D(gl.TEXTURE_2D, _i4, gpuTexture.glInternalFmt, w, h, 0, view);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else {
                      var glRenderbuffer = gl.createRenderbuffer();

                      if (glRenderbuffer && gpuTexture.size > 0) {
                        gpuTexture.glRenderbuffer = glRenderbuffer;

                        if (device.stateCache.glRenderbuffer !== gpuTexture.glRenderbuffer) {
                          gl.bindRenderbuffer(gl.RENDERBUFFER, gpuTexture.glRenderbuffer);
                          device.stateCache.glRenderbuffer = gpuTexture.glRenderbuffer;
                        }

                        gl.renderbufferStorageMultisample(gl.RENDERBUFFER, SAMPLES[gpuTexture.samples], gpuTexture.glInternalFmt, gpuTexture.width, gpuTexture.height);
                      }
                    }

                    break;
                  }

                case TextureType.CUBE:
                  {
                    gpuTexture.type = TextureType.CUBE;
                    gpuTexture.glTarget = gl.TEXTURE_CUBE_MAP;

                    var _maxSize2 = Math.max(w, h);

                    if (_maxSize2 > device.maxCubeMapTextureSize) {
                      errorID(9100, _maxSize2, device.maxTextureSize);
                    }

                    var _glTexUnit2 = device.stateCache.glTexUnits[device.stateCache.texUnit];

                    if (_glTexUnit2.glTexture !== gpuTexture.glTexture) {
                      gl.bindTexture(gl.TEXTURE_CUBE_MAP, gpuTexture.glTexture);
                      _glTexUnit2.glTexture = gpuTexture.glTexture;
                    }

                    if (!FormatInfos[gpuTexture.format].isCompressed) {
                      for (var f = 0; f < 6; ++f) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i5 = 0; _i5 < gpuTexture.mipLevel; ++_i5) {
                          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _i5, gpuTexture.glInternalFmt, w, h, 0, gpuTexture.glFormat, gpuTexture.glType, null);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                      for (var _f3 = 0; _f3 < 6; ++_f3) {
                        w = gpuTexture.width;
                        h = gpuTexture.height;

                        for (var _i6 = 0; _i6 < gpuTexture.mipLevel; ++_i6) {
                          var _imgSize4 = FormatSize(gpuTexture.format, w, h, 1);

                          var _view4 = new Uint8Array(_imgSize4);

                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _f3, _i6, gpuTexture.glInternalFmt, w, h, 0, _view4);
                          w = Math.max(1, w >> 1);
                          h = Math.max(1, h >> 1);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported TextureType, create texture failed.');
                    gpuTexture.type = TextureType.TEX2D;
                    gpuTexture.glTarget = gl.TEXTURE_2D;
                  }
              }
            }
            function WebGL2CmdFuncCreateSampler(device, gpuSampler) {
              var gl = device.gl;
              var glSampler = gl.createSampler();

              if (glSampler) {
                if (gpuSampler.minFilter === Filter.LINEAR || gpuSampler.minFilter === Filter.ANISOTROPIC) {
                  if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                    gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
                  } else if (gpuSampler.mipFilter === Filter.POINT) {
                    gpuSampler.glMinFilter = gl.LINEAR_MIPMAP_NEAREST;
                  } else {
                    gpuSampler.glMinFilter = gl.LINEAR;
                  }
                } else if (gpuSampler.mipFilter === Filter.LINEAR || gpuSampler.mipFilter === Filter.ANISOTROPIC) {
                  gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_LINEAR;
                } else if (gpuSampler.mipFilter === Filter.POINT) {
                  gpuSampler.glMinFilter = gl.NEAREST_MIPMAP_NEAREST;
                } else {
                  gpuSampler.glMinFilter = gl.NEAREST;
                }

                if (gpuSampler.magFilter === Filter.LINEAR || gpuSampler.magFilter === Filter.ANISOTROPIC) {
                  gpuSampler.glMagFilter = gl.LINEAR;
                } else {
                  gpuSampler.glMagFilter = gl.NEAREST;
                }

                gpuSampler.glWrapS = WebGLWraps$1[gpuSampler.addressU];
                gpuSampler.glWrapT = WebGLWraps$1[gpuSampler.addressV];
                gpuSampler.glWrapR = WebGLWraps$1[gpuSampler.addressW];
                gpuSampler.glSampler = glSampler;
                gl.samplerParameteri(glSampler, gl.TEXTURE_MIN_FILTER, gpuSampler.glMinFilter);
                gl.samplerParameteri(glSampler, gl.TEXTURE_MAG_FILTER, gpuSampler.glMagFilter);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_S, gpuSampler.glWrapS);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_T, gpuSampler.glWrapT);
                gl.samplerParameteri(glSampler, gl.TEXTURE_WRAP_R, gpuSampler.glWrapR);
                gl.samplerParameterf(glSampler, gl.TEXTURE_MIN_LOD, gpuSampler.minLOD);
                gl.samplerParameterf(glSampler, gl.TEXTURE_MAX_LOD, gpuSampler.maxLOD);
              }
            }
            function WebGL2CmdFuncDestroySampler(device, gpuSampler) {
              if (gpuSampler.glSampler) {
                device.gl.deleteSampler(gpuSampler.glSampler);
                gpuSampler.glSampler = null;
              }
            }
            function WebGL2CmdFuncCreateFramebuffer(device, gpuFramebuffer) {
              if (!gpuFramebuffer.gpuColorTextures.length && !gpuFramebuffer.gpuDepthStencilTexture) {
                return;
              }

              var gl = device.gl;
              var attachments = [];
              var glFramebuffer = gl.createFramebuffer();

              if (glFramebuffer) {
                gpuFramebuffer.glFramebuffer = glFramebuffer;

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                }

                for (var i = 0; i < gpuFramebuffer.gpuColorTextures.length; ++i) {
                  var colorTexture = gpuFramebuffer.gpuColorTextures[i];

                  if (colorTexture) {
                    if (colorTexture.glTexture) {
                      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, colorTexture.glTarget, colorTexture.glTexture, 0);
                    } else {
                      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, colorTexture.glRenderbuffer);
                    }

                    attachments.push(gl.COLOR_ATTACHMENT0 + i);
                  }
                }

                var dst = gpuFramebuffer.gpuDepthStencilTexture;

                if (dst) {
                  var glAttachment = FormatInfos[dst.format].hasStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;

                  if (dst.glTexture) {
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, glAttachment, dst.glTarget, dst.glTexture, 0);
                  } else {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, glAttachment, gl.RENDERBUFFER, dst.glRenderbuffer);
                  }
                }

                gl.drawBuffers(attachments);
                var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

                if (status !== gl.FRAMEBUFFER_COMPLETE) {
                  switch (status) {
                    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT');
                        break;
                      }

                    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_INCOMPLETE_DIMENSIONS');
                        break;
                      }

                    case gl.FRAMEBUFFER_UNSUPPORTED:
                      {
                        console.error('glCheckFramebufferStatus() - FRAMEBUFFER_UNSUPPORTED');
                        break;
                      }
                  }
                }

                if (device.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
                }
              }
            }
            function WebGL2CmdFuncDestroyFramebuffer(device, gpuFramebuffer) {
              if (gpuFramebuffer.glFramebuffer) {
                device.gl.deleteFramebuffer(gpuFramebuffer.glFramebuffer);
                gpuFramebuffer.glFramebuffer = null;
              }
            }
            function WebGL2CmdFuncCreateShader(device, gpuShader) {
              var gl = device.gl;

              var _loop = function _loop(k) {
                var gpuStage = gpuShader.gpuStages[k];
                var glShaderType = 0;
                var shaderTypeStr = '';
                var lineNumber = 1;

                switch (gpuStage.type) {
                  case ShaderStageFlagBit.VERTEX:
                    {
                      shaderTypeStr = 'VertexShader';
                      glShaderType = gl.VERTEX_SHADER;
                      break;
                    }

                  case ShaderStageFlagBit.FRAGMENT:
                    {
                      shaderTypeStr = 'FragmentShader';
                      glShaderType = gl.FRAGMENT_SHADER;
                      break;
                    }

                  default:
                    {
                      console.error('Unsupported ShaderType.');
                      return {
                        v: void 0
                      };
                    }
                }

                var glShader = gl.createShader(glShaderType);

                if (glShader) {
                  gpuStage.glShader = glShader;
                  gl.shaderSource(gpuStage.glShader, "#version 300 es\n" + gpuStage.source);
                  gl.compileShader(gpuStage.glShader);

                  if (!gl.getShaderParameter(gpuStage.glShader, gl.COMPILE_STATUS)) {
                    console.error(shaderTypeStr + " in '" + gpuShader.name + "' compilation failed.");
                    console.error('Shader source dump:', gpuStage.source.replace(/^|\n/g, function () {
                      return "\n" + lineNumber++ + " ";
                    }));
                    console.error(gl.getShaderInfoLog(gpuStage.glShader));

                    for (var l = 0; l < gpuShader.gpuStages.length; l++) {
                      var stage = gpuShader.gpuStages[k];

                      if (stage.glShader) {
                        gl.deleteShader(stage.glShader);
                        stage.glShader = null;
                      }
                    }

                    return {
                      v: void 0
                    };
                  }
                }
              };

              for (var k = 0; k < gpuShader.gpuStages.length; k++) {
                var _ret = _loop(k);

                if (typeof _ret === "object") return _ret.v;
              }

              var glProgram = gl.createProgram();

              if (!glProgram) {
                return;
              }

              gpuShader.glProgram = glProgram;

              for (var _k = 0; _k < gpuShader.gpuStages.length; _k++) {
                var gpuStage = gpuShader.gpuStages[_k];
                gl.attachShader(gpuShader.glProgram, gpuStage.glShader);
              }

              gl.linkProgram(gpuShader.glProgram);

              for (var _k2 = 0; _k2 < gpuShader.gpuStages.length; _k2++) {
                var _gpuStage = gpuShader.gpuStages[_k2];

                if (_gpuStage.glShader) {
                  gl.detachShader(gpuShader.glProgram, _gpuStage.glShader);
                  gl.deleteShader(_gpuStage.glShader);
                  _gpuStage.glShader = null;
                }
              }

              if (gl.getProgramParameter(gpuShader.glProgram, gl.LINK_STATUS)) {
                console.info("Shader '" + gpuShader.name + "' compilation succeeded.");
              } else {
                console.error("Failed to link shader '" + gpuShader.name + "'.");
                console.error(gl.getProgramInfoLog(gpuShader.glProgram));
                return;
              }

              var activeAttribCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_ATTRIBUTES);
              gpuShader.glInputs = new Array(activeAttribCount);

              for (var i = 0; i < activeAttribCount; ++i) {
                var attribInfo = gl.getActiveAttrib(gpuShader.glProgram, i);

                if (attribInfo) {
                  var varName = void 0;
                  var nameOffset = attribInfo.name.indexOf('[');

                  if (nameOffset !== -1) {
                    varName = attribInfo.name.substr(0, nameOffset);
                  } else {
                    varName = attribInfo.name;
                  }

                  var glLoc = gl.getAttribLocation(gpuShader.glProgram, varName);
                  var type = WebGLTypeToGFXType$1(attribInfo.type, gl);
                  var stride = WebGLGetTypeSize$1(attribInfo.type, gl);
                  gpuShader.glInputs[i] = {
                    name: varName,
                    type: type,
                    stride: stride,
                    count: attribInfo.size,
                    size: stride * attribInfo.size,
                    glType: attribInfo.type,
                    glLoc: glLoc
                  };
                }
              }

              var activeBlockCount = gl.getProgramParameter(gpuShader.glProgram, gl.ACTIVE_UNIFORM_BLOCKS);
              var blockName;
              var blockIdx;
              var blockSize;
              var block;

              if (activeBlockCount) {
                gpuShader.glBlocks = new Array(activeBlockCount);

                for (var b = 0; b < activeBlockCount; ++b) {
                  blockName = gl.getActiveUniformBlockName(gpuShader.glProgram, b);

                  var _nameOffset = blockName.indexOf('[');

                  if (_nameOffset !== -1) {
                    blockName = blockName.substr(0, _nameOffset);
                  }

                  block = null;

                  for (var _k3 = 0; _k3 < gpuShader.blocks.length; _k3++) {
                    if (gpuShader.blocks[_k3].name === blockName) {
                      block = gpuShader.blocks[_k3];
                      break;
                    }
                  }

                  if (!block) {
                    error("Block '" + blockName + "' does not bound");
                  } else {
                    blockIdx = b;
                    blockSize = gl.getActiveUniformBlockParameter(gpuShader.glProgram, blockIdx, gl.UNIFORM_BLOCK_DATA_SIZE);
                    var glBinding = block.binding + (device.bindingMappingInfo.bufferOffsets[block.set] || 0);
                    gl.uniformBlockBinding(gpuShader.glProgram, blockIdx, glBinding);
                    gpuShader.glBlocks[b] = {
                      set: block.set,
                      binding: block.binding,
                      idx: blockIdx,
                      name: blockName,
                      size: blockSize,
                      glBinding: glBinding
                    };
                  }
                }
              }

              if (gpuShader.samplers.length > 0) {
                gpuShader.glSamplers = new Array(gpuShader.samplers.length);

                for (var _i7 = 0; _i7 < gpuShader.samplers.length; ++_i7) {
                  var sampler = gpuShader.samplers[_i7];
                  gpuShader.glSamplers[_i7] = {
                    set: sampler.set,
                    binding: sampler.binding,
                    name: sampler.name,
                    type: sampler.type,
                    count: sampler.count,
                    units: [],
                    glUnits: null,
                    glType: GFXTypeToWebGLType$1(sampler.type, gl),
                    glLoc: null
                  };
                }
              }

              var glActiveSamplers = [];
              var glActiveSamplerLocations = [];
              var bindingMappingInfo = device.bindingMappingInfo;
              var texUnitCacheMap = device.stateCache.texUnitCacheMap;
              var flexibleSetBaseOffset = 0;

              for (var _i8 = 0; _i8 < gpuShader.blocks.length; ++_i8) {
                if (gpuShader.blocks[_i8].set === bindingMappingInfo.flexibleSet) {
                  flexibleSetBaseOffset++;
                }
              }

              var arrayOffset = 0;

              for (var _i9 = 0; _i9 < gpuShader.samplers.length; ++_i9) {
                var _sampler = gpuShader.samplers[_i9];

                var _glLoc = gl.getUniformLocation(gpuShader.glProgram, _sampler.name);

                if (_glLoc !== null && (typeof _glLoc === 'number' || _glLoc.id !== -1)) {
                  glActiveSamplers.push(gpuShader.glSamplers[_i9]);
                  glActiveSamplerLocations.push(_glLoc);
                }

                if (texUnitCacheMap[_sampler.name] === undefined) {
                  var binding = _sampler.binding + bindingMappingInfo.samplerOffsets[_sampler.set] + arrayOffset;

                  if (_sampler.set === bindingMappingInfo.flexibleSet) {
                    binding -= flexibleSetBaseOffset;
                  }

                  texUnitCacheMap[_sampler.name] = binding % device.maxTextureUnits;
                  arrayOffset += _sampler.count - 1;
                }
              }

              if (glActiveSamplers.length) {
                var usedTexUnits = [];

                for (var _i10 = 0; _i10 < glActiveSamplers.length; ++_i10) {
                  var glSampler = glActiveSamplers[_i10];
                  var cachedUnit = texUnitCacheMap[glSampler.name];

                  if (cachedUnit !== undefined) {
                    glSampler.glLoc = glActiveSamplerLocations[_i10];

                    for (var t = 0; t < glSampler.count; ++t) {
                      while (usedTexUnits[cachedUnit]) {
                        cachedUnit = (cachedUnit + 1) % device.maxTextureUnits;
                      }

                      glSampler.units.push(cachedUnit);
                      usedTexUnits[cachedUnit] = true;
                    }
                  }
                }

                var unitIdx = 0;

                for (var _i11 = 0; _i11 < glActiveSamplers.length; ++_i11) {
                  var _glSampler = glActiveSamplers[_i11];

                  if (!_glSampler.glLoc) {
                    _glSampler.glLoc = glActiveSamplerLocations[_i11];

                    while (usedTexUnits[unitIdx]) {
                      unitIdx++;
                    }

                    for (var _t = 0; _t < _glSampler.count; ++_t) {
                      while (usedTexUnits[unitIdx]) {
                        unitIdx = (unitIdx + 1) % device.maxTextureUnits;
                      }

                      if (texUnitCacheMap[_glSampler.name] === undefined) {
                        texUnitCacheMap[_glSampler.name] = unitIdx;
                      }

                      _glSampler.units.push(unitIdx);

                      usedTexUnits[unitIdx] = true;
                    }
                  }
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(gpuShader.glProgram);
                }

                for (var _k4 = 0; _k4 < glActiveSamplers.length; _k4++) {
                  var _glSampler2 = glActiveSamplers[_k4];
                  _glSampler2.glUnits = new Int32Array(_glSampler2.units);
                  gl.uniform1iv(_glSampler2.glLoc, _glSampler2.glUnits);
                }

                if (device.stateCache.glProgram !== gpuShader.glProgram) {
                  gl.useProgram(device.stateCache.glProgram);
                }
              }

              gpuShader.glSamplers = glActiveSamplers;
            }
            function WebGL2CmdFuncDestroyShader(device, gpuShader) {
              if (gpuShader.glProgram) {
                device.gl.deleteProgram(gpuShader.glProgram);
                gpuShader.glProgram = null;
              }
            }
            function WebGL2CmdFuncCreateInputAssember(device, gpuInputAssembler) {
              var gl = device.gl;
              gpuInputAssembler.glAttribs = new Array(gpuInputAssembler.attributes.length);
              var offsets = [0, 0, 0, 0, 0, 0, 0, 0];

              for (var i = 0; i < gpuInputAssembler.attributes.length; ++i) {
                var attrib = gpuInputAssembler.attributes[i];
                var stream = attrib.stream !== undefined ? attrib.stream : 0;
                var gpuBuffer = gpuInputAssembler.gpuVertexBuffers[stream];
                var glType = GFXFormatToWebGLType$1(attrib.format, gl);
                var size = FormatInfos[attrib.format].size;
                gpuInputAssembler.glAttribs[i] = {
                  name: attrib.name,
                  glBuffer: gpuBuffer.glBuffer,
                  glType: glType,
                  size: size,
                  count: FormatInfos[attrib.format].count,
                  stride: gpuBuffer.stride,
                  componentCount: WebGLGetComponentCount$1(glType, gl),
                  isNormalized: attrib.isNormalized !== undefined ? attrib.isNormalized : false,
                  isInstanced: attrib.isInstanced !== undefined ? attrib.isInstanced : false,
                  offset: offsets[stream]
                };
                offsets[stream] += size;
              }
            }
            function WebGL2CmdFuncDestroyInputAssembler(device, gpuInputAssembler) {
              var it = gpuInputAssembler.glVAOs.values();
              var res = it.next();

              while (!res.done) {
                device.gl.deleteVertexArray(res.value);
                res = it.next();
              }

              gpuInputAssembler.glVAOs.clear();
            }
            var gfxStateCache$1 = {
              gpuPipelineState: null,
              gpuInputAssembler: null,
              reverseCW: false,
              glPrimitive: 0,
              invalidateAttachments: []
            };
            function WebGL2CmdFuncBeginRenderPass(device, gpuRenderPass, gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil) {
              var gl = device.gl;
              var cache = device.stateCache;
              var clears = 0;

              if (gpuFramebuffer && gpuRenderPass) {
                if (cache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  cache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                  var reverseCW = !!gpuFramebuffer.glFramebuffer;

                  if (reverseCW !== gfxStateCache$1.reverseCW) {
                    gfxStateCache$1.reverseCW = reverseCW;
                    var isCCW = !device.stateCache.rs.isFrontFaceCCW;
                    gl.frontFace(isCCW ? gl.CCW : gl.CW);
                    device.stateCache.rs.isFrontFaceCCW = isCCW;
                  }
                }

                if (cache.viewport.left !== renderArea.x || cache.viewport.top !== renderArea.y || cache.viewport.width !== renderArea.width || cache.viewport.height !== renderArea.height) {
                  gl.viewport(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.viewport.left = renderArea.x;
                  cache.viewport.top = renderArea.y;
                  cache.viewport.width = renderArea.width;
                  cache.viewport.height = renderArea.height;
                }

                if (cache.scissorRect.x !== renderArea.x || cache.scissorRect.y !== renderArea.y || cache.scissorRect.width !== renderArea.width || cache.scissorRect.height !== renderArea.height) {
                  gl.scissor(renderArea.x, renderArea.y, renderArea.width, renderArea.height);
                  cache.scissorRect.x = renderArea.x;
                  cache.scissorRect.y = renderArea.y;
                  cache.scissorRect.width = renderArea.width;
                  cache.scissorRect.height = renderArea.height;
                }

                gfxStateCache$1.invalidateAttachments.length = 0;

                for (var j = 0; j < clearColors.length; ++j) {
                  var colorAttachment = gpuRenderPass.colorAttachments[j];

                  if (colorAttachment.format !== Format.UNKNOWN) {
                    switch (colorAttachment.loadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (cache.bs.targets[0].blendColorMask !== ColorMask.ALL) {
                            gl.colorMask(true, true, true, true);
                          }

                          if (!gpuFramebuffer.isOffscreen) {
                            var clearColor = clearColors[0];
                            gl.clearColor(clearColor.x, clearColor.y, clearColor.z, clearColor.w);
                            clears |= gl.COLOR_BUFFER_BIT;
                          } else {
                            _f32v4[0] = clearColors[j].x;
                            _f32v4[1] = clearColors[j].y;
                            _f32v4[2] = clearColors[j].z;
                            _f32v4[3] = clearColors[j].w;
                            gl.clearBufferfv(gl.COLOR, j, _f32v4);
                          }

                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.COLOR_ATTACHMENT0 + j);
                          break;
                        }
                    }
                  }
                }

                if (gpuRenderPass.depthStencilAttachment) {
                  if (gpuRenderPass.depthStencilAttachment.format !== Format.UNKNOWN) {
                    switch (gpuRenderPass.depthStencilAttachment.depthLoadOp) {
                      case LoadOp.LOAD:
                        break;

                      case LoadOp.CLEAR:
                        {
                          if (!cache.dss.depthWrite) {
                            gl.depthMask(true);
                          }

                          gl.clearDepth(clearDepth);
                          clears |= gl.DEPTH_BUFFER_BIT;
                          break;
                        }

                      case LoadOp.DISCARD:
                        {
                          gfxStateCache$1.invalidateAttachments.push(gl.DEPTH_ATTACHMENT);
                          break;
                        }
                    }

                    if (FormatInfos[gpuRenderPass.depthStencilAttachment.format].hasStencil) {
                      switch (gpuRenderPass.depthStencilAttachment.stencilLoadOp) {
                        case LoadOp.LOAD:
                          break;

                        case LoadOp.CLEAR:
                          {
                            if (!cache.dss.stencilWriteMaskFront) {
                              gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                            }

                            if (!cache.dss.stencilWriteMaskBack) {
                              gl.stencilMaskSeparate(gl.BACK, 0xffff);
                            }

                            gl.clearStencil(clearStencil);
                            clears |= gl.STENCIL_BUFFER_BIT;
                            break;
                          }

                        case LoadOp.DISCARD:
                          {
                            gfxStateCache$1.invalidateAttachments.push(gl.STENCIL_ATTACHMENT);
                            break;
                          }
                      }
                    }
                  }
                }

                if (gpuFramebuffer.glFramebuffer && gfxStateCache$1.invalidateAttachments.length) {
                  gl.invalidateFramebuffer(gl.FRAMEBUFFER, gfxStateCache$1.invalidateAttachments);
                }

                if (clears) {
                  gl.clear(clears);
                }

                if (clears & gl.COLOR_BUFFER_BIT) {
                  var colorMask = cache.bs.targets[0].blendColorMask;

                  if (colorMask !== ColorMask.ALL) {
                    var r = (colorMask & ColorMask.R) !== ColorMask.NONE;
                    var g = (colorMask & ColorMask.G) !== ColorMask.NONE;
                    var b = (colorMask & ColorMask.B) !== ColorMask.NONE;
                    var a = (colorMask & ColorMask.A) !== ColorMask.NONE;
                    gl.colorMask(r, g, b, a);
                  }
                }

                if (clears & gl.DEPTH_BUFFER_BIT && !cache.dss.depthWrite) {
                  gl.depthMask(false);
                }

                if (clears & gl.STENCIL_BUFFER_BIT) {
                  if (!cache.dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, 0);
                  }

                  if (!cache.dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, 0);
                  }
                }
              }
            }
            function WebGL2CmdFuncBindStates(device, gpuPipelineState, gpuInputAssembler, gpuDescriptorSets, dynamicOffsets, viewport, scissor, lineWidth, depthBias, blendConstants, depthBounds, stencilWriteMask, stencilCompareMask) {
              var gl = device.gl;
              var cache = device.stateCache;
              var gpuShader = gpuPipelineState && gpuPipelineState.gpuShader;
              var isShaderChanged = false;

              if (gpuPipelineState && gfxStateCache$1.gpuPipelineState !== gpuPipelineState) {
                gfxStateCache$1.gpuPipelineState = gpuPipelineState;
                gfxStateCache$1.glPrimitive = gpuPipelineState.glPrimitive;

                if (gpuShader) {
                  var glProgram = gpuShader.glProgram;

                  if (cache.glProgram !== glProgram) {
                    gl.useProgram(glProgram);
                    cache.glProgram = glProgram;
                    isShaderChanged = true;
                  }
                }

                var rs = gpuPipelineState.rs;

                if (rs) {
                  if (cache.rs.cullMode !== rs.cullMode) {
                    switch (rs.cullMode) {
                      case CullMode.NONE:
                        {
                          gl.disable(gl.CULL_FACE);
                          break;
                        }

                      case CullMode.FRONT:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.FRONT);
                          break;
                        }

                      case CullMode.BACK:
                        {
                          gl.enable(gl.CULL_FACE);
                          gl.cullFace(gl.BACK);
                          break;
                        }
                    }

                    device.stateCache.rs.cullMode = rs.cullMode;
                  }

                  var isFrontFaceCCW = rs.isFrontFaceCCW !== gfxStateCache$1.reverseCW;

                  if (device.stateCache.rs.isFrontFaceCCW !== isFrontFaceCCW) {
                    gl.frontFace(isFrontFaceCCW ? gl.CCW : gl.CW);
                    device.stateCache.rs.isFrontFaceCCW = isFrontFaceCCW;
                  }

                  if (device.stateCache.rs.depthBias !== rs.depthBias || device.stateCache.rs.depthBiasSlop !== rs.depthBiasSlop) {
                    gl.polygonOffset(rs.depthBias, rs.depthBiasSlop);
                    device.stateCache.rs.depthBias = rs.depthBias;
                    device.stateCache.rs.depthBiasSlop = rs.depthBiasSlop;
                  }

                  if (device.stateCache.rs.lineWidth !== rs.lineWidth) {
                    gl.lineWidth(rs.lineWidth);
                    device.stateCache.rs.lineWidth = rs.lineWidth;
                  }
                }

                var dss = gpuPipelineState.dss;

                if (dss) {
                  if (cache.dss.depthTest !== dss.depthTest) {
                    if (dss.depthTest) {
                      gl.enable(gl.DEPTH_TEST);
                    } else {
                      gl.disable(gl.DEPTH_TEST);
                    }

                    cache.dss.depthTest = dss.depthTest;
                  }

                  if (cache.dss.depthWrite !== dss.depthWrite) {
                    gl.depthMask(dss.depthWrite);
                    cache.dss.depthWrite = dss.depthWrite;
                  }

                  if (cache.dss.depthFunc !== dss.depthFunc) {
                    gl.depthFunc(WebGLCmpFuncs$1[dss.depthFunc]);
                    cache.dss.depthFunc = dss.depthFunc;
                  }

                  if (cache.dss.stencilTestFront !== dss.stencilTestFront || cache.dss.stencilTestBack !== dss.stencilTestBack) {
                    if (dss.stencilTestFront || dss.stencilTestBack) {
                      gl.enable(gl.STENCIL_TEST);
                    } else {
                      gl.disable(gl.STENCIL_TEST);
                    }

                    cache.dss.stencilTestFront = dss.stencilTestFront;
                    cache.dss.stencilTestBack = dss.stencilTestBack;
                  }

                  if (cache.dss.stencilFuncFront !== dss.stencilFuncFront || cache.dss.stencilRefFront !== dss.stencilRefFront || cache.dss.stencilReadMaskFront !== dss.stencilReadMaskFront) {
                    gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[dss.stencilFuncFront], dss.stencilRefFront, dss.stencilReadMaskFront);
                    cache.dss.stencilFuncFront = dss.stencilFuncFront;
                    cache.dss.stencilRefFront = dss.stencilRefFront;
                    cache.dss.stencilReadMaskFront = dss.stencilReadMaskFront;
                  }

                  if (cache.dss.stencilFailOpFront !== dss.stencilFailOpFront || cache.dss.stencilZFailOpFront !== dss.stencilZFailOpFront || cache.dss.stencilPassOpFront !== dss.stencilPassOpFront) {
                    gl.stencilOpSeparate(gl.FRONT, WebGLStencilOps$1[dss.stencilFailOpFront], WebGLStencilOps$1[dss.stencilZFailOpFront], WebGLStencilOps$1[dss.stencilPassOpFront]);
                    cache.dss.stencilFailOpFront = dss.stencilFailOpFront;
                    cache.dss.stencilZFailOpFront = dss.stencilZFailOpFront;
                    cache.dss.stencilPassOpFront = dss.stencilPassOpFront;
                  }

                  if (cache.dss.stencilWriteMaskFront !== dss.stencilWriteMaskFront) {
                    gl.stencilMaskSeparate(gl.FRONT, dss.stencilWriteMaskFront);
                    cache.dss.stencilWriteMaskFront = dss.stencilWriteMaskFront;
                  }

                  if (cache.dss.stencilFuncBack !== dss.stencilFuncBack || cache.dss.stencilRefBack !== dss.stencilRefBack || cache.dss.stencilReadMaskBack !== dss.stencilReadMaskBack) {
                    gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[dss.stencilFuncBack], dss.stencilRefBack, dss.stencilReadMaskBack);
                    cache.dss.stencilFuncBack = dss.stencilFuncBack;
                    cache.dss.stencilRefBack = dss.stencilRefBack;
                    cache.dss.stencilReadMaskBack = dss.stencilReadMaskBack;
                  }

                  if (cache.dss.stencilFailOpBack !== dss.stencilFailOpBack || cache.dss.stencilZFailOpBack !== dss.stencilZFailOpBack || cache.dss.stencilPassOpBack !== dss.stencilPassOpBack) {
                    gl.stencilOpSeparate(gl.BACK, WebGLStencilOps$1[dss.stencilFailOpBack], WebGLStencilOps$1[dss.stencilZFailOpBack], WebGLStencilOps$1[dss.stencilPassOpBack]);
                    cache.dss.stencilFailOpBack = dss.stencilFailOpBack;
                    cache.dss.stencilZFailOpBack = dss.stencilZFailOpBack;
                    cache.dss.stencilPassOpBack = dss.stencilPassOpBack;
                  }

                  if (cache.dss.stencilWriteMaskBack !== dss.stencilWriteMaskBack) {
                    gl.stencilMaskSeparate(gl.BACK, dss.stencilWriteMaskBack);
                    cache.dss.stencilWriteMaskBack = dss.stencilWriteMaskBack;
                  }
                }

                var bs = gpuPipelineState.bs;

                if (bs) {
                  if (cache.bs.isA2C !== bs.isA2C) {
                    if (bs.isA2C) {
                      gl.enable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    } else {
                      gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                    }

                    cache.bs.isA2C = bs.isA2C;
                  }

                  if (cache.bs.blendColor.x !== bs.blendColor.x || cache.bs.blendColor.y !== bs.blendColor.y || cache.bs.blendColor.z !== bs.blendColor.z || cache.bs.blendColor.w !== bs.blendColor.w) {
                    gl.blendColor(bs.blendColor.x, bs.blendColor.y, bs.blendColor.z, bs.blendColor.w);
                    cache.bs.blendColor.x = bs.blendColor.x;
                    cache.bs.blendColor.y = bs.blendColor.y;
                    cache.bs.blendColor.z = bs.blendColor.z;
                    cache.bs.blendColor.w = bs.blendColor.w;
                  }

                  var target0 = bs.targets[0];
                  var target0Cache = cache.bs.targets[0];

                  if (target0Cache.blend !== target0.blend) {
                    if (target0.blend) {
                      gl.enable(gl.BLEND);
                    } else {
                      gl.disable(gl.BLEND);
                    }

                    target0Cache.blend = target0.blend;
                  }

                  if (target0Cache.blendEq !== target0.blendEq || target0Cache.blendAlphaEq !== target0.blendAlphaEq) {
                    gl.blendEquationSeparate(WebGLBlendOps$1[target0.blendEq], WebGLBlendOps$1[target0.blendAlphaEq]);
                    target0Cache.blendEq = target0.blendEq;
                    target0Cache.blendAlphaEq = target0.blendAlphaEq;
                  }

                  if (target0Cache.blendSrc !== target0.blendSrc || target0Cache.blendDst !== target0.blendDst || target0Cache.blendSrcAlpha !== target0.blendSrcAlpha || target0Cache.blendDstAlpha !== target0.blendDstAlpha) {
                    gl.blendFuncSeparate(WebGLBlendFactors$1[target0.blendSrc], WebGLBlendFactors$1[target0.blendDst], WebGLBlendFactors$1[target0.blendSrcAlpha], WebGLBlendFactors$1[target0.blendDstAlpha]);
                    target0Cache.blendSrc = target0.blendSrc;
                    target0Cache.blendDst = target0.blendDst;
                    target0Cache.blendSrcAlpha = target0.blendSrcAlpha;
                    target0Cache.blendDstAlpha = target0.blendDstAlpha;
                  }

                  if (target0Cache.blendColorMask !== target0.blendColorMask) {
                    gl.colorMask((target0.blendColorMask & ColorMask.R) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.G) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.B) !== ColorMask.NONE, (target0.blendColorMask & ColorMask.A) !== ColorMask.NONE);
                    target0Cache.blendColorMask = target0.blendColorMask;
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.gpuPipelineLayout && gpuShader) {
                var blockLen = gpuShader.glBlocks.length;
                var dynamicOffsetIndices = gpuPipelineState.gpuPipelineLayout.dynamicOffsetIndices;

                for (var j = 0; j < blockLen; j++) {
                  var glBlock = gpuShader.glBlocks[j];
                  var gpuDescriptorSet = gpuDescriptorSets[glBlock.set];
                  var descriptorIndex = gpuDescriptorSet && gpuDescriptorSet.descriptorIndices[glBlock.binding];
                  var gpuDescriptor = descriptorIndex >= 0 && gpuDescriptorSet.gpuDescriptors[descriptorIndex];

                  if (!gpuDescriptor || !gpuDescriptor.gpuBuffer) {
                    error("Buffer binding '" + glBlock.name + "' at set " + glBlock.set + " binding " + glBlock.binding + " is not bounded");
                    continue;
                  }

                  var dynamicOffsetIndexSet = dynamicOffsetIndices[glBlock.set];
                  var dynamicOffsetIndex = dynamicOffsetIndexSet && dynamicOffsetIndexSet[glBlock.binding];
                  var offset = gpuDescriptor.gpuBuffer.glOffset;

                  if (dynamicOffsetIndex >= 0) {
                    offset += dynamicOffsets[dynamicOffsetIndex];
                  }

                  if (cache.glBindUBOs[glBlock.glBinding] !== gpuDescriptor.gpuBuffer.glBuffer || cache.glBindUBOOffsets[glBlock.glBinding] !== offset) {
                    if (offset) {
                      gl.bindBufferRange(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer, offset, gpuDescriptor.gpuBuffer.size);
                    } else {
                      gl.bindBufferBase(gl.UNIFORM_BUFFER, glBlock.glBinding, gpuDescriptor.gpuBuffer.glBuffer);
                    }

                    cache.glUniformBuffer = cache.glBindUBOs[glBlock.glBinding] = gpuDescriptor.gpuBuffer.glBuffer;
                    cache.glBindUBOOffsets[glBlock.glBinding] = offset;
                  }
                }

                var samplerLen = gpuShader.glSamplers.length;

                for (var i = 0; i < samplerLen; i++) {
                  var glSampler = gpuShader.glSamplers[i];
                  var _gpuDescriptorSet = gpuDescriptorSets[glSampler.set];

                  var _descriptorIndex = _gpuDescriptorSet && _gpuDescriptorSet.descriptorIndices[glSampler.binding];

                  var _gpuDescriptor = _descriptorIndex >= 0 && _gpuDescriptorSet.gpuDescriptors[_descriptorIndex];

                  for (var l = 0; l < glSampler.units.length; l++) {
                    var texUnit = glSampler.units[l];
                    var glTexUnit = cache.glTexUnits[texUnit];

                    if (!_gpuDescriptor || !_gpuDescriptor.gpuTexture || !_gpuDescriptor.gpuSampler) {
                      error("Sampler binding '" + glSampler.name + "' at set " + glSampler.set + " binding " + glSampler.binding + " index " + l + " is not bounded");
                      continue;
                    }

                    if (_gpuDescriptor.gpuTexture && _gpuDescriptor.gpuTexture.size > 0) {
                      var _gpuDescriptor2 = _gpuDescriptor,
                          gpuTexture = _gpuDescriptor2.gpuTexture;

                      if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                        if (cache.texUnit !== texUnit) {
                          gl.activeTexture(gl.TEXTURE0 + texUnit);
                          cache.texUnit = texUnit;
                        }

                        if (gpuTexture.glTexture) {
                          gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                        } else {
                          gl.bindTexture(gpuTexture.glTarget, device.nullTex2D.gpuTexture.glTexture);
                        }

                        glTexUnit.glTexture = gpuTexture.glTexture;
                      }

                      var _gpuDescriptor3 = _gpuDescriptor,
                          gpuSampler = _gpuDescriptor3.gpuSampler;

                      if (cache.glSamplerUnits[texUnit] !== gpuSampler.glSampler) {
                        gl.bindSampler(texUnit, gpuSampler.glSampler);
                        cache.glSamplerUnits[texUnit] = gpuSampler.glSampler;
                      }
                    }

                    _gpuDescriptor = _gpuDescriptorSet.gpuDescriptors[++_descriptorIndex];
                  }
                }
              }

              if (gpuInputAssembler && gpuShader && (isShaderChanged || gfxStateCache$1.gpuInputAssembler !== gpuInputAssembler)) {
                gfxStateCache$1.gpuInputAssembler = gpuInputAssembler;

                if (device.useVAO) {
                  var glVAO = gpuInputAssembler.glVAOs.get(gpuShader.glProgram);

                  if (!glVAO) {
                    glVAO = gl.createVertexArray();
                    gpuInputAssembler.glVAOs.set(gpuShader.glProgram, glVAO);
                    gl.bindVertexArray(glVAO);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                    var glAttrib;

                    for (var _j = 0; _j < gpuShader.glInputs.length; _j++) {
                      var glInput = gpuShader.glInputs[_j];
                      glAttrib = null;

                      for (var k = 0; k < gpuInputAssembler.glAttribs.length; k++) {
                        var attrib = gpuInputAssembler.glAttribs[k];

                        if (attrib.name === glInput.name) {
                          glAttrib = attrib;
                          break;
                        }
                      }

                      if (glAttrib) {
                        if (cache.glArrayBuffer !== glAttrib.glBuffer) {
                          gl.bindBuffer(gl.ARRAY_BUFFER, glAttrib.glBuffer);
                          cache.glArrayBuffer = glAttrib.glBuffer;
                        }

                        for (var c = 0; c < glAttrib.componentCount; ++c) {
                          var glLoc = glInput.glLoc + c;
                          var attribOffset = glAttrib.offset + glAttrib.size * c;
                          gl.enableVertexAttribArray(glLoc);
                          cache.glCurrentAttribLocs[glLoc] = true;
                          gl.vertexAttribPointer(glLoc, glAttrib.count, glAttrib.glType, glAttrib.isNormalized, glAttrib.stride, attribOffset);
                          gl.vertexAttribDivisor(glLoc, glAttrib.isInstanced ? 1 : 0);
                        }
                      }
                    }

                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (gpuBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gpuBuffer.glBuffer);
                    }

                    gl.bindVertexArray(null);
                    gl.bindBuffer(gl.ARRAY_BUFFER, null);
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
                    cache.glArrayBuffer = null;
                    cache.glElementArrayBuffer = null;
                  }

                  if (cache.glVAO !== glVAO) {
                    gl.bindVertexArray(glVAO);
                    cache.glVAO = glVAO;
                  }
                } else {
                  for (var a = 0; a < device.maxVertexAttributes; ++a) {
                    cache.glCurrentAttribLocs[a] = false;
                  }

                  for (var _j2 = 0; _j2 < gpuShader.glInputs.length; _j2++) {
                    var _glInput = gpuShader.glInputs[_j2];
                    var _glAttrib = null;

                    for (var _k5 = 0; _k5 < gpuInputAssembler.glAttribs.length; _k5++) {
                      var _attrib = gpuInputAssembler.glAttribs[_k5];

                      if (_attrib.name === _glInput.name) {
                        _glAttrib = _attrib;
                        break;
                      }
                    }

                    if (_glAttrib) {
                      if (cache.glArrayBuffer !== _glAttrib.glBuffer) {
                        gl.bindBuffer(gl.ARRAY_BUFFER, _glAttrib.glBuffer);
                        cache.glArrayBuffer = _glAttrib.glBuffer;
                      }

                      for (var _c = 0; _c < _glAttrib.componentCount; ++_c) {
                        var _glLoc2 = _glInput.glLoc + _c;

                        var _attribOffset = _glAttrib.offset + _glAttrib.size * _c;

                        if (!cache.glEnabledAttribLocs[_glLoc2] && _glLoc2 >= 0) {
                          gl.enableVertexAttribArray(_glLoc2);
                          cache.glEnabledAttribLocs[_glLoc2] = true;
                        }

                        cache.glCurrentAttribLocs[_glLoc2] = true;
                        gl.vertexAttribPointer(_glLoc2, _glAttrib.count, _glAttrib.glType, _glAttrib.isNormalized, _glAttrib.stride, _attribOffset);
                        gl.vertexAttribDivisor(_glLoc2, _glAttrib.isInstanced ? 1 : 0);
                      }
                    }
                  }

                  var _gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                  if (_gpuBuffer) {
                    if (cache.glElementArrayBuffer !== _gpuBuffer.glBuffer) {
                      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, _gpuBuffer.glBuffer);
                      cache.glElementArrayBuffer = _gpuBuffer.glBuffer;
                    }
                  }

                  for (var _a = 0; _a < device.maxVertexAttributes; ++_a) {
                    if (cache.glEnabledAttribLocs[_a] !== cache.glCurrentAttribLocs[_a]) {
                      gl.disableVertexAttribArray(_a);
                      cache.glEnabledAttribLocs[_a] = false;
                    }
                  }
                }
              }

              if (gpuPipelineState && gpuPipelineState.dynamicStates.length) {
                var dsLen = gpuPipelineState.dynamicStates.length;

                for (var _k6 = 0; _k6 < dsLen; _k6++) {
                  var dynamicState = gpuPipelineState.dynamicStates[_k6];

                  switch (dynamicState) {
                    case DynamicStateFlagBit.VIEWPORT:
                      {
                        if (viewport) {
                          if (cache.viewport.left !== viewport.left || cache.viewport.top !== viewport.top || cache.viewport.width !== viewport.width || cache.viewport.height !== viewport.height) {
                            gl.viewport(viewport.left, viewport.top, viewport.width, viewport.height);
                            cache.viewport.left = viewport.left;
                            cache.viewport.top = viewport.top;
                            cache.viewport.width = viewport.width;
                            cache.viewport.height = viewport.height;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.SCISSOR:
                      {
                        if (scissor) {
                          if (cache.scissorRect.x !== scissor.x || cache.scissorRect.y !== scissor.y || cache.scissorRect.width !== scissor.width || cache.scissorRect.height !== scissor.height) {
                            gl.scissor(scissor.x, scissor.y, scissor.width, scissor.height);
                            cache.scissorRect.x = scissor.x;
                            cache.scissorRect.y = scissor.y;
                            cache.scissorRect.width = scissor.width;
                            cache.scissorRect.height = scissor.height;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.LINE_WIDTH:
                      {
                        if (lineWidth) {
                          if (cache.rs.lineWidth !== lineWidth) {
                            gl.lineWidth(lineWidth);
                            cache.rs.lineWidth = lineWidth;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.DEPTH_BIAS:
                      {
                        if (depthBias) {
                          if (cache.rs.depthBias !== depthBias.constantFactor || cache.rs.depthBiasSlop !== depthBias.slopeFactor) {
                            gl.polygonOffset(depthBias.constantFactor, depthBias.slopeFactor);
                            cache.rs.depthBias = depthBias.constantFactor;
                            cache.rs.depthBiasSlop = depthBias.slopeFactor;
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.BLEND_CONSTANTS:
                      {
                        if (cache.bs.blendColor.x !== blendConstants[0] || cache.bs.blendColor.y !== blendConstants[1] || cache.bs.blendColor.z !== blendConstants[2] || cache.bs.blendColor.w !== blendConstants[3]) {
                          gl.blendColor(blendConstants[0], blendConstants[1], blendConstants[2], blendConstants[3]);
                          cache.bs.blendColor.x = blendConstants[0];
                          cache.bs.blendColor.y = blendConstants[1];
                          cache.bs.blendColor.z = blendConstants[2];
                          cache.bs.blendColor.w = blendConstants[3];
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_WRITE_MASK:
                      {
                        if (stencilWriteMask) {
                          switch (stencilWriteMask.face) {
                            case StencilFace.FRONT:
                              {
                                if (cache.dss.stencilWriteMaskFront !== stencilWriteMask.writeMask) {
                                  gl.stencilMaskSeparate(gl.FRONT, stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask;
                                }

                                break;
                              }

                            case StencilFace.BACK:
                              {
                                if (cache.dss.stencilWriteMaskBack !== stencilWriteMask.writeMask) {
                                  gl.stencilMaskSeparate(gl.BACK, stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask;
                                }

                                break;
                              }

                            case StencilFace.ALL:
                              {
                                if (cache.dss.stencilWriteMaskFront !== stencilWriteMask.writeMask || cache.dss.stencilWriteMaskBack !== stencilWriteMask.writeMask) {
                                  gl.stencilMask(stencilWriteMask.writeMask);
                                  cache.dss.stencilWriteMaskFront = stencilWriteMask.writeMask;
                                  cache.dss.stencilWriteMaskBack = stencilWriteMask.writeMask;
                                }

                                break;
                              }
                          }
                        }

                        break;
                      }

                    case DynamicStateFlagBit.STENCIL_COMPARE_MASK:
                      {
                        if (stencilCompareMask) {
                          switch (stencilCompareMask.face) {
                            case StencilFace.FRONT:
                              {
                                if (cache.dss.stencilRefFront !== stencilCompareMask.reference || cache.dss.stencilReadMaskFront !== stencilCompareMask.compareMask) {
                                  gl.stencilFuncSeparate(gl.FRONT, WebGLCmpFuncs$1[cache.dss.stencilFuncFront], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefFront = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask;
                                }

                                break;
                              }

                            case StencilFace.BACK:
                              {
                                if (cache.dss.stencilRefBack !== stencilCompareMask.reference || cache.dss.stencilReadMaskBack !== stencilCompareMask.compareMask) {
                                  gl.stencilFuncSeparate(gl.BACK, WebGLCmpFuncs$1[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefBack = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask;
                                }

                                break;
                              }

                            case StencilFace.ALL:
                              {
                                if (cache.dss.stencilRefFront !== stencilCompareMask.reference || cache.dss.stencilReadMaskFront !== stencilCompareMask.compareMask || cache.dss.stencilRefBack !== stencilCompareMask.reference || cache.dss.stencilReadMaskBack !== stencilCompareMask.compareMask) {
                                  gl.stencilFunc(WebGLCmpFuncs$1[cache.dss.stencilFuncBack], stencilCompareMask.reference, stencilCompareMask.compareMask);
                                  cache.dss.stencilRefFront = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskFront = stencilCompareMask.compareMask;
                                  cache.dss.stencilRefBack = stencilCompareMask.reference;
                                  cache.dss.stencilReadMaskBack = stencilCompareMask.compareMask;
                                }

                                break;
                              }
                          }
                        }

                        break;
                      }
                  }
                }
              }
            }
            function WebGL2CmdFuncDraw(device, drawInfo) {
              var gl = device.gl;
              var gpuInputAssembler = gfxStateCache$1.gpuInputAssembler,
                  glPrimitive = gfxStateCache$1.glPrimitive;

              if (gpuInputAssembler) {
                if (gpuInputAssembler.gpuIndirectBuffer) {
                  var indirects = gpuInputAssembler.gpuIndirectBuffer.indirects;

                  for (var k = 0; k < indirects.length; k++) {
                    var subDrawInfo = indirects[k];
                    var gpuBuffer = gpuInputAssembler.gpuIndexBuffer;

                    if (subDrawInfo.instanceCount) {
                      if (gpuBuffer) {
                        if (subDrawInfo.indexCount > 0) {
                          var offset = subDrawInfo.firstIndex * gpuBuffer.stride;
                          gl.drawElementsInstanced(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, offset, subDrawInfo.instanceCount);
                        }
                      } else if (subDrawInfo.vertexCount > 0) {
                        gl.drawArraysInstanced(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount, subDrawInfo.instanceCount);
                      }
                    } else if (gpuBuffer) {
                      if (subDrawInfo.indexCount > 0) {
                        var _offset = subDrawInfo.firstIndex * gpuBuffer.stride;

                        gl.drawElements(glPrimitive, subDrawInfo.indexCount, gpuInputAssembler.glIndexType, _offset);
                      }
                    } else if (subDrawInfo.vertexCount > 0) {
                      gl.drawArrays(glPrimitive, subDrawInfo.firstVertex, subDrawInfo.vertexCount);
                    }
                  }
                } else if (drawInfo.instanceCount) {
                  if (gpuInputAssembler.gpuIndexBuffer) {
                    if (drawInfo.indexCount > 0) {
                      var _offset2 = drawInfo.firstIndex * gpuInputAssembler.gpuIndexBuffer.stride;

                      gl.drawElementsInstanced(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset2, drawInfo.instanceCount);
                    }
                  } else if (drawInfo.vertexCount > 0) {
                    gl.drawArraysInstanced(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount, drawInfo.instanceCount);
                  }
                } else if (gpuInputAssembler.gpuIndexBuffer) {
                  if (drawInfo.indexCount > 0) {
                    var _offset3 = drawInfo.firstIndex * gpuInputAssembler.gpuIndexBuffer.stride;

                    gl.drawElements(glPrimitive, drawInfo.indexCount, gpuInputAssembler.glIndexType, _offset3);
                  }
                } else if (drawInfo.vertexCount > 0) {
                  gl.drawArrays(glPrimitive, drawInfo.firstVertex, drawInfo.vertexCount);
                }
              }
            }
            var cmdIds$1 = new Array(WebGL2Cmd.COUNT);
            function WebGL2CmdFuncExecuteCmds(device, cmdPackage) {
              cmdIds$1.fill(0);

              for (var i = 0; i < cmdPackage.cmds.length; ++i) {
                var cmd = cmdPackage.cmds.array[i];
                var cmdId = cmdIds$1[cmd]++;

                switch (cmd) {
                  case WebGL2Cmd.BEGIN_RENDER_PASS:
                    {
                      var cmd0 = cmdPackage.beginRenderPassCmds.array[cmdId];
                      WebGL2CmdFuncBeginRenderPass(device, cmd0.gpuRenderPass, cmd0.gpuFramebuffer, cmd0.renderArea, cmd0.clearColors, cmd0.clearDepth, cmd0.clearStencil);
                      break;
                    }

                  case WebGL2Cmd.BIND_STATES:
                    {
                      var cmd2 = cmdPackage.bindStatesCmds.array[cmdId];
                      WebGL2CmdFuncBindStates(device, cmd2.gpuPipelineState, cmd2.gpuInputAssembler, cmd2.gpuDescriptorSets, cmd2.dynamicOffsets, cmd2.viewport, cmd2.scissor, cmd2.lineWidth, cmd2.depthBias, cmd2.blendConstants, cmd2.depthBounds, cmd2.stencilWriteMask, cmd2.stencilCompareMask);
                      break;
                    }

                  case WebGL2Cmd.DRAW:
                    {
                      var cmd3 = cmdPackage.drawCmds.array[cmdId];
                      WebGL2CmdFuncDraw(device, cmd3.drawInfo);
                      break;
                    }

                  case WebGL2Cmd.UPDATE_BUFFER:
                    {
                      var cmd4 = cmdPackage.updateBufferCmds.array[cmdId];
                      WebGL2CmdFuncUpdateBuffer(device, cmd4.gpuBuffer, cmd4.buffer, cmd4.offset, cmd4.size);
                      break;
                    }

                  case WebGL2Cmd.COPY_BUFFER_TO_TEXTURE:
                    {
                      var cmd5 = cmdPackage.copyBufferToTextureCmds.array[cmdId];
                      WebGL2CmdFuncCopyBuffersToTexture(device, cmd5.buffers, cmd5.gpuTexture, cmd5.regions);
                      break;
                    }
                }
              }
            }
            function WebGL2CmdFuncCopyTexImagesToTexture(device, texImages, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var f = 0;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _k7 = 0; _k7 < regions.length; _k7++) {
                      var _region = regions[_k7];
                      var fcount = _region.texSubres.baseArrayLayer + _region.texSubres.layerCount;

                      for (f = _region.texSubres.baseArrayLayer; f < fcount; ++f) {
                        gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region.texSubres.mipLevel, _region.texOffset.x, _region.texOffset.y, gpuTexture.glFormat, gpuTexture.glType, texImages[n++]);
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncCopyBuffersToTexture(device, buffers, gpuTexture, regions) {
              var gl = device.gl;
              var glTexUnit = device.stateCache.glTexUnits[device.stateCache.texUnit];

              if (glTexUnit.glTexture !== gpuTexture.glTexture) {
                gl.bindTexture(gpuTexture.glTarget, gpuTexture.glTexture);
                glTexUnit.glTexture = gpuTexture.glTexture;
              }

              var n = 0;
              var w = 1;
              var h = 1;
              var f = 0;
              var fmtInfo = FormatInfos[gpuTexture.format];
              var isCompressed = fmtInfo.isCompressed;

              switch (gpuTexture.glTarget) {
                case gl.TEXTURE_2D:
                  {
                    for (var k = 0; k < regions.length; k++) {
                      var region = regions[k];
                      w = region.texExtent.width;
                      h = region.texExtent.height;
                      var pixels = buffers[n++];

                      if (!isCompressed) {
                        gl.texSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, pixels);
                      } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                        gl.compressedTexSubImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, region.texOffset.x, region.texOffset.y, w, h, gpuTexture.glFormat, pixels);
                      } else {
                        gl.compressedTexImage2D(gl.TEXTURE_2D, region.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, pixels);
                      }
                    }

                    break;
                  }

                case gl.TEXTURE_CUBE_MAP:
                  {
                    for (var _k8 = 0; _k8 < regions.length; _k8++) {
                      var _region2 = regions[_k8];
                      var fcount = _region2.texSubres.baseArrayLayer + _region2.texSubres.layerCount;

                      for (f = _region2.texSubres.baseArrayLayer; f < fcount; ++f) {
                        w = _region2.texExtent.width;
                        h = _region2.texExtent.height;
                        var _pixels = buffers[n++];

                        if (!isCompressed) {
                          gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, gpuTexture.glType, _pixels);
                        } else if (gpuTexture.glInternalFmt !== WebGLEXT.COMPRESSED_RGB_ETC1_WEBGL) {
                          gl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, _region2.texOffset.x, _region2.texOffset.y, w, h, gpuTexture.glFormat, _pixels);
                        } else {
                          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + f, _region2.texSubres.mipLevel, gpuTexture.glInternalFmt, w, h, 0, _pixels);
                        }
                      }
                    }

                    break;
                  }

                default:
                  {
                    console.error('Unsupported GL texture type, copy buffer to texture failed.');
                  }
              }

              if (gpuTexture.flags & TextureFlagBit.GEN_MIPMAP) {
                gl.generateMipmap(gpuTexture.glTarget);
              }
            }
            function WebGL2CmdFuncBlitFramebuffer(device, src, dst, srcRect, dstRect, filter) {
              var gl = device.gl;

              if (device.stateCache.glReadFramebuffer !== src.glFramebuffer) {
                gl.bindFramebuffer(gl.READ_FRAMEBUFFER, src.glFramebuffer);
                device.stateCache.glReadFramebuffer = src.glFramebuffer;
              }

              var rebindFBO = dst.glFramebuffer !== device.stateCache.glFramebuffer;

              if (rebindFBO) {
                gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst.glFramebuffer);
              }

              var mask = 0;

              if (src.gpuColorTextures.length > 0) {
                mask |= gl.COLOR_BUFFER_BIT;
              }

              if (src.gpuDepthStencilTexture) {
                mask |= gl.DEPTH_BUFFER_BIT;

                if (FormatInfos[src.gpuDepthStencilTexture.format].hasStencil) {
                  mask |= gl.STENCIL_BUFFER_BIT;
                }
              }

              var glFilter = filter === Filter.LINEAR || filter === Filter.ANISOTROPIC ? gl.LINEAR : gl.NEAREST;
              gl.blitFramebuffer(srcRect.x, srcRect.y, srcRect.x + srcRect.width, srcRect.y + srcRect.height, dstRect.x, dstRect.y, dstRect.x + dstRect.width, dstRect.y + dstRect.height, mask, glFilter);

              if (rebindFBO) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, device.stateCache.glFramebuffer);
              }
            }

            var WebGL2Buffer = function (_Buffer) {
              _inheritsLoose(WebGL2Buffer, _Buffer);

              function WebGL2Buffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Buffer.call.apply(_Buffer, [this].concat(args)) || this;
                _this._gpuBuffer = null;
                return _this;
              }

              var _proto = WebGL2Buffer.prototype;

              _proto.initialize = function initialize(info) {
                if ('buffer' in info) {
                  this._isBufferView = true;
                  var buffer = info.buffer;
                  this._usage = buffer.usage;
                  this._memUsage = buffer.memUsage;
                  this._size = this._stride = info.range;
                  this._count = 1;
                  this._flags = buffer.flags;
                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: this._bakcupBuffer,
                    indirects: buffer.gpuBuffer.indirects,
                    glTarget: buffer.gpuBuffer.glTarget,
                    glBuffer: buffer.gpuBuffer.glBuffer,
                    glOffset: info.offset
                  };
                } else {
                  this._usage = info.usage;
                  this._memUsage = info.memUsage;
                  this._size = info.size;
                  this._stride = Math.max(info.stride || this._size, 1);
                  this._count = this._size / this._stride;
                  this._flags = info.flags;

                  if (this._usage & BufferUsageBit.INDIRECT) {
                    this._indirectBuffer = new IndirectBuffer();
                  }

                  if (this._flags & BufferFlagBit.BAKUP_BUFFER) {
                    this._bakcupBuffer = new Uint8Array(this._size);
                    this._device.memoryStatus.bufferSize += this._size;
                  }

                  this._gpuBuffer = {
                    usage: this._usage,
                    memUsage: this._memUsage,
                    size: this._size,
                    stride: this._stride,
                    buffer: this._bakcupBuffer,
                    indirects: [],
                    glTarget: 0,
                    glBuffer: null,
                    glOffset: 0
                  };

                  if (info.usage & BufferUsageBit.INDIRECT) {
                    this._gpuBuffer.indirects = this._indirectBuffer.drawInfos;
                  }

                  WebGL2CmdFuncCreateBuffer(this._device, this._gpuBuffer);
                  this._device.memoryStatus.bufferSize += this._size;
                }

                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuBuffer) {
                  if (!this._isBufferView) {
                    WebGL2CmdFuncDestroyBuffer(this._device, this._gpuBuffer);
                    this._device.memoryStatus.bufferSize -= this._size;
                  }

                  this._gpuBuffer = null;
                }

                this._bakcupBuffer = null;
              };

              _proto.resize = function resize(size) {
                if (this._isBufferView) {
                  console.warn('cannot resize buffer views!');
                  return;
                }

                var oldSize = this._size;

                if (oldSize === size) {
                  return;
                }

                this._size = size;
                this._count = this._size / this._stride;

                if (this._bakcupBuffer) {
                  var oldView = this._bakcupBuffer;
                  this._bakcupBuffer = new Uint8Array(this._size);

                  this._bakcupBuffer.set(oldView);

                  this._device.memoryStatus.bufferSize -= oldSize;
                  this._device.memoryStatus.bufferSize += size;
                }

                if (this._gpuBuffer) {
                  if (this._bakcupBuffer) {
                    this._gpuBuffer.buffer = this._bakcupBuffer;
                  }

                  this._gpuBuffer.size = size;

                  if (size > 0) {
                    WebGL2CmdFuncResizeBuffer(this._device, this._gpuBuffer);
                    this._device.memoryStatus.bufferSize -= oldSize;
                    this._device.memoryStatus.bufferSize += size;
                  }
                }
              };

              _proto.update = function update(buffer, size) {
                if (this._isBufferView) {
                  console.warn('cannot update through buffer views!');
                  return;
                }

                var buffSize;

                if (size !== undefined) {
                  buffSize = size;
                } else if (this._usage & BufferUsageBit.INDIRECT) {
                  buffSize = 0;
                } else {
                  buffSize = buffer.byteLength;
                }

                if (this._bakcupBuffer && buffer !== this._bakcupBuffer.buffer) {
                  var view = new Uint8Array(buffer, 0, size);

                  this._bakcupBuffer.set(view);
                }

                WebGL2CmdFuncUpdateBuffer(this._device, this._gpuBuffer, buffer, 0, buffSize);
              };

              _createClass(WebGL2Buffer, [{
                key: "gpuBuffer",
                get: function get() {
                  return this._gpuBuffer;
                }
              }]);

              return WebGL2Buffer;
            }(Buffer);

            var WebGL2CommandPool = function () {
              function WebGL2CommandPool(clazz, count) {
                this._frees = void 0;
                this._freeIdx = 0;
                this._freeCmds = void 0;
                this._frees = new Array(count);
                this._freeCmds = new CachedArray(count);

                for (var i = 0; i < count; ++i) {
                  this._frees[i] = new clazz();
                }

                this._freeIdx = count - 1;
              }

              var _proto = WebGL2CommandPool.prototype;

              _proto.alloc = function alloc(clazz) {
                if (this._freeIdx < 0) {
                  var size = this._frees.length * 2;
                  var temp = this._frees;
                  this._frees = new Array(size);
                  var increase = size - temp.length;

                  for (var i = 0; i < increase; ++i) {
                    this._frees[i] = new clazz();
                  }

                  for (var _i = increase, j = 0; _i < size; ++_i, ++j) {
                    this._frees[_i] = temp[j];
                  }

                  this._freeIdx += increase;
                }

                var cmd = this._frees[this._freeIdx];
                this._frees[this._freeIdx--] = null;
                ++cmd.refCount;
                return cmd;
              };

              _proto.free = function free(cmd) {
                if (--cmd.refCount === 0) {
                  this._freeCmds.push(cmd);
                }
              };

              _proto.freeCmds = function freeCmds(cmds) {
                for (var i = 0; i < cmds.length; ++i) {
                  if (--cmds.array[i].refCount === 0) {
                    this._freeCmds.push(cmds.array[i]);
                  }
                }
              };

              _proto.release = function release() {
                for (var i = 0; i < this._freeCmds.length; ++i) {
                  var cmd = this._freeCmds.array[i];
                  cmd.clear();
                  this._frees[++this._freeIdx] = cmd;
                }

                this._freeCmds.clear();
              };

              return WebGL2CommandPool;
            }();
            var WebGL2CommandAllocator = function () {
              function WebGL2CommandAllocator() {
                this.beginRenderPassCmdPool = void 0;
                this.bindStatesCmdPool = void 0;
                this.drawCmdPool = void 0;
                this.updateBufferCmdPool = void 0;
                this.copyBufferToTextureCmdPool = void 0;
                this.beginRenderPassCmdPool = new WebGL2CommandPool(WebGL2CmdBeginRenderPass, 1);
                this.bindStatesCmdPool = new WebGL2CommandPool(WebGL2CmdBindStates, 1);
                this.drawCmdPool = new WebGL2CommandPool(WebGL2CmdDraw, 1);
                this.updateBufferCmdPool = new WebGL2CommandPool(WebGL2CmdUpdateBuffer, 1);
                this.copyBufferToTextureCmdPool = new WebGL2CommandPool(WebGL2CmdCopyBufferToTexture, 1);
              }

              var _proto2 = WebGL2CommandAllocator.prototype;

              _proto2.clearCmds = function clearCmds(cmdPackage) {
                if (cmdPackage.beginRenderPassCmds.length) {
                  this.beginRenderPassCmdPool.freeCmds(cmdPackage.beginRenderPassCmds);
                  cmdPackage.beginRenderPassCmds.clear();
                }

                if (cmdPackage.bindStatesCmds.length) {
                  this.bindStatesCmdPool.freeCmds(cmdPackage.bindStatesCmds);
                  cmdPackage.bindStatesCmds.clear();
                }

                if (cmdPackage.drawCmds.length) {
                  this.drawCmdPool.freeCmds(cmdPackage.drawCmds);
                  cmdPackage.drawCmds.clear();
                }

                if (cmdPackage.updateBufferCmds.length) {
                  this.updateBufferCmdPool.freeCmds(cmdPackage.updateBufferCmds);
                  cmdPackage.updateBufferCmds.clear();
                }

                if (cmdPackage.copyBufferToTextureCmds.length) {
                  this.copyBufferToTextureCmdPool.freeCmds(cmdPackage.copyBufferToTextureCmds);
                  cmdPackage.copyBufferToTextureCmds.clear();
                }

                cmdPackage.cmds.clear();
              };

              _proto2.releaseCmds = function releaseCmds() {
                this.beginRenderPassCmdPool.release();
                this.bindStatesCmdPool.release();
                this.drawCmdPool.release();
                this.updateBufferCmdPool.release();
                this.copyBufferToTextureCmdPool.release();
              };

              return WebGL2CommandAllocator;
            }();

            var WebGL2CommandBuffer = function (_CommandBuffer) {
              _inheritsLoose(WebGL2CommandBuffer, _CommandBuffer);

              function WebGL2CommandBuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _CommandBuffer.call.apply(_CommandBuffer, [this].concat(args)) || this;
                _this.cmdPackage = new WebGL2CmdPackage();
                _this._webGLAllocator = null;
                _this._isInRenderPass = false;
                _this._curGPUPipelineState = null;
                _this._curGPUDescriptorSets = [];
                _this._curGPUInputAssembler = null;
                _this._curDynamicOffsets = [];
                _this._curViewport = null;
                _this._curScissor = null;
                _this._curLineWidth = null;
                _this._curDepthBias = null;
                _this._curBlendConstants = [];
                _this._curDepthBounds = null;
                _this._curStencilWriteMask = null;
                _this._curStencilCompareMask = null;
                _this._isStateInvalied = false;
                return _this;
              }

              var _proto = WebGL2CommandBuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                this._queue = info.queue;
                this._webGLAllocator = this._device.cmdAllocator;
                var setCount = this._device.bindingMappingInfo.bufferOffsets.length;

                for (var i = 0; i < setCount; i++) {
                  this._curGPUDescriptorSets.push(null);

                  this._curDynamicOffsets.push([]);
                }

                return true;
              };

              _proto.destroy = function destroy() {
                if (this._webGLAllocator) {
                  this._webGLAllocator.clearCmds(this.cmdPackage);

                  this._webGLAllocator = null;
                }
              };

              _proto.begin = function begin(renderPass, subpass, frameBuffer) {

                this._webGLAllocator.clearCmds(this.cmdPackage);

                this._curGPUPipelineState = null;
                this._curGPUInputAssembler = null;
                this._curGPUDescriptorSets.length = 0;

                for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                  this._curDynamicOffsets[i].length = 0;
                }

                this._curViewport = null;
                this._curScissor = null;
                this._curLineWidth = null;
                this._curDepthBias = null;
                this._curBlendConstants.length = 0;
                this._curDepthBounds = null;
                this._curStencilWriteMask = null;
                this._curStencilCompareMask = null;
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
              };

              _proto.end = function end() {
                if (this._isStateInvalied) {
                  this.bindStates();
                }

                this._isInRenderPass = false;
              };

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                var cmd = this._webGLAllocator.beginRenderPassCmdPool.alloc(WebGL2CmdBeginRenderPass);

                cmd.gpuRenderPass = renderPass.gpuRenderPass;
                cmd.gpuFramebuffer = framebuffer.gpuFramebuffer;
                cmd.renderArea = renderArea;

                for (var i = 0; i < clearColors.length; ++i) {
                  cmd.clearColors[i] = clearColors[i];
                }

                cmd.clearDepth = clearDepth;
                cmd.clearStencil = clearStencil;
                this.cmdPackage.beginRenderPassCmds.push(cmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BEGIN_RENDER_PASS);
                this._isInRenderPass = true;
              };

              _proto.endRenderPass = function endRenderPass() {
                this._isInRenderPass = false;
              };

              _proto.bindPipelineState = function bindPipelineState(pipelineState) {
                var gpuPipelineState = pipelineState.gpuPipelineState;

                if (gpuPipelineState !== this._curGPUPipelineState) {
                  this._curGPUPipelineState = gpuPipelineState;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindDescriptorSet = function bindDescriptorSet(set, descriptorSet, dynamicOffsets) {
                var gpuDescriptorSets = descriptorSet.gpuDescriptorSet;

                if (gpuDescriptorSets !== this._curGPUDescriptorSets[set]) {
                  this._curGPUDescriptorSets[set] = gpuDescriptorSets;
                  this._isStateInvalied = true;
                }

                if (dynamicOffsets) {
                  var offsets = this._curDynamicOffsets[set];

                  for (var i = 0; i < dynamicOffsets.length; i++) {
                    offsets[i] = dynamicOffsets[i];
                  }

                  offsets.length = dynamicOffsets.length;
                  this._isStateInvalied = true;
                }
              };

              _proto.bindInputAssembler = function bindInputAssembler(inputAssembler) {
                var gpuInputAssembler = inputAssembler.gpuInputAssembler;
                this._curGPUInputAssembler = gpuInputAssembler;
                this._isStateInvalied = true;
              };

              _proto.setViewport = function setViewport(viewport) {
                if (!this._curViewport) {
                  this._curViewport = new Viewport(viewport.left, viewport.top, viewport.width, viewport.height, viewport.minDepth, viewport.maxDepth);
                } else if (this._curViewport.left !== viewport.left || this._curViewport.top !== viewport.top || this._curViewport.width !== viewport.width || this._curViewport.height !== viewport.height || this._curViewport.minDepth !== viewport.minDepth || this._curViewport.maxDepth !== viewport.maxDepth) {
                  this._curViewport.left = viewport.left;
                  this._curViewport.top = viewport.top;
                  this._curViewport.width = viewport.width;
                  this._curViewport.height = viewport.height;
                  this._curViewport.minDepth = viewport.minDepth;
                  this._curViewport.maxDepth = viewport.maxDepth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setScissor = function setScissor(scissor) {
                if (!this._curScissor) {
                  this._curScissor = new Rect(scissor.x, scissor.y, scissor.width, scissor.height);
                } else if (this._curScissor.x !== scissor.x || this._curScissor.y !== scissor.y || this._curScissor.width !== scissor.width || this._curScissor.height !== scissor.height) {
                  this._curScissor.x = scissor.x;
                  this._curScissor.y = scissor.y;
                  this._curScissor.width = scissor.width;
                  this._curScissor.height = scissor.height;
                  this._isStateInvalied = true;
                }
              };

              _proto.setLineWidth = function setLineWidth(lineWidth) {
                if (this._curLineWidth !== lineWidth) {
                  this._curLineWidth = lineWidth;
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBias = function setDepthBias(depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor) {
                if (!this._curDepthBias) {
                  this._curDepthBias = {
                    constantFactor: depthBiasConstantFactor,
                    clamp: depthBiasClamp,
                    slopeFactor: depthBiasSlopeFactor
                  };
                  this._isStateInvalied = true;
                } else if (this._curDepthBias.constantFactor !== depthBiasConstantFactor || this._curDepthBias.clamp !== depthBiasClamp || this._curDepthBias.slopeFactor !== depthBiasSlopeFactor) {
                  this._curDepthBias.constantFactor = depthBiasConstantFactor;
                  this._curDepthBias.clamp = depthBiasClamp;
                  this._curDepthBias.slopeFactor = depthBiasSlopeFactor;
                  this._isStateInvalied = true;
                }
              };

              _proto.setBlendConstants = function setBlendConstants(blendConstants) {
                if (blendConstants.length === 4 && (this._curBlendConstants[0] !== blendConstants[0] || this._curBlendConstants[1] !== blendConstants[1] || this._curBlendConstants[2] !== blendConstants[2] || this._curBlendConstants[3] !== blendConstants[3])) {
                  this._curBlendConstants.length = 0;
                  Array.prototype.push.apply(this._curBlendConstants, blendConstants);
                  this._isStateInvalied = true;
                }
              };

              _proto.setDepthBound = function setDepthBound(minDepthBounds, maxDepthBounds) {
                if (!this._curDepthBounds) {
                  this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                  };
                  this._isStateInvalied = true;
                } else if (this._curDepthBounds.minBounds !== minDepthBounds || this._curDepthBounds.maxBounds !== maxDepthBounds) {
                  this._curDepthBounds = {
                    minBounds: minDepthBounds,
                    maxBounds: maxDepthBounds
                  };
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilWriteMask = function setStencilWriteMask(face, writeMask) {
                if (!this._curStencilWriteMask) {
                  this._curStencilWriteMask = {
                    face: face,
                    writeMask: writeMask
                  };
                  this._isStateInvalied = true;
                } else if (this._curStencilWriteMask.face !== face || this._curStencilWriteMask.writeMask !== writeMask) {
                  this._curStencilWriteMask.face = face;
                  this._curStencilWriteMask.writeMask = writeMask;
                  this._isStateInvalied = true;
                }
              };

              _proto.setStencilCompareMask = function setStencilCompareMask(face, reference, compareMask) {
                if (!this._curStencilCompareMask) {
                  this._curStencilCompareMask = {
                    face: face,
                    reference: reference,
                    compareMask: compareMask
                  };
                  this._isStateInvalied = true;
                } else if (this._curStencilCompareMask.face !== face || this._curStencilCompareMask.reference !== reference || this._curStencilCompareMask.compareMask !== compareMask) {
                  this._curStencilCompareMask.face = face;
                  this._curStencilCompareMask.reference = reference;
                  this._curStencilCompareMask.compareMask = compareMask;
                  this._isStateInvalied = true;
                }
              };

              _proto.draw = function draw(inputAssembler) {
                if (this._type === CommandBufferType.PRIMARY && this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  var cmd = this._webGLAllocator.drawCmdPool.alloc(WebGL2CmdDraw);

                  cmd.drawInfo.vertexCount = inputAssembler.vertexCount;
                  cmd.drawInfo.firstVertex = inputAssembler.firstVertex;
                  cmd.drawInfo.indexCount = inputAssembler.indexCount;
                  cmd.drawInfo.firstIndex = inputAssembler.firstIndex;
                  cmd.drawInfo.vertexOffset = inputAssembler.vertexOffset;
                  cmd.drawInfo.instanceCount = inputAssembler.instanceCount;
                  cmd.drawInfo.firstInstance = inputAssembler.firstInstance;
                  this.cmdPackage.drawCmds.push(cmd);
                  this.cmdPackage.cmds.push(WebGL2Cmd.DRAW);
                  ++this._numDrawCalls;
                  this._numInstances += inputAssembler.instanceCount;
                  var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var cmd = this._webGLAllocator.updateBufferCmdPool.alloc(WebGL2CmdUpdateBuffer);

                    var buffSize = 0;
                    var buff = null;

                    if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buff = data;
                    } else {
                      if (size !== undefined) {
                        buffSize = size;
                      } else {
                        buffSize = data.byteLength;
                      }

                      buff = data;
                    }

                    cmd.gpuBuffer = gpuBuffer;
                    cmd.buffer = buff;
                    cmd.offset = 0;
                    cmd.size = buffSize;
                    this.cmdPackage.updateBufferCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.UPDATE_BUFFER);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (this._type === CommandBufferType.PRIMARY && !this._isInRenderPass || this._type === CommandBufferType.SECONDARY) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    var cmd = this._webGLAllocator.copyBufferToTextureCmdPool.alloc(WebGL2CmdCopyBufferToTexture);

                    cmd.gpuTexture = gpuTexture;
                    cmd.regions = regions;
                    cmd.buffers = buffers;
                    this.cmdPackage.copyBufferToTextureCmds.push(cmd);
                    this.cmdPackage.cmds.push(WebGL2Cmd.COPY_BUFFER_TO_TEXTURE);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGL2CmdBuff = cmdBuffs[i];

                  for (var c = 0; c < webGL2CmdBuff.cmdPackage.beginRenderPassCmds.length; ++c) {
                    var cmd = webGL2CmdBuff.cmdPackage.beginRenderPassCmds.array[c];
                    ++cmd.refCount;
                    this.cmdPackage.beginRenderPassCmds.push(cmd);
                  }

                  for (var _c = 0; _c < webGL2CmdBuff.cmdPackage.bindStatesCmds.length; ++_c) {
                    var _cmd = webGL2CmdBuff.cmdPackage.bindStatesCmds.array[_c];
                    ++_cmd.refCount;
                    this.cmdPackage.bindStatesCmds.push(_cmd);
                  }

                  for (var _c2 = 0; _c2 < webGL2CmdBuff.cmdPackage.drawCmds.length; ++_c2) {
                    var _cmd2 = webGL2CmdBuff.cmdPackage.drawCmds.array[_c2];
                    ++_cmd2.refCount;
                    this.cmdPackage.drawCmds.push(_cmd2);
                  }

                  for (var _c3 = 0; _c3 < webGL2CmdBuff.cmdPackage.updateBufferCmds.length; ++_c3) {
                    var _cmd3 = webGL2CmdBuff.cmdPackage.updateBufferCmds.array[_c3];
                    ++_cmd3.refCount;
                    this.cmdPackage.updateBufferCmds.push(_cmd3);
                  }

                  for (var _c4 = 0; _c4 < webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.length; ++_c4) {
                    var _cmd4 = webGL2CmdBuff.cmdPackage.copyBufferToTextureCmds.array[_c4];
                    ++_cmd4.refCount;
                    this.cmdPackage.copyBufferToTextureCmds.push(_cmd4);
                  }

                  this.cmdPackage.cmds.concat(webGL2CmdBuff.cmdPackage.cmds.array);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                var bindStatesCmd = this._webGLAllocator.bindStatesCmdPool.alloc(WebGL2CmdBindStates);

                bindStatesCmd.gpuPipelineState = this._curGPUPipelineState;
                Array.prototype.push.apply(bindStatesCmd.gpuDescriptorSets, this._curGPUDescriptorSets);

                for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                  Array.prototype.push.apply(bindStatesCmd.dynamicOffsets, this._curDynamicOffsets[i]);
                }

                bindStatesCmd.gpuInputAssembler = this._curGPUInputAssembler;
                bindStatesCmd.viewport = this._curViewport;
                bindStatesCmd.scissor = this._curScissor;
                bindStatesCmd.lineWidth = this._curLineWidth;
                bindStatesCmd.depthBias = this._curDepthBias;
                Array.prototype.push.apply(bindStatesCmd.blendConstants, this._curBlendConstants);
                bindStatesCmd.depthBounds = this._curDepthBounds;
                bindStatesCmd.stencilWriteMask = this._curStencilWriteMask;
                bindStatesCmd.stencilCompareMask = this._curStencilCompareMask;
                this.cmdPackage.bindStatesCmds.push(bindStatesCmd);
                this.cmdPackage.cmds.push(WebGL2Cmd.BIND_STATES);
                this._isStateInvalied = false;
              };

              _createClass(WebGL2CommandBuffer, [{
                key: "webGLDevice",
                get: function get() {
                  return this._device;
                }
              }]);

              return WebGL2CommandBuffer;
            }(CommandBuffer);

            var WebGL2Fence = function (_Fence) {
              _inheritsLoose(WebGL2Fence, _Fence);

              function WebGL2Fence() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Fence.call.apply(_Fence, [this].concat(args)) || this;
                _this._sync = null;
                return _this;
              }

              var _proto = WebGL2Fence.prototype;

              _proto.initialize = function initialize(info) {
                return true;
              };

              _proto.destroy = function destroy() {};

              _proto.wait = function wait() {
                if (this._sync) {
                  var gl = this._device.gl;
                  gl.clientWaitSync(this._sync, 0, gl.TIMEOUT_IGNORED);
                }
              };

              _proto.reset = function reset() {
                if (this._sync) {
                  var gl = this._device.gl;
                  gl.deleteSync(this._sync);
                  this._sync = null;
                }
              };

              _proto.insert = function insert() {
                var gl = this._device.gl;

                if (this._sync) {
                  gl.deleteSync(this._sync);
                }

                this._sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
              };

              return WebGL2Fence;
            }(Fence);

            var WebGL2Framebuffer = function (_Framebuffer) {
              _inheritsLoose(WebGL2Framebuffer, _Framebuffer);

              function WebGL2Framebuffer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Framebuffer.call.apply(_Framebuffer, [this].concat(args)) || this;
                _this._gpuFramebuffer = null;
                return _this;
              }

              var _proto = WebGL2Framebuffer.prototype;

              _proto.initialize = function initialize(info) {
                this._renderPass = info.renderPass;
                this._colorTextures = info.colorTextures || [];
                this._depthStencilTexture = info.depthStencilTexture || null;

                if (info.depStencilMipmapLevel !== 0) {
                  console.warn('The mipmap level of th texture image to be attached of depth stencil attachment should be 0. Convert to 0.');
                }

                for (var i = 0; i < info.colorMipmapLevels.length; ++i) {
                  if (info.colorMipmapLevels[i] !== 0) {
                    console.warn("The mipmap level of th texture image to be attached of color attachment " + i + " should be 0. Convert to 0.");
                  }
                }

                var gpuColorTextures = [];

                for (var _i = 0; _i < info.colorTextures.length; _i++) {
                  var colorTexture = info.colorTextures[_i];

                  if (colorTexture) {
                    gpuColorTextures.push(colorTexture.gpuTexture);
                  }
                }

                var gpuDepthStencilTexture = null;

                if (info.depthStencilTexture) {
                  gpuDepthStencilTexture = info.depthStencilTexture.gpuTexture;
                }

                this._gpuFramebuffer = {
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  gpuColorTextures: gpuColorTextures,
                  gpuDepthStencilTexture: gpuDepthStencilTexture,
                  glFramebuffer: null
                };
                WebGL2CmdFuncCreateFramebuffer(this._device, this._gpuFramebuffer);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuFramebuffer) {
                  WebGL2CmdFuncDestroyFramebuffer(this._device, this._gpuFramebuffer);
                  this._gpuFramebuffer = null;
                }
              };

              _createClass(WebGL2Framebuffer, [{
                key: "gpuFramebuffer",
                get: function get() {
                  return this._gpuFramebuffer;
                }
              }]);

              return WebGL2Framebuffer;
            }(Framebuffer);

            var WebGL2InputAssembler = function (_InputAssembler) {
              _inheritsLoose(WebGL2InputAssembler, _InputAssembler);

              function WebGL2InputAssembler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _InputAssembler.call.apply(_InputAssembler, [this].concat(args)) || this;
                _this._gpuInputAssembler = null;
                return _this;
              }

              var _proto = WebGL2InputAssembler.prototype;

              _proto.initialize = function initialize(info) {
                if (info.vertexBuffers.length === 0) {
                  console.error('InputAssemblerInfo.vertexBuffers is null.');
                  return false;
                }

                this._attributes = info.attributes;
                this._attributesHash = this.computeAttributesHash();
                this._vertexBuffers = info.vertexBuffers;

                if (info.indexBuffer) {
                  this._indexBuffer = info.indexBuffer;
                  this._indexCount = this._indexBuffer.size / this._indexBuffer.stride;
                  this._firstIndex = 0;
                } else {
                  var vertBuff = this._vertexBuffers[0];
                  this._vertexCount = vertBuff.size / vertBuff.stride;
                  this._firstVertex = 0;
                  this._vertexOffset = 0;
                }

                this._instanceCount = 0;
                this._firstInstance = 0;
                this._indirectBuffer = info.indirectBuffer || null;
                var gpuVertexBuffers = new Array(info.vertexBuffers.length);

                for (var i = 0; i < info.vertexBuffers.length; ++i) {
                  var vb = info.vertexBuffers[i];

                  if (vb.gpuBuffer) {
                    gpuVertexBuffers[i] = vb.gpuBuffer;
                  }
                }

                var gpuIndexBuffer = null;
                var glIndexType = 0;

                if (info.indexBuffer) {
                  gpuIndexBuffer = info.indexBuffer.gpuBuffer;

                  if (gpuIndexBuffer) {
                    switch (gpuIndexBuffer.stride) {
                      case 1:
                        glIndexType = 0x1401;
                        break;

                      case 2:
                        glIndexType = 0x1403;
                        break;

                      case 4:
                        glIndexType = 0x1405;
                        break;

                      default:
                        {
                          console.error('Illegal index buffer stride.');
                        }
                    }
                  }
                }

                var gpuIndirectBuffer = null;

                if (info.indirectBuffer) {
                  gpuIndirectBuffer = info.indirectBuffer.gpuBuffer;
                }

                this._gpuInputAssembler = {
                  attributes: info.attributes,
                  gpuVertexBuffers: gpuVertexBuffers,
                  gpuIndexBuffer: gpuIndexBuffer,
                  gpuIndirectBuffer: gpuIndirectBuffer,
                  glAttribs: [],
                  glIndexType: glIndexType,
                  glVAOs: new Map()
                };
                WebGL2CmdFuncCreateInputAssember(this._device, this._gpuInputAssembler);
                return true;
              };

              _proto.destroy = function destroy() {
                var webgl2Dev = this._device;

                if (this._gpuInputAssembler && webgl2Dev.useVAO) {
                  WebGL2CmdFuncDestroyInputAssembler(webgl2Dev, this._gpuInputAssembler);
                }

                this._gpuInputAssembler = null;
              };

              _createClass(WebGL2InputAssembler, [{
                key: "gpuInputAssembler",
                get: function get() {
                  return this._gpuInputAssembler;
                }
              }]);

              return WebGL2InputAssembler;
            }(InputAssembler);

            var WebGL2DescriptorSetLayout = function (_DescriptorSetLayout) {
              _inheritsLoose(WebGL2DescriptorSetLayout, _DescriptorSetLayout);

              function WebGL2DescriptorSetLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _DescriptorSetLayout.call.apply(_DescriptorSetLayout, [this].concat(args)) || this;
                _this._gpuDescriptorSetLayout = null;
                return _this;
              }

              var _proto = WebGL2DescriptorSetLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._bindings, info.bindings);
                var descriptorCount = 0;
                var maxBinding = -1;
                var flattenedIndices = [];

                for (var i = 0; i < this._bindings.length; i++) {
                  var binding = this._bindings[i];
                  flattenedIndices.push(descriptorCount);
                  descriptorCount += binding.count;
                  if (binding.binding > maxBinding) maxBinding = binding.binding;
                }

                this._bindingIndices = Array(maxBinding + 1).fill(-1);
                var descriptorIndices = this._descriptorIndices = Array(maxBinding + 1).fill(-1);

                for (var _i = 0; _i < this._bindings.length; _i++) {
                  var _binding = this._bindings[_i];
                  this._bindingIndices[_binding.binding] = _i;
                  descriptorIndices[_binding.binding] = flattenedIndices[_i];
                }

                var dynamicBindings = [];

                for (var _i2 = 0; _i2 < this._bindings.length; _i2++) {
                  var _binding2 = this._bindings[_i2];

                  if (_binding2.descriptorType & DESCRIPTOR_DYNAMIC_TYPE) {
                    for (var j = 0; j < _binding2.count; j++) {
                      dynamicBindings.push(_binding2.binding);
                    }
                  }
                }

                this._gpuDescriptorSetLayout = {
                  bindings: this._bindings,
                  dynamicBindings: dynamicBindings,
                  descriptorIndices: descriptorIndices,
                  descriptorCount: descriptorCount
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._bindings.length = 0;
              };

              _createClass(WebGL2DescriptorSetLayout, [{
                key: "gpuDescriptorSetLayout",
                get: function get() {
                  return this._gpuDescriptorSetLayout;
                }
              }]);

              return WebGL2DescriptorSetLayout;
            }(DescriptorSetLayout);

            var WebGL2PipelineLayout = function (_PipelineLayout) {
              _inheritsLoose(WebGL2PipelineLayout, _PipelineLayout);

              function WebGL2PipelineLayout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineLayout.call.apply(_PipelineLayout, [this].concat(args)) || this;
                _this._gpuPipelineLayout = null;
                return _this;
              }

              var _proto = WebGL2PipelineLayout.prototype;

              _proto.initialize = function initialize(info) {
                Array.prototype.push.apply(this._setLayouts, info.setLayouts);
                var dynamicOffsetIndices = [];
                var gpuSetLayouts = [];
                var dynamicOffsetCount = 0;

                for (var i = 0; i < this._setLayouts.length; i++) {
                  var setLayout = this._setLayouts[i];
                  var dynamicBindings = setLayout.gpuDescriptorSetLayout.dynamicBindings;
                  var indices = Array(setLayout.bindingIndices.length).fill(-1);

                  for (var j = 0; j < dynamicBindings.length; j++) {
                    var binding = dynamicBindings[j];
                    if (indices[binding] < 0) indices[binding] = dynamicOffsetCount + j;
                  }

                  gpuSetLayouts.push(setLayout.gpuDescriptorSetLayout);
                  dynamicOffsetIndices.push(indices);
                  dynamicOffsetCount += dynamicBindings.length;
                }

                this._gpuPipelineLayout = {
                  gpuSetLayouts: gpuSetLayouts,
                  dynamicOffsetIndices: dynamicOffsetIndices,
                  dynamicOffsetCount: dynamicOffsetCount
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._setLayouts.length = 0;
              };

              _createClass(WebGL2PipelineLayout, [{
                key: "gpuPipelineLayout",
                get: function get() {
                  return this._gpuPipelineLayout;
                }
              }]);

              return WebGL2PipelineLayout;
            }(PipelineLayout);

            var WebGLPrimitives$1 = [0x0000, 0x0001, 0x0003, 0x0002, 0x0000, 0x0000, 0x0000, 0x0004, 0x0005, 0x0006, 0x0000, 0x0000, 0x0000, 0x0000];
            var WebGL2PipelineState = function (_PipelineState) {
              _inheritsLoose(WebGL2PipelineState, _PipelineState);

              function WebGL2PipelineState() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _PipelineState.call.apply(_PipelineState, [this].concat(args)) || this;
                _this._gpuPipelineState = null;
                return _this;
              }

              var _proto = WebGL2PipelineState.prototype;

              _proto.initialize = function initialize(info) {
                this._primitive = info.primitive;
                this._shader = info.shader;
                this._pipelineLayout = info.pipelineLayout;
                var bs = this._bs;

                if (info.blendState) {
                  var bsInfo = info.blendState;
                  var targets = bsInfo.targets;

                  if (targets) {
                    targets.forEach(function (t, i) {
                      bs.setTarget(i, t);
                    });
                  }

                  if (bsInfo.isA2C !== undefined) {
                    bs.isA2C = bsInfo.isA2C;
                  }

                  if (bsInfo.isIndepend !== undefined) {
                    bs.isIndepend = bsInfo.isIndepend;
                  }

                  if (bsInfo.blendColor !== undefined) {
                    bs.blendColor = bsInfo.blendColor;
                  }
                }

                Object.assign(this._rs, info.rasterizerState);
                Object.assign(this._dss, info.depthStencilState);
                this._is = info.inputState;
                this._renderPass = info.renderPass;
                this._dynamicStates = info.dynamicStates;
                var dynamicStates = [];

                for (var i = 0; i < 31; i++) {
                  if (this._dynamicStates & 1 << i) {
                    dynamicStates.push(1 << i);
                  }
                }

                this._gpuPipelineState = {
                  glPrimitive: WebGLPrimitives$1[info.primitive],
                  gpuShader: info.shader.gpuShader,
                  gpuPipelineLayout: info.pipelineLayout.gpuPipelineLayout,
                  rs: info.rasterizerState,
                  dss: info.depthStencilState,
                  bs: info.blendState,
                  gpuRenderPass: info.renderPass.gpuRenderPass,
                  dynamicStates: dynamicStates
                };
                return true;
              };

              _proto.destroy = function destroy() {
                this._gpuPipelineState = null;
              };

              _createClass(WebGL2PipelineState, [{
                key: "gpuPipelineState",
                get: function get() {
                  return this._gpuPipelineState;
                }
              }]);

              return WebGL2PipelineState;
            }(PipelineState);

            var _dynamicOffsets$1 = [];
            var WebGL2PrimaryCommandBuffer = function (_WebGL2CommandBuffer) {
              _inheritsLoose(WebGL2PrimaryCommandBuffer, _WebGL2CommandBuffer);

              function WebGL2PrimaryCommandBuffer() {
                return _WebGL2CommandBuffer.apply(this, arguments) || this;
              }

              var _proto = WebGL2PrimaryCommandBuffer.prototype;

              _proto.beginRenderPass = function beginRenderPass(renderPass, framebuffer, renderArea, clearColors, clearDepth, clearStencil) {
                WebGL2CmdFuncBeginRenderPass(this._device, renderPass.gpuRenderPass, framebuffer.gpuFramebuffer, renderArea, clearColors, clearDepth, clearStencil);
                this._isInRenderPass = true;
              };

              _proto.draw = function draw(inputAssembler) {
                if (this._isInRenderPass) {
                  if (this._isStateInvalied) {
                    this.bindStates();
                  }

                  WebGL2CmdFuncDraw(this._device, inputAssembler);
                  ++this._numDrawCalls;
                  this._numInstances += inputAssembler.instanceCount;
                  var indexCount = inputAssembler.indexCount || inputAssembler.vertexCount;

                  if (this._curGPUPipelineState) {
                    var glPrimitive = this._curGPUPipelineState.glPrimitive;

                    switch (glPrimitive) {
                      case 0x0004:
                        {
                          this._numTris += indexCount / 3 * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }

                      case 0x0005:
                      case 0x0006:
                        {
                          this._numTris += (indexCount - 2) * Math.max(inputAssembler.instanceCount, 1);
                          break;
                        }
                    }
                  }
                } else {
                  console.error('Command \'draw\' must be recorded inside a render pass.');
                }
              };

              _proto.updateBuffer = function updateBuffer(buffer, data, size) {
                if (!this._isInRenderPass) {
                  var gpuBuffer = buffer.gpuBuffer;

                  if (gpuBuffer) {
                    var buffSize;

                    if (size !== undefined) {
                      buffSize = size;
                    } else if (buffer.usage & BufferUsageBit.INDIRECT) {
                      buffSize = 0;
                    } else {
                      buffSize = data.byteLength;
                    }

                    WebGL2CmdFuncUpdateBuffer(this._device, gpuBuffer, data, 0, buffSize);
                  }
                } else {
                  console.error('Command \'updateBuffer\' must be recorded outside a render pass.');
                }
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                if (!this._isInRenderPass) {
                  var gpuTexture = texture.gpuTexture;

                  if (gpuTexture) {
                    WebGL2CmdFuncCopyBuffersToTexture(this._device, buffers, gpuTexture, regions);
                  }
                } else {
                  console.error('Command \'copyBufferToTexture\' must be recorded outside a render pass.');
                }
              };

              _proto.execute = function execute(cmdBuffs, count) {
                for (var i = 0; i < count; ++i) {
                  var webGL2CmdBuff = cmdBuffs[i];
                  WebGL2CmdFuncExecuteCmds(this._device, webGL2CmdBuff.cmdPackage);
                  this._numDrawCalls += webGL2CmdBuff._numDrawCalls;
                  this._numInstances += webGL2CmdBuff._numInstances;
                  this._numTris += webGL2CmdBuff._numTris;
                }
              };

              _proto.bindStates = function bindStates() {
                _dynamicOffsets$1.length = 0;

                for (var i = 0; i < this._curDynamicOffsets.length; i++) {
                  Array.prototype.push.apply(_dynamicOffsets$1, this._curDynamicOffsets[i]);
                }

                WebGL2CmdFuncBindStates(this._device, this._curGPUPipelineState, this._curGPUInputAssembler, this._curGPUDescriptorSets, _dynamicOffsets$1, this._curViewport, this._curScissor, this._curLineWidth, this._curDepthBias, this._curBlendConstants, this._curDepthBounds, this._curStencilWriteMask, this._curStencilCompareMask);
                this._isStateInvalied = false;
              };

              return WebGL2PrimaryCommandBuffer;
            }(WebGL2CommandBuffer);

            var WebGL2Queue = function (_Queue) {
              _inheritsLoose(WebGL2Queue, _Queue);

              function WebGL2Queue() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Queue.call.apply(_Queue, [this].concat(args)) || this;
                _this.numDrawCalls = 0;
                _this.numInstances = 0;
                _this.numTris = 0;
                return _this;
              }

              var _proto = WebGL2Queue.prototype;

              _proto.initialize = function initialize(info) {
                this._type = info.type;
                return true;
              };

              _proto.destroy = function destroy() {};

              _proto.submit = function submit(cmdBuffs, fence) {
                if (!this._isAsync) {
                  for (var i = 0; i < cmdBuffs.length; i++) {
                    var cmdBuff = cmdBuffs[i];
                    this.numDrawCalls += cmdBuff.numDrawCalls;
                    this.numInstances += cmdBuff.numInstances;
                    this.numTris += cmdBuff.numTris;
                  }
                }

                if (fence) {
                  fence.insert();
                }
              };

              _proto.clear = function clear() {
                this.numDrawCalls = 0;
                this.numInstances = 0;
                this.numTris = 0;
              };

              return WebGL2Queue;
            }(Queue);

            var WebGL2RenderPass = function (_RenderPass) {
              _inheritsLoose(WebGL2RenderPass, _RenderPass);

              function WebGL2RenderPass() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _RenderPass.call.apply(_RenderPass, [this].concat(args)) || this;
                _this._gpuRenderPass = null;
                return _this;
              }

              var _proto = WebGL2RenderPass.prototype;

              _proto.initialize = function initialize(info) {
                this._colorInfos = info.colorAttachments;
                this._depthStencilInfo = info.depthStencilAttachment;

                if (info.subPasses) {
                  this._subPasses = info.subPasses;
                }

                this._gpuRenderPass = {
                  colorAttachments: this._colorInfos,
                  depthStencilAttachment: this._depthStencilInfo
                };
                this._hash = this.computeHash();
                return true;
              };

              _proto.destroy = function destroy() {
                this._gpuRenderPass = null;
              };

              _createClass(WebGL2RenderPass, [{
                key: "gpuRenderPass",
                get: function get() {
                  return this._gpuRenderPass;
                }
              }]);

              return WebGL2RenderPass;
            }(RenderPass);

            var WebGL2Sampler = function (_Sampler) {
              _inheritsLoose(WebGL2Sampler, _Sampler);

              function WebGL2Sampler() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Sampler.call.apply(_Sampler, [this].concat(args)) || this;
                _this._gpuSampler = null;
                return _this;
              }

              var _proto = WebGL2Sampler.prototype;

              _proto.initialize = function initialize(info) {
                this._minFilter = info.minFilter;
                this._magFilter = info.magFilter;
                this._mipFilter = info.mipFilter;
                this._addressU = info.addressU;
                this._addressV = info.addressV;
                this._addressW = info.addressW;
                this._maxAnisotropy = info.maxAnisotropy;
                this._cmpFunc = info.cmpFunc;
                this._borderColor = info.borderColor;
                this._minLOD = info.minLOD;
                this._maxLOD = info.maxLOD;
                this._mipLODBias = info.mipLODBias;
                this._gpuSampler = {
                  glSampler: null,
                  minFilter: this._minFilter,
                  magFilter: this._magFilter,
                  mipFilter: this._mipFilter,
                  addressU: this._addressU,
                  addressV: this._addressV,
                  addressW: this._addressW,
                  minLOD: this._minLOD,
                  maxLOD: this._maxLOD,
                  glMinFilter: 0,
                  glMagFilter: 0,
                  glWrapS: 0,
                  glWrapT: 0,
                  glWrapR: 0
                };
                WebGL2CmdFuncCreateSampler(this._device, this._gpuSampler);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuSampler) {
                  WebGL2CmdFuncDestroySampler(this._device, this._gpuSampler);
                  this._gpuSampler = null;
                }
              };

              _createClass(WebGL2Sampler, [{
                key: "gpuSampler",
                get: function get() {
                  return this._gpuSampler;
                }
              }]);

              return WebGL2Sampler;
            }(Sampler);

            var WebGL2Shader = function (_Shader) {
              _inheritsLoose(WebGL2Shader, _Shader);

              function WebGL2Shader() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Shader.call.apply(_Shader, [this].concat(args)) || this;
                _this._gpuShader = null;
                return _this;
              }

              var _proto = WebGL2Shader.prototype;

              _proto.initialize = function initialize(info) {
                this._name = info.name;
                this._stages = info.stages;
                this._attributes = info.attributes;
                this._blocks = info.blocks;
                this._samplers = info.samplers;
                this._gpuShader = {
                  name: info.name,
                  blocks: info.blocks,
                  samplers: info.samplers,
                  gpuStages: new Array(info.stages.length),
                  glProgram: null,
                  glInputs: [],
                  glUniforms: [],
                  glBlocks: [],
                  glSamplers: []
                };

                for (var i = 0; i < info.stages.length; ++i) {
                  var stage = info.stages[i];
                  this._gpuShader.gpuStages[i] = {
                    type: stage.stage,
                    source: stage.source,
                    glShader: null
                  };
                }

                WebGL2CmdFuncCreateShader(this._device, this._gpuShader);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuShader) {
                  WebGL2CmdFuncDestroyShader(this._device, this._gpuShader);
                  this._gpuShader = null;
                }
              };

              _createClass(WebGL2Shader, [{
                key: "gpuShader",
                get: function get() {
                  return this._gpuShader;
                }
              }]);

              return WebGL2Shader;
            }(Shader);

            var WebGL2StateCache = function () {
              function WebGL2StateCache() {
                this.glArrayBuffer = null;
                this.glElementArrayBuffer = null;
                this.glUniformBuffer = null;
                this.glBindUBOs = [];
                this.glBindUBOOffsets = [];
                this.glVAO = null;
                this.texUnit = 0;
                this.glTexUnits = [];
                this.glSamplerUnits = [];
                this.glRenderbuffer = null;
                this.glFramebuffer = null;
                this.glReadFramebuffer = null;
                this.viewport = new Viewport();
                this.scissorRect = new Rect(0, 0, 0, 0);
                this.rs = new RasterizerState();
                this.dss = new DepthStencilState();
                this.bs = new BlendState();
                this.glProgram = null;
                this.glEnabledAttribLocs = [];
                this.glCurrentAttribLocs = [];
                this.texUnitCacheMap = {};
              }

              var _proto = WebGL2StateCache.prototype;

              _proto.initialize = function initialize(texUnit, bufferBindings, vertexAttributes) {
                for (var i = 0; i < texUnit; ++i) {
                  this.glTexUnits.push({
                    glTexture: null
                  });
                }

                this.glSamplerUnits.length = texUnit;
                this.glSamplerUnits.fill(null);
                this.glBindUBOs.length = bufferBindings;
                this.glBindUBOs.fill(null);
                this.glBindUBOOffsets.length = bufferBindings;
                this.glBindUBOOffsets.fill(0);
                this.glEnabledAttribLocs.length = vertexAttributes;
                this.glEnabledAttribLocs.fill(false);
                this.glCurrentAttribLocs.length = vertexAttributes;
                this.glCurrentAttribLocs.fill(false);
              };

              return WebGL2StateCache;
            }();

            var WebGL2Texture = function (_Texture) {
              _inheritsLoose(WebGL2Texture, _Texture);

              function WebGL2Texture() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Texture.call.apply(_Texture, [this].concat(args)) || this;
                _this._gpuTexture = null;
                return _this;
              }

              var _proto = WebGL2Texture.prototype;

              _proto.initialize = function initialize(info) {
                if ('texture' in info) {
                  console.log('WebGL2 does not support texture view.');
                  return false;
                }

                this._type = info.type;
                this._usage = info.usage;
                this._format = info.format;
                this._width = info.width;
                this._height = info.height;
                this._depth = info.depth;
                this._layerCount = info.layerCount;
                this._levelCount = info.levelCount;
                this._samples = info.samples;
                this._flags = info.flags;
                this._isPowerOf2 = IsPowerOf2(this._width) && IsPowerOf2(this._height);
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._flags & TextureFlagBit.BAKUP_BUFFER) {
                  this._buffer = new ArrayBuffer(this._size);
                }

                this._gpuTexture = {
                  type: this._type,
                  format: this._format,
                  usage: this._usage,
                  width: this._width,
                  height: this._height,
                  depth: this._depth,
                  size: this._size,
                  arrayLayer: this._layerCount,
                  mipLevel: this._levelCount,
                  samples: this._samples,
                  flags: this._flags,
                  isPowerOf2: this._isPowerOf2,
                  glTarget: 0,
                  glInternalFmt: 0,
                  glFormat: 0,
                  glType: 0,
                  glUsage: 0,
                  glTexture: null,
                  glRenderbuffer: null,
                  glWrapS: 0,
                  glWrapT: 0,
                  glMinFilter: 0,
                  glMagFilter: 0
                };
                WebGL2CmdFuncCreateTexture(this._device, this._gpuTexture);
                this._device.memoryStatus.textureSize += this._size;
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._gpuTexture) {
                  WebGL2CmdFuncDestroyTexture(this._device, this._gpuTexture);
                  this._device.memoryStatus.textureSize -= this._size;
                  this._gpuTexture = null;
                }

                this._buffer = null;
              };

              _proto.resize = function resize(width, height) {
                var oldSize = this._size;
                this._width = width;
                this._height = height;
                this._size = FormatSurfaceSize(this._format, this.width, this.height, this.depth, this._levelCount) * this._layerCount;

                if (this._gpuTexture) {
                  this._gpuTexture.width = width;
                  this._gpuTexture.height = height;
                  this._gpuTexture.size = this._size;
                  WebGL2CmdFuncResizeTexture(this._device, this._gpuTexture);
                  this._device.memoryStatus.textureSize -= oldSize;
                  this._device.memoryStatus.textureSize += this._size;
                }
              };

              _createClass(WebGL2Texture, [{
                key: "gpuTexture",
                get: function get() {
                  return this._gpuTexture;
                }
              }]);

              return WebGL2Texture;
            }(Texture);

            var eventWebGLContextLost$1 = 'webglcontextlost';
            var WebGL2Device = exports('WebGL2Device', function (_Device) {
              _inheritsLoose(WebGL2Device, _Device);

              function WebGL2Device() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Device.call.apply(_Device, [this].concat(args)) || this;
                _this.stateCache = new WebGL2StateCache();
                _this.cmdAllocator = new WebGL2CommandAllocator();
                _this.nullTex2D = null;
                _this.nullTexCube = null;
                _this._webGL2RC = null;
                _this._isAntialias = true;
                _this._isPremultipliedAlpha = true;
                _this._useVAO = true;
                _this._bindingMappingInfo = new BindingMappingInfo();
                _this._webGLContextLostHandler = null;
                _this._extensions = null;
                _this._EXT_texture_filter_anisotropic = null;
                _this._OES_texture_float_linear = null;
                _this._OES_texture_half_float_linear = null;
                _this._EXT_color_buffer_float = null;
                _this._EXT_disjoint_timer_query_webgl2 = null;
                _this._WEBGL_compressed_texture_etc1 = null;
                _this._WEBGL_compressed_texture_etc = null;
                _this._WEBGL_compressed_texture_pvrtc = null;
                _this._WEBGL_compressed_texture_astc = null;
                _this._WEBGL_compressed_texture_s3tc = null;
                _this._WEBGL_compressed_texture_s3tc_srgb = null;
                _this._WEBGL_debug_renderer_info = null;
                _this._WEBGL_texture_storage_multisample = null;
                _this._WEBGL_debug_shaders = null;
                _this._WEBGL_lose_context = null;
                return _this;
              }

              var _proto = WebGL2Device.prototype;

              _proto.initialize = function initialize(info) {
                this._canvas = info.canvasElm;
                this._isAntialias = info.isAntialias;
                this._isPremultipliedAlpha = info.isPremultipliedAlpha;
                this._bindingMappingInfo = info.bindingMappingInfo;
                if (!this._bindingMappingInfo.bufferOffsets.length) this._bindingMappingInfo.bufferOffsets.push(0);
                if (!this._bindingMappingInfo.samplerOffsets.length) this._bindingMappingInfo.samplerOffsets.push(0);

                try {
                  var webGLCtxAttribs = {
                    alpha: macro.ENABLE_TRANSPARENT_CANVAS,
                    antialias: this._isAntialias,
                    depth: true,
                    stencil: true,
                    premultipliedAlpha: this._isPremultipliedAlpha,
                    preserveDrawingBuffer: false,
                    powerPreference: 'default',
                    failIfMajorPerformanceCaveat: false
                  };
                  this._webGL2RC = this._canvas.getContext('webgl2', webGLCtxAttribs);
                } catch (err) {
                  console.warn(err);
                  return false;
                }

                if (!this._webGL2RC) {
                  console.warn('This device does not support WebGL2.');
                  return false;
                }

                this._webGLContextLostHandler = this._onWebGLContextLost.bind(this);

                this._canvas.addEventListener(eventWebGLContextLost$1, this._onWebGLContextLost);

                this._canvas2D = document.createElement('canvas');
                console.info('WebGL2 device initialized.');
                this._gfxAPI = API.WEBGL2;
                this._deviceName = 'WebGL2';
                var gl = this._webGL2RC;
                this._WEBGL_debug_renderer_info = this.getExtension('WEBGL_debug_renderer_info');

                if (this._WEBGL_debug_renderer_info) {
                  this._renderer = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_RENDERER_WEBGL);
                  this._vendor = gl.getParameter(this._WEBGL_debug_renderer_info.UNMASKED_VENDOR_WEBGL);
                } else {
                  this._renderer = gl.getParameter(gl.RENDERER);
                  this._vendor = gl.getParameter(gl.VENDOR);
                }

                this._version = gl.getParameter(gl.VERSION);
                this._maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
                this._maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
                this._maxFragmentUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
                this._maxTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
                this._maxVertexTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
                this._maxUniformBufferBindings = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
                this._maxUniformBlockSize = gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE);
                this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                this._maxCubeMapTextureSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
                this._uboOffsetAlignment = gl.getParameter(gl.UNIFORM_BUFFER_OFFSET_ALIGNMENT);
                this._depthBits = gl.getParameter(gl.DEPTH_BITS);
                this._stencilBits = gl.getParameter(gl.STENCIL_BITS);
                this.stateCache.initialize(this._maxTextureUnits, this._maxUniformBufferBindings, this._maxVertexAttributes);
                this._devicePixelRatio = info.devicePixelRatio || 1.0;
                this._width = this._canvas.width;
                this._height = this._canvas.height;
                this._nativeWidth = Math.max(info.nativeWidth || this._width, 0);
                this._nativeHeight = Math.max(info.nativeHeight || this._height, 0);
                this._colorFmt = Format.RGBA8;

                if (this._depthBits === 32) {
                  if (this._stencilBits === 8) {
                    this._depthStencilFmt = Format.D32F_S8;
                  } else {
                    this._depthStencilFmt = Format.D32F;
                  }
                } else if (this._depthBits === 24) {
                  if (this._stencilBits === 8) {
                    this._depthStencilFmt = Format.D24S8;
                  } else {
                    this._depthStencilFmt = Format.D24;
                  }
                } else if (this._stencilBits === 8) {
                  this._depthStencilFmt = Format.D16S8;
                } else {
                  this._depthStencilFmt = Format.D16;
                }

                this._extensions = gl.getSupportedExtensions();
                var extensions = '';

                if (this._extensions) {
                  for (var _iterator = _createForOfIteratorHelperLoose(this._extensions), _step; !(_step = _iterator()).done;) {
                    var ext = _step.value;
                    extensions += ext + " ";
                  }

                  console.debug("EXTENSIONS: " + extensions);
                }

                this._EXT_texture_filter_anisotropic = this.getExtension('EXT_texture_filter_anisotropic');
                this._EXT_color_buffer_float = this.getExtension('EXT_color_buffer_float');
                this._EXT_disjoint_timer_query_webgl2 = this.getExtension('EXT_disjoint_timer_query_webgl2');
                this._OES_texture_float_linear = this.getExtension('OES_texture_float_linear');
                this._OES_texture_half_float_linear = this.getExtension('OES_texture_half_float_linear');
                this._WEBGL_compressed_texture_etc1 = this.getExtension('WEBGL_compressed_texture_etc1');
                this._WEBGL_compressed_texture_etc = this.getExtension('WEBGL_compressed_texture_etc');
                this._WEBGL_compressed_texture_pvrtc = this.getExtension('WEBGL_compressed_texture_pvrtc');
                this._WEBGL_compressed_texture_astc = this.getExtension('WEBGL_compressed_texture_astc');
                this._WEBGL_compressed_texture_s3tc = this.getExtension('WEBGL_compressed_texture_s3tc');
                this._WEBGL_compressed_texture_s3tc_srgb = this.getExtension('WEBGL_compressed_texture_s3tc_srgb');
                this._WEBGL_texture_storage_multisample = this.getExtension('WEBGL_texture_storage_multisample');
                this._WEBGL_debug_shaders = this.getExtension('WEBGL_debug_shaders');
                this._WEBGL_lose_context = this.getExtension('WEBGL_lose_context');

                this._features.fill(false);

                this._features[Feature.TEXTURE_FLOAT] = true;
                this._features[Feature.TEXTURE_HALF_FLOAT] = true;
                this._features[Feature.FORMAT_R11G11B10F] = true;
                this._features[Feature.FORMAT_RGB8] = true;
                this._features[Feature.FORMAT_D16] = true;
                this._features[Feature.FORMAT_D24] = true;
                this._features[Feature.FORMAT_D32F] = true;
                this._features[Feature.FORMAT_D24S8] = true;
                this._features[Feature.FORMAT_D32FS8] = true;
                this._features[Feature.MSAA] = true;
                this._features[Feature.ELEMENT_INDEX_UINT] = true;
                this._features[Feature.INSTANCED_ARRAYS] = true;
                this._features[Feature.MULTIPLE_RENDER_TARGETS] = true;
                this._features[Feature.BLEND_MINMAX] = true;

                if (this._EXT_color_buffer_float) {
                  this._features[Feature.COLOR_FLOAT] = true;
                  this._features[Feature.COLOR_HALF_FLOAT] = true;
                }

                if (this._OES_texture_float_linear) {
                  this._features[Feature.TEXTURE_FLOAT_LINEAR] = true;
                }

                if (this._OES_texture_half_float_linear) {
                  this._features[Feature.TEXTURE_HALF_FLOAT_LINEAR] = true;
                }

                var compressedFormat = '';

                if (this._WEBGL_compressed_texture_etc1) {
                  this._features[Feature.FORMAT_ETC1] = true;
                  compressedFormat += 'etc1 ';
                }

                if (this._WEBGL_compressed_texture_etc) {
                  this._features[Feature.FORMAT_ETC2] = true;
                  compressedFormat += 'etc2 ';
                }

                if (this._WEBGL_compressed_texture_s3tc) {
                  this._features[Feature.FORMAT_DXT] = true;
                  compressedFormat += 'dxt ';
                }

                if (this._WEBGL_compressed_texture_pvrtc) {
                  this._features[Feature.FORMAT_PVRTC] = true;
                  compressedFormat += 'pvrtc ';
                }

                if (this._WEBGL_compressed_texture_astc) {
                  this._features[Feature.FORMAT_ASTC] = true;
                  compressedFormat += 'astc ';
                }

                console.info("RENDERER: " + this._renderer);
                console.info("VENDOR: " + this._vendor);
                console.info("VERSION: " + this._version);
                console.info("DPR: " + this._devicePixelRatio);
                console.info("SCREEN_SIZE: " + this._width + " x " + this._height);
                console.info("NATIVE_SIZE: " + this._nativeWidth + " x " + this._nativeHeight);
                console.info("MAX_VERTEX_ATTRIBS: " + this._maxVertexAttributes);
                console.info("MAX_VERTEX_UNIFORM_VECTORS: " + this._maxVertexUniformVectors);
                console.info("MAX_FRAGMENT_UNIFORM_VECTORS: " + this._maxFragmentUniformVectors);
                console.info("MAX_TEXTURE_IMAGE_UNITS: " + this._maxTextureUnits);
                console.info("MAX_VERTEX_TEXTURE_IMAGE_UNITS: " + this._maxVertexTextureUnits);
                console.info("MAX_UNIFORM_BUFFER_BINDINGS: " + this._maxUniformBufferBindings);
                console.info("MAX_UNIFORM_BLOCK_SIZE: " + this._maxUniformBlockSize);
                console.info("DEPTH_BITS: " + this._depthBits);
                console.info("STENCIL_BITS: " + this._stencilBits);
                console.info("UNIFORM_BUFFER_OFFSET_ALIGNMENT: " + this._uboOffsetAlignment);

                if (this._EXT_texture_filter_anisotropic) {
                  console.info("MAX_TEXTURE_MAX_ANISOTROPY_EXT: " + this._EXT_texture_filter_anisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
                }

                console.info("USE_VAO: " + this._useVAO);
                console.info("COMPRESSED_FORMAT: " + compressedFormat);
                this.initStates(gl);
                this._queue = this.createQueue(new QueueInfo(QueueType.GRAPHICS));
                this._cmdBuff = this.createCommandBuffer(new CommandBufferInfo(this._queue));
                this.nullTex2D = this.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.GEN_MIPMAP));
                this.nullTexCube = new WebGL2Texture(this);
                this.nullTexCube.initialize(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED, Format.RGBA8, 2, 2, TextureFlagBit.CUBEMAP | TextureFlagBit.GEN_MIPMAP, 6));
                var nullTexRegion = new BufferTextureCopy();
                nullTexRegion.texExtent.width = 2;
                nullTexRegion.texExtent.height = 2;
                var nullTexBuff = new Uint8Array(this.nullTex2D.size);
                nullTexBuff.fill(0);
                this.copyBuffersToTexture([nullTexBuff], this.nullTex2D, [nullTexRegion]);
                nullTexRegion.texSubres.layerCount = 6;
                this.copyBuffersToTexture([nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff, nullTexBuff], this.nullTexCube, [nullTexRegion]);
                return true;
              };

              _proto.destroy = function destroy() {
                if (this._canvas && this._webGLContextLostHandler) {
                  this._canvas.removeEventListener(eventWebGLContextLost$1, this._webGLContextLostHandler);

                  this._webGLContextLostHandler = null;
                }

                if (this.nullTex2D) {
                  this.nullTex2D.destroy();
                  this.nullTex2D = null;
                }

                if (this.nullTexCube) {
                  this.nullTexCube.destroy();
                  this.nullTexCube = null;
                }

                if (this._queue) {
                  this._queue.destroy();

                  this._queue = null;
                }

                if (this._cmdBuff) {
                  this._cmdBuff.destroy();

                  this._cmdBuff = null;
                }

                this._extensions = null;
                this._webGL2RC = null;
              };

              _proto.resize = function resize(width, height) {
                if (this._width !== width || this._height !== height) {
                  console.info("Resizing device: " + width + "x" + height);
                  this._canvas.width = width;
                  this._canvas.height = height;
                  this._width = width;
                  this._height = height;
                }
              };

              _proto.acquire = function acquire() {
                this.cmdAllocator.releaseCmds();
              };

              _proto.present = function present() {
                var queue = this._queue;
                this._numDrawCalls = queue.numDrawCalls;
                this._numInstances = queue.numInstances;
                this._numTris = queue.numTris;
                queue.clear();
              };

              _proto.createCommandBuffer = function createCommandBuffer(info) {
                var ctor = info.type === CommandBufferType.PRIMARY ? WebGL2PrimaryCommandBuffer : WebGL2CommandBuffer;
                var cmdBuff = new ctor(this);

                if (cmdBuff.initialize(info)) {
                  return cmdBuff;
                }

                return null;
              };

              _proto.createBuffer = function createBuffer(info) {
                var buffer = new WebGL2Buffer(this);

                if (buffer.initialize(info)) {
                  return buffer;
                }

                return null;
              };

              _proto.createTexture = function createTexture(info) {
                var texture = new WebGL2Texture(this);

                if (texture.initialize(info)) {
                  return texture;
                }

                return null;
              };

              _proto.createSampler = function createSampler(info) {
                var sampler = new WebGL2Sampler(this);

                if (sampler.initialize(info)) {
                  return sampler;
                }

                return null;
              };

              _proto.createDescriptorSet = function createDescriptorSet(info) {
                var descriptorSet = new WebGL2DescriptorSet(this);

                if (descriptorSet.initialize(info)) {
                  return descriptorSet;
                }

                return null;
              };

              _proto.createShader = function createShader(info) {
                var shader = new WebGL2Shader(this);

                if (shader.initialize(info)) {
                  return shader;
                }

                return null;
              };

              _proto.createInputAssembler = function createInputAssembler(info) {
                var inputAssembler = new WebGL2InputAssembler(this);

                if (inputAssembler.initialize(info)) {
                  return inputAssembler;
                }

                return null;
              };

              _proto.createRenderPass = function createRenderPass(info) {
                var renderPass = new WebGL2RenderPass(this);

                if (renderPass.initialize(info)) {
                  return renderPass;
                }

                return null;
              };

              _proto.createFramebuffer = function createFramebuffer(info) {
                var framebuffer = new WebGL2Framebuffer(this);

                if (framebuffer.initialize(info)) {
                  return framebuffer;
                }

                return null;
              };

              _proto.createDescriptorSetLayout = function createDescriptorSetLayout(info) {
                var descriptorSetLayout = new WebGL2DescriptorSetLayout(this);

                if (descriptorSetLayout.initialize(info)) {
                  return descriptorSetLayout;
                }

                return null;
              };

              _proto.createPipelineLayout = function createPipelineLayout(info) {
                var pipelineLayout = new WebGL2PipelineLayout(this);

                if (pipelineLayout.initialize(info)) {
                  return pipelineLayout;
                }

                return null;
              };

              _proto.createPipelineState = function createPipelineState(info) {
                var pipelineState = new WebGL2PipelineState(this);

                if (pipelineState.initialize(info)) {
                  return pipelineState;
                }

                return null;
              };

              _proto.createFence = function createFence(info) {
                var fence = new WebGL2Fence(this);

                if (fence.initialize(info)) {
                  return fence;
                }

                return null;
              };

              _proto.createQueue = function createQueue(info) {
                var queue = new WebGL2Queue(this);

                if (queue.initialize(info)) {
                  return queue;
                }

                return null;
              };

              _proto.copyBuffersToTexture = function copyBuffersToTexture(buffers, texture, regions) {
                WebGL2CmdFuncCopyBuffersToTexture(this, buffers, texture.gpuTexture, regions);
              };

              _proto.copyTexImagesToTexture = function copyTexImagesToTexture(texImages, texture, regions) {
                WebGL2CmdFuncCopyTexImagesToTexture(this, texImages, texture.gpuTexture, regions);
              };

              _proto.copyFramebufferToBuffer = function copyFramebufferToBuffer(srcFramebuffer, dstBuffer, regions) {
                var gl = this._webGL2RC;
                var gpuFramebuffer = srcFramebuffer.gpuFramebuffer;
                var format = gpuFramebuffer.gpuColorTextures[0].format;
                var glFormat = GFXFormatToWebGLFormat$1(format, gl);
                var glType = GFXFormatToWebGLType$1(format, gl);
                var ctor = getTypedArrayConstructor(FormatInfos[format]);
                var curFBO = this.stateCache.glFramebuffer;

                if (this.stateCache.glFramebuffer !== gpuFramebuffer.glFramebuffer) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, gpuFramebuffer.glFramebuffer);
                  this.stateCache.glFramebuffer = gpuFramebuffer.glFramebuffer;
                }

                var view = new ctor(dstBuffer);

                for (var _iterator2 = _createForOfIteratorHelperLoose(regions), _step2; !(_step2 = _iterator2()).done;) {
                  var region = _step2.value;
                  var w = region.texExtent.width;
                  var h = region.texExtent.height;
                  gl.readPixels(region.texOffset.x, region.texOffset.y, w, h, glFormat, glType, view);
                }

                if (this.stateCache.glFramebuffer !== curFBO) {
                  gl.bindFramebuffer(gl.FRAMEBUFFER, curFBO);
                  this.stateCache.glFramebuffer = curFBO;
                }
              };

              _proto.blitFramebuffer = function blitFramebuffer(src, dst, srcRect, dstRect, filter) {
                var srcFBO = src.gpuFramebuffer;
                var dstFBO = dst.gpuFramebuffer;
                WebGL2CmdFuncBlitFramebuffer(this, srcFBO, dstFBO, srcRect, dstRect, filter);
              };

              _proto.getExtension = function getExtension(ext) {
                var prefixes = ['', 'WEBKIT_', 'MOZ_'];

                for (var i = 0; i < prefixes.length; ++i) {
                  var _ext = this.gl.getExtension(prefixes[i] + ext);

                  if (_ext) {
                    return _ext;
                  }
                }

                return null;
              };

              _proto.initStates = function initStates(gl) {
                gl.activeTexture(gl.TEXTURE0);
                gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
                gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
                gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.enable(gl.SCISSOR_TEST);
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
                gl.frontFace(gl.CCW);
                gl.polygonOffset(0.0, 0.0);
                gl.enable(gl.DEPTH_TEST);
                gl.depthMask(true);
                gl.depthFunc(gl.LESS);
                gl.stencilFuncSeparate(gl.FRONT, gl.ALWAYS, 1, 0xffff);
                gl.stencilOpSeparate(gl.FRONT, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMaskSeparate(gl.FRONT, 0xffff);
                gl.stencilFuncSeparate(gl.BACK, gl.ALWAYS, 1, 0xffff);
                gl.stencilOpSeparate(gl.BACK, gl.KEEP, gl.KEEP, gl.KEEP);
                gl.stencilMaskSeparate(gl.BACK, 0xffff);
                gl.disable(gl.STENCIL_TEST);
                gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
                gl.disable(gl.BLEND);
                gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
                gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
                gl.colorMask(true, true, true, true);
                gl.blendColor(0.0, 0.0, 0.0, 0.0);
              };

              _proto._onWebGLContextLost = function _onWebGLContextLost(event) {
                warnID(11000);
                warn(event);
              };

              _createClass(WebGL2Device, [{
                key: "gl",
                get: function get() {
                  return this._webGL2RC;
                }
              }, {
                key: "isAntialias",
                get: function get() {
                  return this._isAntialias;
                }
              }, {
                key: "isPremultipliedAlpha",
                get: function get() {
                  return this._isPremultipliedAlpha;
                }
              }, {
                key: "useVAO",
                get: function get() {
                  return this._useVAO;
                }
              }, {
                key: "bindingMappingInfo",
                get: function get() {
                  return this._bindingMappingInfo;
                }
              }, {
                key: "EXT_texture_filter_anisotropic",
                get: function get() {
                  return this._EXT_texture_filter_anisotropic;
                }
              }, {
                key: "OES_texture_float_linear",
                get: function get() {
                  return this._OES_texture_float_linear;
                }
              }, {
                key: "EXT_color_buffer_float",
                get: function get() {
                  return this._EXT_color_buffer_float;
                }
              }, {
                key: "EXT_disjoint_timer_query_webgl2",
                get: function get() {
                  return this._EXT_disjoint_timer_query_webgl2;
                }
              }, {
                key: "WEBGL_compressed_texture_etc1",
                get: function get() {
                  return this._WEBGL_compressed_texture_etc1;
                }
              }, {
                key: "WEBGL_compressed_texture_etc",
                get: function get() {
                  return this._WEBGL_compressed_texture_etc;
                }
              }, {
                key: "WEBGL_compressed_texture_pvrtc",
                get: function get() {
                  return this._WEBGL_compressed_texture_pvrtc;
                }
              }, {
                key: "WEBGL_compressed_texture_s3tc",
                get: function get() {
                  return this._WEBGL_compressed_texture_s3tc;
                }
              }, {
                key: "WEBGL_compressed_texture_s3tc_srgb",
                get: function get() {
                  return this._WEBGL_compressed_texture_s3tc_srgb;
                }
              }, {
                key: "WEBGL_texture_storage_multisample",
                get: function get() {
                  return this._WEBGL_texture_storage_multisample;
                }
              }, {
                key: "WEBGL_debug_shaders",
                get: function get() {
                  return this._WEBGL_debug_shaders;
                }
              }, {
                key: "WEBGL_lose_context",
                get: function get() {
                  return this._WEBGL_lose_context;
                }
              }]);

              return WebGL2Device;
            }(Device));

            legacyCC.WebGL2Device = WebGL2Device;

            function toPPM(buffer, w, h) {
              return "P3 " + w + " " + h + " 255\n" + buffer.filter(function (e, i) {
                return i % 4 < 3;
              }).toString() + "\n";
            }

            var _keyMap;

            (function (_keyMap) {
              _keyMap[_keyMap["positions"] = AttributeName.ATTR_POSITION] = "positions";
              _keyMap[_keyMap["normals"] = AttributeName.ATTR_NORMAL] = "normals";
              _keyMap[_keyMap["uvs"] = AttributeName.ATTR_TEX_COORD] = "uvs";
              _keyMap[_keyMap["colors"] = AttributeName.ATTR_COLOR] = "colors";
            })(_keyMap || (_keyMap = {}));

            function readMesh(mesh, iPrimitive) {
              if (iPrimitive === void 0) {
                iPrimitive = 0;
              }

              var out = {
                positions: []
              };
              var dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
              var struct = mesh.struct;
              var primitive = struct.primitives[iPrimitive];

              for (var _iterator = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step; !(_step = _iterator()).done;) {
                var idx = _step.value;
                var bundle = struct.vertexBundles[idx];
                var offset = bundle.view.offset;
                var _bundle$view = bundle.view,
                    length = _bundle$view.length,
                    stride = _bundle$view.stride;

                for (var _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                  var attr = _step2.value;
                  var name = _keyMap[attr.name];

                  if (name) {
                    out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
                  }

                  offset += FormatInfos[attr.format].size;
                }
              }

              var view = primitive.indexView;
              out.indices = readBuffer(dataView, Format["R" + view.stride * 8 + "UI"], view.offset, view.length);
              return out;
            }

            var BufferBlob = function () {
              function BufferBlob() {
                this._arrayBufferOrPaddings = [];
                this._length = 0;
              }

              var _proto = BufferBlob.prototype;

              _proto.setNextAlignment = function setNextAlignment(align) {
                if (align !== 0) {
                  var remainder = this._length % align;

                  if (remainder !== 0) {
                    var padding = align - remainder;

                    this._arrayBufferOrPaddings.push(padding);

                    this._length += padding;
                  }
                }
              };

              _proto.addBuffer = function addBuffer(arrayBuffer) {
                var result = this._length;

                this._arrayBufferOrPaddings.push(arrayBuffer);

                this._length += arrayBuffer.byteLength;
                return result;
              };

              _proto.getLength = function getLength() {
                return this._length;
              };

              _proto.getCombined = function getCombined() {
                var result = new Uint8Array(this._length);
                var counter = 0;

                this._arrayBufferOrPaddings.forEach(function (arrayBufferOrPadding) {
                  if (typeof arrayBufferOrPadding === 'number') {
                    counter += arrayBufferOrPadding;
                  } else {
                    result.set(new Uint8Array(arrayBufferOrPadding), counter);
                    counter += arrayBufferOrPadding.byteLength;
                  }
                });

                return result.buffer;
              };

              return BufferBlob;
            }();

            var StdMorphRendering = function () {
              function StdMorphRendering(mesh, gfxDevice) {
                this._mesh = void 0;
                this._subMeshRenderings = [];
                this._mesh = mesh;

                if (!this._mesh.struct.morph) {
                  return;
                }

                var nSubMeshes = this._mesh.struct.primitives.length;
                this._subMeshRenderings = new Array(nSubMeshes).fill(null);

                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];

                  if (!subMeshMorph) {
                    continue;
                  }

                  if ( subMeshMorph.targets.length > UBOMorph.MAX_MORPH_TARGET_COUNT) {
                    this._subMeshRenderings[iSubMesh] = new CpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  } else {
                    this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  }
                }
              }

              var _proto = StdMorphRendering.prototype;

              _proto.createInstance = function createInstance() {
                var _this = this;

                var nSubMeshes = this._mesh.struct.primitives.length;
                var subMeshInstances = new Array(nSubMeshes);

                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var _this$_subMeshRenderi, _this$_subMeshRenderi2;

                  subMeshInstances[iSubMesh] = (_this$_subMeshRenderi = (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) === null || _this$_subMeshRenderi2 === void 0 ? void 0 : _this$_subMeshRenderi2.createInstance()) !== null && _this$_subMeshRenderi !== void 0 ? _this$_subMeshRenderi : null;
                }

                return {
                  setWeights: function setWeights(subMeshIndex, weights) {
                    var _subMeshInstances$sub;

                    (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub === void 0 ? void 0 : _subMeshInstances$sub.setWeights(weights);
                  },
                  requiredPatches: function requiredPatches(subMeshIndex) {
                    assertIsNonNullable(_this._mesh.struct.morph);
                    var subMeshMorph = _this._mesh.struct.morph.subMeshMorphs[subMeshIndex];
                    var subMeshRenderingInstance = subMeshInstances[subMeshIndex];

                    if (subMeshRenderingInstance === null) {
                      return undefined;
                    }

                    assertIsNonNullable(subMeshMorph);
                    var patches = [{
                      name: 'CC_USE_MORPH',
                      value: true
                    }, {
                      name: 'CC_MORPH_TARGET_COUNT',
                      value: subMeshMorph.targets.length
                    }];

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_POSITION)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_POSITION',
                        value: true
                      });
                    }

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_NORMAL)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_NORMAL',
                        value: true
                      });
                    }

                    if (subMeshMorph.attributes.includes(AttributeName.ATTR_TANGENT)) {
                      patches.push({
                        name: 'CC_MORPH_TARGET_HAS_TANGENT',
                        value: true
                      });
                    }

                    patches.push.apply(patches, subMeshRenderingInstance.requiredPatches());
                    return patches;
                  },
                  adaptPipelineState: function adaptPipelineState(subMeshIndex, descriptorSet) {
                    var _subMeshInstances$sub2;

                    (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub2 === void 0 ? void 0 : _subMeshInstances$sub2.adaptPipelineState(descriptorSet);
                  },
                  destroy: function destroy() {
                    for (var _iterator = _createForOfIteratorHelperLoose(subMeshInstances), _step; !(_step = _iterator()).done;) {
                      var subMeshInstance = _step.value;
                      subMeshInstance === null || subMeshInstance === void 0 ? void 0 : subMeshInstance.destroy();
                    }
                  }
                };
              };

              return StdMorphRendering;
            }();

            var GpuComputing = function () {
              function GpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
                this._gfxDevice = void 0;
                this._subMeshMorph = void 0;
                this._textureInfo = void 0;
                this._attributes = void 0;
                this._verticesCount = void 0;
                this._gfxDevice = gfxDevice;
                var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                this._subMeshMorph = subMeshMorph;
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                var nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;
                this._verticesCount = nVertices;
                var nTargets = subMeshMorph.targets.length;
                var vec4Required = nVertices * nTargets;
                var vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);
                this._textureInfo = {
                  width: vec4TextureFactory.width,
                  height: vec4TextureFactory.height
                };
                this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
                  var vec4Tex = vec4TextureFactory.create();
                  var valueView = vec4Tex.valueView;
                  subMeshMorph.targets.forEach(function (morphTarget, morphTargetIndex) {
                    var displacementsView = morphTarget.displacements[attributeIndex];
                    var displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);
                    var displacementsOffset = nVertices * morphTargetIndex * 4;

                    for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                      valueView[displacementsOffset + 4 * iVertex + 0] = displacements[3 * iVertex + 0];
                      valueView[displacementsOffset + 4 * iVertex + 1] = displacements[3 * iVertex + 1];
                      valueView[displacementsOffset + 4 * iVertex + 2] = displacements[3 * iVertex + 2];
                    }
                  });
                  vec4Tex.updatePixels();
                  return {
                    name: attributeName,
                    morphTexture: vec4Tex
                  };
                });
              }

              var _proto2 = GpuComputing.prototype;

              _proto2.destroy = function destroy() {
                for (var _iterator2 = _createForOfIteratorHelperLoose(this._attributes), _step2; !(_step2 = _iterator2()).done;) {
                  var attribute = _step2.value;
                  attribute.morphTexture.destroy();
                }
              };

              _proto2.createInstance = function createInstance() {
                var _this2 = this;

                var morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
                morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);
                morphUniforms.setVerticesCount(this._verticesCount);
                morphUniforms.commit();
                return {
                  setWeights: function setWeights(weights) {
                    morphUniforms.setWeights(weights);
                    morphUniforms.commit();
                  },
                  requiredPatches: function requiredPatches() {
                    return [{
                      name: 'CC_MORPH_TARGET_USE_TEXTURE',
                      value: true
                    }];
                  },
                  adaptPipelineState: function adaptPipelineState(descriptorSet) {
                    for (var _iterator3 = _createForOfIteratorHelperLoose(_this2._attributes), _step3; !(_step3 = _iterator3()).done;) {
                      var attribute = _step3.value;
                      var binding = void 0;

                      switch (attribute.name) {
                        case AttributeName.ATTR_POSITION:
                          binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                          break;

                        case AttributeName.ATTR_NORMAL:
                          binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                          break;

                        case AttributeName.ATTR_TANGENT:
                          binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                          break;

                        default:
                          warn('Unexpected attribute!');
                          break;
                      }

                      if (binding !== undefined) {
                        descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                        descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                      }
                    }

                    descriptorSet.bindBuffer(UBOMorph.BINDING, morphUniforms.buffer);
                    descriptorSet.update();
                  },
                  destroy: function destroy() {}
                };
              };

              return GpuComputing;
            }();

            var CpuComputing = function () {
              function CpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
                this._gfxDevice = void 0;
                this._attributes = [];
                this._gfxDevice = gfxDevice;
                var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
                  return {
                    name: attributeName,
                    targets: subMeshMorph.targets.map(function (attributeDisplacement) {
                      return {
                        displacements: new Float32Array(mesh.data.buffer, mesh.data.byteOffset + attributeDisplacement.displacements[attributeIndex].offset, attributeDisplacement.displacements[attributeIndex].count)
                      };
                    })
                  };
                });
              }

              var _proto3 = CpuComputing.prototype;

              _proto3.createInstance = function createInstance() {
                return new CpuComputingRenderingInstance(this, this._attributes[0].targets[0].displacements.length / 3, this._gfxDevice);
              };

              _createClass(CpuComputing, [{
                key: "data",
                get: function get() {
                  return this._attributes;
                }
              }]);

              return CpuComputing;
            }();

            var CpuComputingRenderingInstance = function () {
              function CpuComputingRenderingInstance(owner, nVertices, gfxDevice) {
                this._attributes = void 0;
                this._owner = void 0;
                this._morphUniforms = void 0;
                this._owner = owner;
                this._morphUniforms = new MorphUniforms(gfxDevice, 0);
                var vec4TextureFactory = createVec4TextureFactory(gfxDevice, nVertices);

                this._morphUniforms.setMorphTextureInfo(vec4TextureFactory.width, vec4TextureFactory.height);

                this._morphUniforms.commit();

                this._attributes = this._owner.data.map(function (attributeMorph, attributeIndex) {
                  var morphTexture = vec4TextureFactory.create();
                  return {
                    attributeName: attributeMorph.name,
                    morphTexture: morphTexture
                  };
                });
              }

              var _proto4 = CpuComputingRenderingInstance.prototype;

              _proto4.setWeights = function setWeights(weights) {
                for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  var myAttribute = this._attributes[iAttribute];
                  var valueView = myAttribute.morphTexture.valueView;
                  var attributeMorph = this._owner.data[iAttribute];
                  assertIsTrue(weights.length === attributeMorph.targets.length);

                  for (var iTarget = 0; iTarget < attributeMorph.targets.length; ++iTarget) {
                    var targetDisplacements = attributeMorph.targets[iTarget].displacements;
                    var weight = weights[iTarget];
                    var nVertices = targetDisplacements.length / 3;

                    if (iTarget === 0) {
                      for (var iVertex = 0; iVertex < nVertices; ++iVertex) {
                        valueView[4 * iVertex + 0] = targetDisplacements[3 * iVertex + 0] * weight;
                        valueView[4 * iVertex + 1] = targetDisplacements[3 * iVertex + 1] * weight;
                        valueView[4 * iVertex + 2] = targetDisplacements[3 * iVertex + 2] * weight;
                      }
                    } else {
                      for (var _iVertex = 0; _iVertex < nVertices; ++_iVertex) {
                        valueView[4 * _iVertex + 0] += targetDisplacements[3 * _iVertex + 0] * weight;
                        valueView[4 * _iVertex + 1] += targetDisplacements[3 * _iVertex + 1] * weight;
                        valueView[4 * _iVertex + 2] += targetDisplacements[3 * _iVertex + 2] * weight;
                      }
                    }
                  }

                  myAttribute.morphTexture.updatePixels();
                }
              };

              _proto4.requiredPatches = function requiredPatches() {
                return [{
                  name: 'CC_MORPH_TARGET_USE_TEXTURE',
                  value: true
                }, {
                  name: 'CC_MORPH_PRECOMPUTED',
                  value: true
                }];
              };

              _proto4.adaptPipelineState = function adaptPipelineState(descriptorSet) {
                for (var _iterator4 = _createForOfIteratorHelperLoose(this._attributes), _step4; !(_step4 = _iterator4()).done;) {
                  var attribute = _step4.value;
                  var attributeName = attribute.attributeName;
                  var binding = void 0;

                  switch (attributeName) {
                    case AttributeName.ATTR_POSITION:
                      binding = UNIFORM_POSITION_MORPH_TEXTURE_BINDING;
                      break;

                    case AttributeName.ATTR_NORMAL:
                      binding = UNIFORM_NORMAL_MORPH_TEXTURE_BINDING;
                      break;

                    case AttributeName.ATTR_TANGENT:
                      binding = UNIFORM_TANGENT_MORPH_TEXTURE_BINDING;
                      break;

                    default:
                      warn('Unexpected attribute!');
                      break;
                  }

                  if (binding !== undefined) {
                    descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                    descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                  }
                }

                descriptorSet.bindBuffer(UBOMorph.BINDING, this._morphUniforms.buffer);
                descriptorSet.update();
              };

              _proto4.destroy = function destroy() {
                this._morphUniforms.destroy();

                for (var iAttribute = 0; iAttribute < this._attributes.length; ++iAttribute) {
                  var myAttribute = this._attributes[iAttribute];
                  myAttribute.morphTexture.destroy();
                }
              };

              return CpuComputingRenderingInstance;
            }();

            var MorphUniforms = function () {
              function MorphUniforms(gfxDevice, targetCount) {
                this._targetCount = void 0;
                this._localBuffer = void 0;
                this._remoteBuffer = void 0;
                this._targetCount = targetCount;
                this._localBuffer = new DataView(new ArrayBuffer(UBOMorph.SIZE));
                this._remoteBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOMorph.SIZE, UBOMorph.SIZE));
              }

              var _proto5 = MorphUniforms.prototype;

              _proto5.destroy = function destroy() {
                this._remoteBuffer.destroy();
              };

              _proto5.setWeights = function setWeights(weights) {
                assertIsTrue(weights.length === this._targetCount);

                for (var iWeight = 0; iWeight < weights.length; ++iWeight) {
                  this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], legacyCC.sys.isLittleEndian);
                }
              };

              _proto5.setMorphTextureInfo = function setMorphTextureInfo(width, height) {
                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, legacyCC.sys.isLittleEndian);

                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, legacyCC.sys.isLittleEndian);
              };

              _proto5.setVerticesCount = function setVerticesCount(count) {
                this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_VERTICES_COUNT, count, legacyCC.sys.isLittleEndian);
              };

              _proto5.commit = function commit() {
                this._remoteBuffer.update(this._localBuffer.buffer);
              };

              _createClass(MorphUniforms, [{
                key: "buffer",
                get: function get() {
                  return this._remoteBuffer;
                }
              }]);

              return MorphUniforms;
            }();

            function createVec4TextureFactory(gfxDevice, vec4Capacity) {
              var hasFeatureFloatTexture = gfxDevice.hasFeature(Feature.TEXTURE_FLOAT);
              var pixelRequired;
              var pixelFormat;
              var pixelBytes;
              var UpdateViewConstructor;

              if (hasFeatureFloatTexture) {
                pixelRequired = vec4Capacity;
                pixelBytes = 16;
                pixelFormat = Texture2D.PixelFormat.RGBA32F;
                UpdateViewConstructor = Float32Array;
              } else {
                pixelRequired = 4 * vec4Capacity;
                pixelBytes = 4;
                pixelFormat = Texture2D.PixelFormat.RGBA8888;
                UpdateViewConstructor = Uint8Array;
              }

              var _bestSizeToHavePixels = bestSizeToHavePixels(pixelRequired),
                  width = _bestSizeToHavePixels.width,
                  height = _bestSizeToHavePixels.height;

              assertIsTrue(width * height >= pixelRequired);
              return {
                width: width,
                height: height,
                create: function create() {
                  var arrayBuffer = new ArrayBuffer(width * height * pixelBytes);
                  var valueView = new Float32Array(arrayBuffer);
                  var updateView = UpdateViewConstructor === Float32Array ? valueView : new UpdateViewConstructor(arrayBuffer);
                  var image = new ImageAsset({
                    width: width,
                    height: height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  var textureAsset = new Texture2D();
                  textureAsset.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
                  textureAsset.setMipFilter(Texture2D.Filter.NONE);
                  textureAsset.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
                  textureAsset.image = image;

                  if (!textureAsset.getGFXTexture()) {
                    warn('Unexpected: failed to create morph texture?');
                  }

                  var sampler = samplerLib.getSampler(gfxDevice, textureAsset.getSamplerHash());
                  return {
                    get texture() {
                      return textureAsset.getGFXTexture();
                    },

                    get sampler() {
                      return sampler;
                    },

                    get valueView() {
                      return valueView;
                    },

                    destroy: function destroy() {
                      textureAsset.destroy();
                    },
                    updatePixels: function updatePixels() {
                      textureAsset.uploadData(updateView);
                    }
                  };
                }
              };
            }

            function enableVertexId(mesh, subMeshIndex, gfxDevice) {
              mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
            }

            function bestSizeToHavePixels(nPixels) {
              if (nPixels < 5) {
                nPixels = 5;
              }

              var aligned = nextPow2(nPixels);
              var epxSum = log2(aligned);
              var h = epxSum >> 1;
              var w = epxSum & 1 ? h + 1 : h;
              return {
                width: 1 << w,
                height: 1 << h
              };
            }

            function createMorphRendering(mesh, gfxDevice) {
              return new StdMorphRendering(mesh, gfxDevice);
            }

            var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _temp;

            function getIndexStrideCtor(stride) {
              switch (stride) {
                case 1:
                  return Uint8Array;

                case 2:
                  return Uint16Array;

                case 4:
                  return Uint32Array;

                default:
                  return Uint8Array;
              }
            }

            var v3_1 = new Vec3();
            var v3_2 = new Vec3();
            var globalEmptyMeshBuffer = new Uint8Array();
            var Mesh = exports('Mesh', (_dec = ccclass('cc.Mesh'), _dec(_class = (_class2 = (_temp = function (_Asset) {
              _inheritsLoose(Mesh, _Asset);

              _createClass(Mesh, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._data.buffer;
                },
                set: function set(value) {
                  if (this._data.byteLength === value.byteLength) {
                    this._data.set(new Uint8Array(value));
                  } else {
                    this._data = new Uint8Array(value);
                  }

                  this.loaded = true;
                  this.emit('load');
                }
              }, {
                key: "subMeshCount",
                get: function get() {
                  var renderingMesh = this.renderingSubMeshes;
                  return renderingMesh ? renderingMesh.length : 0;
                }
              }, {
                key: "minPosition",
                get: function get() {
                  return this.struct.minPosition;
                }
              }, {
                key: "maxPosition",
                get: function get() {
                  return this.struct.maxPosition;
                }
              }, {
                key: "struct",
                get: function get() {
                  return this._struct;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }, {
                key: "hash",
                get: function get() {
                  if (!this._hash) {
                    this._hash = murmurhash2_32_gc(this._data, 666);
                  }

                  return this._hash;
                }
              }, {
                key: "jointBufferIndices",
                get: function get() {
                  if (this._jointBufferIndices) {
                    return this._jointBufferIndices;
                  }

                  return this._jointBufferIndices = this._struct.primitives.map(function (p) {
                    return p.jointMapIndex || 0;
                  });
                }
              }, {
                key: "renderingSubMeshes",
                get: function get() {
                  this.initialize();
                  return this._renderingSubMeshes;
                }
              }]);

              function Mesh() {
                var _this;

                _this = _Asset.call(this) || this;
                _this.morphRendering = null;

                _initializerDefineProperty(_this, "_struct", _descriptor, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_dataLength", _descriptor2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_hash", _descriptor3, _assertThisInitialized(_this));

                _this._data = globalEmptyMeshBuffer;
                _this._initialized = false;
                _this._renderingSubMeshes = null;
                _this._boneSpaceBounds = new Map();
                _this._jointBufferIndices = null;
                _this.loaded = false;
                return _this;
              }

              var _proto = Mesh.prototype;

              _proto.initialize = function initialize() {
                var _this2 = this;

                if (this._initialized) {
                  return;
                }

                this._initialized = true;

                if (this._data.byteLength !== this._dataLength) {
                  this._data = new Uint8Array(this._dataLength);
                  legacyCC.assetManager.postLoadNative(this);
                }

                var buffer = this._data.buffer;
                var gfxDevice = legacyCC.director.root.device;

                var vertexBuffers = this._createVertexBuffers(gfxDevice, buffer);
                var subMeshes = [];

                var _loop = function _loop(i) {
                  var prim = _this2._struct.primitives[i];

                  if (prim.vertexBundelIndices.length === 0) {
                    return "continue";
                  }

                  var indexBuffer = null;
                  var ib = null;

                  if (prim.indexView) {
                    var idxView = prim.indexView;
                    var dstStride = idxView.stride;
                    var dstSize = idxView.length;

                    if (dstStride === 4 && !gfxDevice.hasFeature(Feature.ELEMENT_INDEX_UINT)) {
                      var vertexCount = _this2._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;

                      if (vertexCount >= 65536) {
                        warnID(10001, vertexCount, 65536);
                        return "continue";
                      } else {
                        dstStride >>= 1;
                        dstSize >>= 1;
                      }
                    }

                    indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX, MemoryUsageBit.DEVICE, dstSize, dstStride));
                    ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);

                    if (idxView.stride !== dstStride) {
                      ib = getIndexStrideCtor(dstStride).from(ib);
                    }

                    if (_this2.loaded) {
                      indexBuffer.update(ib);
                    } else {
                      _this2.once('load', function () {
                        indexBuffer.update(ib);
                      });
                    }
                  }

                  var vbReference = prim.vertexBundelIndices.map(function (idx) {
                    return vertexBuffers[idx];
                  });
                  var gfxAttributes = [];

                  if (prim.vertexBundelIndices.length > 0) {
                    var idx = prim.vertexBundelIndices[0];
                    var _vertexBundle = _this2._struct.vertexBundles[idx];
                    var attrs = _vertexBundle.attributes;

                    for (var j = 0; j < attrs.length; ++j) {
                      var attr = attrs[j];
                      gfxAttributes[j] = new Attribute(attr.name, attr.format, attr.isInstanced, attr.stream, attr.isInstanced, attr.location);
                    }
                  }

                  var subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode, indexBuffer);
                  subMesh.mesh = _this2;
                  subMesh.subMeshIdx = i;
                  subMeshes.push(subMesh);
                };

                for (var i = 0; i < this._struct.primitives.length; i++) {
                  var _ret = _loop(i);

                  if (_ret === "continue") continue;
                }

                this._renderingSubMeshes = subMeshes;

                if (this._struct.morph) {
                  this.morphRendering = createMorphRendering(this, gfxDevice);
                }
              };

              _proto.destroy = function destroy() {
                this.destroyRenderingMesh();
                return _Asset.prototype.destroy.call(this);
              };

              _proto.destroyRenderingMesh = function destroyRenderingMesh() {
                if (this._renderingSubMeshes) {
                  for (var i = 0; i < this._renderingSubMeshes.length; i++) {
                    this._renderingSubMeshes[i].destroy();
                  }

                  this._renderingSubMeshes = null;
                  this._initialized = false;
                }
              };

              _proto.assign = function assign(struct, data) {
                this.reset({
                  struct: struct,
                  data: data
                });
              };

              _proto.reset = function reset(info) {
                this.destroyRenderingMesh();
                this._struct = info.struct;
                this._data = info.data;
                this._dataLength = this.data.byteLength;
                this._hash = 0;
                this.loaded = true;
                this.emit('load');
              };

              _proto.getBoneSpaceBounds = function getBoneSpaceBounds(skeleton) {
                if (this._boneSpaceBounds.has(skeleton.hash)) {
                  return this._boneSpaceBounds.get(skeleton.hash);
                }

                var bounds = [];

                this._boneSpaceBounds.set(skeleton.hash, bounds);

                var valid = [];
                var bindposes = skeleton.bindposes;

                for (var i = 0; i < bindposes.length; i++) {
                  bounds.push(new AABB(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));
                  valid.push(false);
                }

                var primitives = this._struct.primitives;

                for (var p = 0; p < primitives.length; p++) {
                  var joints = this.readAttribute(p, AttributeName.ATTR_JOINTS);
                  var weights = this.readAttribute(p, AttributeName.ATTR_WEIGHTS);
                  var positions = this.readAttribute(p, AttributeName.ATTR_POSITION);

                  if (!joints || !weights || !positions) {
                    continue;
                  }

                  var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);

                  for (var _i = 0; _i < vertCount; _i++) {
                    Vec3.set(v3_1, positions[3 * _i + 0], positions[3 * _i + 1], positions[3 * _i + 2]);

                    for (var j = 0; j < 4; ++j) {
                      var idx = 4 * _i + j;
                      var joint = joints[idx];

                      if (weights[idx] === 0 || joint >= bindposes.length) {
                        continue;
                      }

                      Vec3.transformMat4(v3_2, v3_1, bindposes[joint]);
                      valid[joint] = true;
                      var b = bounds[joint];
                      Vec3.min(b.center, b.center, v3_2);
                      Vec3.max(b.halfExtents, b.halfExtents, v3_2);
                    }
                  }
                }

                for (var _i2 = 0; _i2 < bindposes.length; _i2++) {
                  var _b = bounds[_i2];

                  if (!valid[_i2]) {
                    bounds[_i2] = null;
                  } else {
                    AABB.fromPoints(_b, _b.center, _b.halfExtents);
                  }
                }

                return bounds;
              };

              _proto.merge = function merge(mesh, worldMatrix, validate) {
                if (validate) {
                  if (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh)) {
                    return false;
                  }
                }

                var vec3_temp = new Vec3();
                var rotate = worldMatrix && new Quat();
                var boundingBox = worldMatrix && new AABB();

                if (rotate) {
                  worldMatrix.getRotation(rotate);
                }

                if (!this._initialized) {
                  var struct = JSON.parse(JSON.stringify(mesh._struct));

                  var data = mesh._data.slice();

                  if (worldMatrix) {
                    if (struct.maxPosition && struct.minPosition) {
                      Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                      Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                      AABB.transform(boundingBox, boundingBox, worldMatrix);
                      Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents);
                      Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents);
                    }

                    for (var i = 0; i < struct.vertexBundles.length; i++) {
                      var vtxBdl = struct.vertexBundles[i];

                      for (var j = 0; j < vtxBdl.attributes.length; j++) {
                        if (vtxBdl.attributes[j].name === AttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === AttributeName.ATTR_NORMAL) {
                          var format = vtxBdl.attributes[j].format;
                          var inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j));
                          var reader = getReader(inputView, format);
                          var writer = getWriter(inputView, format);

                          if (!reader || !writer) {
                            continue;
                          }

                          var vertexCount = vtxBdl.view.count;
                          var vertexStride = vtxBdl.view.stride;
                          var attrComponentByteLength = getComponentByteLength(format);

                          for (var vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                            var xOffset = vtxIdx * vertexStride;
                            var yOffset = xOffset + attrComponentByteLength;
                            var zOffset = yOffset + attrComponentByteLength;
                            vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));

                            switch (vtxBdl.attributes[j].name) {
                              case AttributeName.ATTR_POSITION:
                                vec3_temp.transformMat4(worldMatrix);
                                break;

                              case AttributeName.ATTR_NORMAL:
                                Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                break;
                            }

                            writer(xOffset, vec3_temp.x);
                            writer(yOffset, vec3_temp.y);
                            writer(zOffset, vec3_temp.z);
                          }
                        }
                      }
                    }
                  }

                  this.reset({
                    struct: struct,
                    data: data
                  });
                  this.initialize();
                  return true;
                }

                var bufferBlob = new BufferBlob();
                var vertCount = 0;
                var vertStride = 0;
                var srcOffset = 0;
                var dstOffset = 0;
                var vb;
                var vbView;
                var srcVBView;
                var dstVBView;
                var srcAttrOffset = 0;
                var srcVBOffset = 0;
                var dstVBOffset = 0;
                var attrSize = 0;
                var dstAttrView;
                var hasAttr = false;
                var vertexBundles = new Array(this._struct.vertexBundles.length);

                for (var _i3 = 0; _i3 < this._struct.vertexBundles.length; ++_i3) {
                  var bundle = this._struct.vertexBundles[_i3];
                  var dstBundle = mesh._struct.vertexBundles[_i3];
                  srcOffset = bundle.view.offset;
                  dstOffset = dstBundle.view.offset;
                  vertStride = bundle.view.stride;
                  vertCount = bundle.view.count + dstBundle.view.count;
                  vb = new ArrayBuffer(vertCount * vertStride);
                  vbView = new Uint8Array(vb);
                  srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);
                  srcOffset += srcVBView.length;
                  dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);
                  dstOffset += dstVBView.length;
                  vbView.set(srcVBView);
                  srcAttrOffset = 0;

                  for (var _iterator = _createForOfIteratorHelperLoose(bundle.attributes), _step; !(_step = _iterator()).done;) {
                    var attr = _step.value;
                    dstVBOffset = 0;
                    hasAttr = false;

                    for (var _iterator2 = _createForOfIteratorHelperLoose(dstBundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                      var dstAttr = _step2.value;

                      if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                        hasAttr = true;
                        break;
                      }

                      dstVBOffset += FormatInfos[dstAttr.format].size;
                    }

                    if (hasAttr) {
                      attrSize = FormatInfos[attr.format].size;
                      srcVBOffset = bundle.view.length + srcAttrOffset;

                      for (var v = 0; v < dstBundle.view.count; ++v) {
                        dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);
                        vbView.set(dstAttrView, srcVBOffset);

                        if ((attr.name === AttributeName.ATTR_POSITION || attr.name === AttributeName.ATTR_NORMAL) && worldMatrix) {
                          var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                          vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);

                          switch (attr.name) {
                            case AttributeName.ATTR_POSITION:
                              vec3_temp.transformMat4(worldMatrix);
                              break;

                            case AttributeName.ATTR_NORMAL:
                              Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                              break;
                          }

                          f32_temp[0] = vec3_temp.x;
                          f32_temp[1] = vec3_temp.y;
                          f32_temp[2] = vec3_temp.z;
                        }

                        srcVBOffset += bundle.view.stride;
                        dstVBOffset += dstBundle.view.stride;
                      }
                    }

                    srcAttrOffset += FormatInfos[attr.format].size;
                  }

                  vertexBundles[_i3] = {
                    attributes: bundle.attributes,
                    view: {
                      offset: bufferBlob.getLength(),
                      length: vb.byteLength,
                      count: vertCount,
                      stride: vertStride
                    }
                  };
                  bufferBlob.addBuffer(vb);
                }

                var idxCount = 0;
                var idxStride = 2;
                var vertBatchCount = 0;
                var ibView;
                var srcIBView;
                var dstIBView;
                var primitives = new Array(this._struct.primitives.length);

                for (var _i4 = 0; _i4 < this._struct.primitives.length; ++_i4) {
                  var prim = this._struct.primitives[_i4];
                  var dstPrim = mesh._struct.primitives[_i4];
                  primitives[_i4] = {
                    primitiveMode: prim.primitiveMode,
                    vertexBundelIndices: prim.vertexBundelIndices
                  };

                  for (var _iterator3 = _createForOfIteratorHelperLoose(prim.vertexBundelIndices), _step3; !(_step3 = _iterator3()).done;) {
                    var bundleIdx = _step3.value;
                    vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                  }

                  if (prim.indexView && dstPrim.indexView) {
                    idxCount = prim.indexView.count;
                    idxCount += dstPrim.indexView.count;
                    srcOffset = prim.indexView.offset;
                    dstOffset = dstPrim.indexView.offset;

                    if (idxCount < 256) {
                      idxStride = 1;
                    } else if (idxCount < 65536) {
                      idxStride = 2;
                    } else {
                      idxStride = 4;
                    }

                    var ib = new ArrayBuffer(idxCount * idxStride);

                    if (idxStride === 2) {
                      ibView = new Uint16Array(ib);
                    } else if (idxStride === 1) {
                      ibView = new Uint8Array(ib);
                    } else {
                      ibView = new Uint32Array(ib);
                    }

                    if (prim.indexView.stride === 2) {
                      srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else if (prim.indexView.stride === 1) {
                      srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);
                    } else {
                      srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);
                    }

                    if (idxStride === prim.indexView.stride) {
                      ibView.set(srcIBView);
                    } else {
                      for (var n = 0; n < prim.indexView.count; ++n) {
                        ibView[n] = srcIBView[n];
                      }
                    }

                    srcOffset += prim.indexView.length;

                    if (dstPrim.indexView.stride === 2) {
                      dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else if (dstPrim.indexView.stride === 1) {
                      dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    } else {
                      dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                    }

                    for (var _n = 0; _n < dstPrim.indexView.count; ++_n) {
                      ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                    }

                    dstOffset += dstPrim.indexView.length;
                    primitives[_i4].indexView = {
                      offset: bufferBlob.getLength(),
                      length: ib.byteLength,
                      count: idxCount,
                      stride: idxStride
                    };
                    bufferBlob.setNextAlignment(idxStride);
                    bufferBlob.addBuffer(ib);
                  }
                }

                var meshStruct = {
                  vertexBundles: vertexBundles,
                  primitives: primitives,
                  minPosition: this._struct.minPosition,
                  maxPosition: this._struct.maxPosition
                };

                if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {
                  if (worldMatrix) {
                    Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition);
                    Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                    Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);
                    Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                    AABB.transform(boundingBox, boundingBox, worldMatrix);
                    Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);
                    Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                    Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);
                  } else {
                    Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);
                    Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);
                  }
                }

                this.reset({
                  struct: meshStruct,
                  data: new Uint8Array(bufferBlob.getCombined())
                });
                this.initialize();
                return true;
              };

              _proto.validateMergingMesh = function validateMergingMesh(mesh) {
                if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {
                  return false;
                }

                for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                  var bundle = this._struct.vertexBundles[i];
                  var dstBundle = mesh._struct.vertexBundles[i];

                  if (bundle.attributes.length !== dstBundle.attributes.length) {
                    return false;
                  }

                  for (var j = 0; j < bundle.attributes.length; ++j) {
                    if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {
                      return false;
                    }
                  }
                }

                if (this._struct.primitives.length !== mesh._struct.primitives.length) {
                  return false;
                }

                for (var _i5 = 0; _i5 < this._struct.primitives.length; ++_i5) {
                  var prim = this._struct.primitives[_i5];
                  var dstPrim = mesh._struct.primitives[_i5];

                  if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {
                    return false;
                  }

                  for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) {
                    if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) {
                      return false;
                    }
                  }

                  if (prim.primitiveMode !== dstPrim.primitiveMode) {
                    return false;
                  }

                  if (prim.indexView) {
                    if (dstPrim.indexView === undefined) {
                      return false;
                    }
                  } else if (dstPrim.indexView) {
                    return false;
                  }
                }

                return true;
              };

              _proto.readAttribute = function readAttribute(primitiveIndex, attributeName) {
                var _this3 = this;

                var result = null;

                this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                  var vertexCount = vertexBundle.view.count;
                  var format = vertexBundle.attributes[iAttribute].format;
                  var storageConstructor = getTypedArrayConstructor(FormatInfos[format]);

                  if (vertexCount === 0) {
                    return;
                  }

                  var inputView = new DataView(_this3._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  var formatInfo = FormatInfos[format];
                  var reader = getReader(inputView, format);

                  if (!storageConstructor || !reader) {
                    return;
                  }

                  var componentCount = formatInfo.count;
                  var storage = new storageConstructor(vertexCount * componentCount);
                  var inputStride = vertexBundle.view.stride;

                  for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                      storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                    }
                  }

                  result = storage;
                });

                return result;
              };

              _proto.copyAttribute = function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                var _this4 = this;

                var written = false;

                this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                  var vertexCount = vertexBundle.view.count;

                  if (vertexCount === 0) {
                    written = true;
                    return;
                  }

                  var format = vertexBundle.attributes[iAttribute].format;
                  var inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                  var outputView = new DataView(buffer, offset);
                  var formatInfo = FormatInfos[format];
                  var reader = getReader(inputView, format);
                  var writer = getWriter(outputView, format);

                  if (!reader || !writer) {
                    return;
                  }

                  var componentCount = formatInfo.count;
                  var inputStride = vertexBundle.view.stride;
                  var inputComponentByteLength = getComponentByteLength(format);
                  var outputStride = stride;
                  var outputComponentByteLength = inputComponentByteLength;

                  for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                      var inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;
                      var outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;
                      writer(outputOffset, reader(inputOffset));
                    }
                  }

                  written = true;
                });

                return written;
              };

              _proto.readIndices = function readIndices(primitiveIndex) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return null;
                }

                var primitive = this._struct.primitives[primitiveIndex];

                if (!primitive.indexView) {
                  return null;
                }

                var stride = primitive.indexView.stride;
                var ctor = stride === 1 ? Uint8Array : stride === 2 ? Uint16Array : Uint32Array;
                return new ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
              };

              _proto.copyIndices = function copyIndices(primitiveIndex, outputArray) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return false;
                }

                var primitive = this._struct.primitives[primitiveIndex];

                if (!primitive.indexView) {
                  return false;
                }

                var indexCount = primitive.indexView.count;
                var indexFormat = primitive.indexView.stride === 1 ? Format.R8UI : primitive.indexView.stride === 2 ? Format.R16UI : Format.R32UI;
                var reader = getReader(new DataView(this._data.buffer), indexFormat);

                for (var i = 0; i < indexCount; ++i) {
                  outputArray[i] = reader(primitive.indexView.offset + FormatInfos[indexFormat].size * i);
                }

                return true;
              };

              _proto._accessAttribute = function _accessAttribute(primitiveIndex, attributeName, accessor) {
                if (primitiveIndex >= this._struct.primitives.length) {
                  return;
                }

                var primitive = this._struct.primitives[primitiveIndex];

                for (var _iterator4 = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step4; !(_step4 = _iterator4()).done;) {
                  var vertexBundleIndex = _step4.value;
                  var _vertexBundle2 = this._struct.vertexBundles[vertexBundleIndex];

                  var _iAttribute = _vertexBundle2.attributes.findIndex(function (a) {
                    return a.name === attributeName;
                  });

                  if (_iAttribute < 0) {
                    continue;
                  }

                  accessor(_vertexBundle2, _iAttribute);
                  break;
                }
              };

              _proto._createVertexBuffers = function _createVertexBuffers(gfxDevice, data) {
                var _this5 = this;

                return this._struct.vertexBundles.map(function (vertexBundle) {
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX, MemoryUsageBit.DEVICE, vertexBundle.view.length, vertexBundle.view.stride));
                  var view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);

                  if (_this5.loaded) {
                    vertexBuffer.update(view);
                  } else {
                    _this5.once('load', function () {
                      vertexBuffer.update(view);
                    });
                  }

                  return vertexBuffer;
                });
              };

              return Mesh;
            }(Asset), _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "_struct", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return {
                  vertexBundles: [],
                  primitives: []
                };
              }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "_dataLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2)) || _class));
            legacyCC.Mesh = Mesh;

            function getOffset(attributes, attributeIndex) {
              var result = 0;

              for (var i = 0; i < attributeIndex; ++i) {
                var attribute = attributes[i];
                result += FormatInfos[attribute.format].size;
              }

              return result;
            }

            var isLittleEndian = sys.isLittleEndian;

            function getComponentByteLength(format) {
              var info = FormatInfos[format];
              return info.size / info.count;
            }

            function getReader(dataView, format) {
              var info = FormatInfos[format];
              var stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return function (offset) {
                      return dataView.getFloat32(offset, isLittleEndian);
                    };
                  }
              }

              return null;
            }

            function getWriter(dataView, format) {
              var info = FormatInfos[format];
              var stride = info.size / info.count;

              switch (info.type) {
                case FormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case FormatType.FLOAT:
                  {
                    return function (offset, value) {
                      return dataView.setFloat32(offset, value, isLittleEndian);
                    };
                  }
              }

              return null;
            }

            var _defAttrs = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_NORMAL, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_TANGENT, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var v3_1$1 = new Vec3();
            function createMesh(geometry, out, options) {
              options = options || {};
              var attributes = [];
              var stride = 0;
              var channels = [];
              var vertCount = 0;
              var attr;
              var positions = geometry.positions.slice();

              if (positions.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator = _createForOfIteratorHelperLoose(geometry.attributes), _step; !(_step = _iterator()).done;) {
                    var att = _step.value;

                    if (att.name === AttributeName.ATTR_POSITION) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[0];
                }

                attributes.push(attr);
                var info = FormatInfos[attr.format];
                vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
                channels.push({
                  offset: stride,
                  data: positions,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.normals && geometry.normals.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(geometry.attributes), _step2; !(_step2 = _iterator2()).done;) {
                    var _att = _step2.value;

                    if (_att.name === AttributeName.ATTR_NORMAL) {
                      attr = _att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[1];
                }

                var _info = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count));
                channels.push({
                  offset: stride,
                  data: geometry.normals,
                  attribute: attr
                });
                stride += _info.size;
              }

              if (geometry.uvs && geometry.uvs.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(geometry.attributes), _step3; !(_step3 = _iterator3()).done;) {
                    var _att2 = _step3.value;

                    if (_att2.name === AttributeName.ATTR_TEX_COORD) {
                      attr = _att2;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[2];
                }

                var _info2 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count));
                channels.push({
                  offset: stride,
                  data: geometry.uvs,
                  attribute: attr
                });
                stride += _info2.size;
              }

              if (geometry.tangents && geometry.tangents.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator4 = _createForOfIteratorHelperLoose(geometry.attributes), _step4; !(_step4 = _iterator4()).done;) {
                    var _att3 = _step4.value;

                    if (_att3.name === AttributeName.ATTR_TANGENT) {
                      attr = _att3;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[3];
                }

                var _info3 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / _info3.count));
                channels.push({
                  offset: stride,
                  data: geometry.tangents,
                  attribute: attr
                });
                stride += _info3.size;
              }

              if (geometry.colors && geometry.colors.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator5 = _createForOfIteratorHelperLoose(geometry.attributes), _step5; !(_step5 = _iterator5()).done;) {
                    var _att4 = _step5.value;

                    if (_att4.name === AttributeName.ATTR_COLOR) {
                      attr = _att4;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[4];
                }

                var _info4 = FormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info4.count));
                channels.push({
                  offset: stride,
                  data: geometry.colors,
                  attribute: attr
                });
                stride += _info4.size;
              }

              if (geometry.customAttributes) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(geometry.customAttributes), _step6; !(_step6 = _iterator6()).done;) {
                  var ca = _step6.value;
                  var _info5 = FormatInfos[ca.attr.format];
                  attributes.push(ca.attr);
                  vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info5.count));
                  channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                  });
                  stride += _info5.size;
                }
              }

              var bufferBlob = new BufferBlob();
              var vertexBuffer = new ArrayBuffer(vertCount * stride);
              var vertexBufferView = new DataView(vertexBuffer);

              for (var _i = 0, _channels = channels; _i < _channels.length; _i++) {
                var channel = _channels[_i];
                writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
              }

              bufferBlob.setNextAlignment(0);
              var vertexBundle = {
                attributes: attributes,
                view: {
                  offset: bufferBlob.getLength(),
                  length: vertexBuffer.byteLength,
                  count: vertCount,
                  stride: stride
                }
              };
              bufferBlob.addBuffer(vertexBuffer);
              var indexBuffer = null;
              var idxCount = 0;
              var idxStride = 2;

              if (geometry.indices) {
                var indices = geometry.indices;
                idxCount = indices.length;
                indexBuffer = new ArrayBuffer(idxStride * idxCount);
                var indexBufferView = new DataView(indexBuffer);
                writeBuffer(indexBufferView, indices, Format.R16UI);
              }

              var primitive = {
                primitiveMode: geometry.primitiveMode || PrimitiveMode.TRIANGLE_LIST,
                vertexBundelIndices: [0]
              };

              if (indexBuffer) {
                bufferBlob.setNextAlignment(idxStride);
                primitive.indexView = {
                  offset: bufferBlob.getLength(),
                  length: indexBuffer.byteLength,
                  count: idxCount,
                  stride: idxStride
                };
                bufferBlob.addBuffer(indexBuffer);
              }

              var minPosition = geometry.minPos;

              if (!minPosition && options.calculateBounds) {
                minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);

                for (var iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1$1, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.min(minPosition, minPosition, v3_1$1);
                }
              }

              var maxPosition = geometry.maxPos;

              if (!maxPosition && options.calculateBounds) {
                maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);

                for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) {
                  Vec3.set(v3_1$1, positions[_iVertex * 3 + 0], positions[_iVertex * 3 + 1], positions[_iVertex * 3 + 2]);
                  Vec3.max(maxPosition, maxPosition, v3_1$1);
                }
              }

              var meshStruct = {
                vertexBundles: [vertexBundle],
                primitives: [primitive]
              };

              if (minPosition) {
                meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
              }

              if (maxPosition) {
                meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
              }

              if (!out) {
                out = new Mesh();
              }

              out.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
              });
              return out;
            }

            var utils = /*#__PURE__*/Object.freeze({
                __proto__: null,
                find: find,
                toPPM: toPPM,
                readMesh: readMesh,
                createMesh: createMesh,
                readBuffer: readBuffer,
                writeBuffer: writeBuffer,
                mapBuffer: mapBuffer
            });
            exports('utils', utils);

            var MorphModel = function (_Model) {
              _inheritsLoose(MorphModel, _Model);

              function MorphModel() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Model.call.apply(_Model, [this].concat(args)) || this;
                _this._morphRenderingInstance = null;
                _this._usedMaterials = new Set();
                return _this;
              }

              var _proto = MorphModel.prototype;

              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                if (this._morphRenderingInstance) {
                  return this._morphRenderingInstance.requiredPatches(subModelIndex);
                } else {
                  return undefined;
                }
              };

              _proto.initSubModel = function initSubModel(subModelIndex, subMeshData, material) {
                return _Model.prototype.initSubModel.call(this, subModelIndex, subMeshData, this._launderMaterial(material));
              };

              _proto.setSubModelMaterial = function setSubModelMaterial(subModelIndex, material) {
                return _Model.prototype.setSubModelMaterial.call(this, subModelIndex, this._launderMaterial(material));
              };

              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _Model.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

                if (this._morphRenderingInstance) {
                  this._morphRenderingInstance.adaptPipelineState(submodelIdx, descriptorSet);
                }
              };

              _proto._launderMaterial = function _launderMaterial(material) {
                return material;
              };

              _proto.setMorphRendering = function setMorphRendering(morphRendering) {
                this._morphRenderingInstance = morphRendering;
              };

              return MorphModel;
            }(Model);

            var _dec$1, _dec2, _class$1, _class2$1, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4, _descriptor5, _descriptor6, _temp$1, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _class4, _class5, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _class6, _temp2;
            var ModelShadowCastingMode = Enum({
              OFF: 0,
              ON: 1
            });
            var ModelShadowReceivingMode = Enum({
              OFF: 0,
              ON: 1
            });
            var ModelLightmapSettings = (_dec$1 = ccclass('cc.ModelLightmapSettings'), _dec2 = formerlySerializedAs('_recieveShadow'), _dec$1(_class$1 = (_class2$1 = (_temp$1 = function () {
              function ModelLightmapSettings() {
                _initializerDefineProperty(this, "texture", _descriptor$1, this);

                _initializerDefineProperty(this, "uvParam", _descriptor2$1, this);

                _initializerDefineProperty(this, "_bakeable", _descriptor3$1, this);

                _initializerDefineProperty(this, "_castShadow", _descriptor4, this);

                _initializerDefineProperty(this, "_receiveShadow", _descriptor5, this);

                _initializerDefineProperty(this, "_lightmapSize", _descriptor6, this);
              }

              _createClass(ModelLightmapSettings, [{
                key: "bakeable",
                get: function get() {
                  return this._bakeable;
                },
                set: function set(val) {
                  this._bakeable = val;
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;
                }
              }, {
                key: "lightmapSize",
                get: function get() {
                  return this._lightmapSize;
                },
                set: function set(val) {
                  this._lightmapSize = val;
                }
              }]);

              return ModelLightmapSettings;
            }(), _temp$1), (_descriptor$1 = _applyDecoratedDescriptor(_class2$1.prototype, "texture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$1.prototype, "uvParam", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec4();
              }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$1.prototype, "_bakeable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2$1.prototype, "_castShadow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor5 = _applyDecoratedDescriptor(_class2$1.prototype, "_receiveShadow", [_dec2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2$1.prototype, "_lightmapSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 64;
              }
            }), _applyDecoratedDescriptor(_class2$1.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "bakeable"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "castShadow"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "receiveShadow", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "receiveShadow"), _class2$1.prototype), _applyDecoratedDescriptor(_class2$1.prototype, "lightmapSize", [editable], Object.getOwnPropertyDescriptor(_class2$1.prototype, "lightmapSize"), _class2$1.prototype)), _class2$1)) || _class$1);
            var MeshRenderer = function (v) { return exports({ MeshRenderer: v, ModelComponent: v }), v; }((_dec3 = ccclass('cc.MeshRenderer'), _dec4 = help(), _dec5 = executionOrder(100), _dec6 = menu(), _dec7 = type(ModelShadowCastingMode), _dec8 = tooltip(), _dec9 = type(ModelShadowReceivingMode), _dec10 = tooltip(), _dec11 = type(Mesh), _dec12 = tooltip(), _dec13 = visible(), _dec3(_class4 = _dec4(_class4 = _dec5(_class4 = _dec6(_class4 = executeInEditMode(_class4 = (_class5 = (_temp2 = _class6 = function (_RenderableComponent) {
              _inheritsLoose(MeshRenderer, _RenderableComponent);

              _createClass(MeshRenderer, [{
                key: "shadowCastingMode",
                get: function get() {
                  return this._shadowCastingMode;
                },
                set: function set(val) {
                  this._shadowCastingMode = val;

                  this._updateCastShadow();
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._shadowReceivingMode;
                },
                set: function set(val) {
                  this._shadowReceivingMode = val;

                  this._updateReceiveShadow();
                }
              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(val) {
                  var old = this._mesh;
                  this._mesh = val;

                  if (this._mesh) {
                    this._mesh.initialize();
                  }

                  this._watchMorphInMesh();

                  this._onMeshChanged(old);

                  this._updateModels();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }

                  this._updateCastShadow();

                  this._updateReceiveShadow();
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }, {
                key: "enableMorph",
                get: function get() {
                  return this._enableMorph;
                },
                set: function set(value) {
                  this._enableMorph = value;
                }
              }]);

              function MeshRenderer() {
                var _this;

                _this = _RenderableComponent.call(this) || this;

                _initializerDefineProperty(_this, "lightmapSettings", _descriptor7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_mesh", _descriptor8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_shadowReceivingMode", _descriptor10, _assertThisInitialized(_this));

                _this._modelType = void 0;
                _this._model = null;
                _this._morphInstance = null;

                _initializerDefineProperty(_this, "_enableMorph", _descriptor11, _assertThisInitialized(_this));

                _this._modelType = Model;
                return _this;
              }

              var _proto = MeshRenderer.prototype;

              _proto.onLoad = function onLoad() {
                if (this._mesh) {
                  this._mesh.initialize();
                }

                this._watchMorphInMesh();

                this._updateModels();

                this._updateCastShadow();

                this._updateReceiveShadow();
              };

              _proto.onRestore = function onRestore() {
                this._updateModels();

                this._updateCastShadow();

                this._updateReceiveShadow();
              };

              _proto.onEnable = function onEnable() {
                if (!this._model) {
                  this._updateModels();
                }

                this._attachToScene();
              };

              _proto.onDisable = function onDisable() {
                if (this._model) {
                  this._detachFromScene();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;
                }

                if (this._morphInstance) {
                  this._morphInstance.destroy();
                }
              };

              _proto.setWeights = function setWeights(weights, subMeshIndex) {
                if (this._morphInstance) {
                  this._morphInstance.setWeights(subMeshIndex, weights);
                }
              };

              _proto.setInstancedAttribute = function setInstancedAttribute(name, value) {
                if (!this.model) {
                  return;
                }

                var _this$model$instanced = this.model.instancedAttributes,
                    attributes = _this$model$instanced.attributes,
                    views = _this$model$instanced.views;

                for (var i = 0; i < attributes.length; i++) {
                  if (attributes[i].name === name) {
                    views[i].set(value);
                    break;
                  }
                }
              };

              _proto._updateLightmap = function _updateLightmap(lightmap, uOff, vOff, uScale, vScale) {
                this.lightmapSettings.texture = lightmap;
                this.lightmapSettings.uvParam.x = uOff;
                this.lightmapSettings.uvParam.y = vOff;
                this.lightmapSettings.uvParam.z = uScale;
                this.lightmapSettings.uvParam.w = vScale;

                this._onUpdateLightingmap();
              };

              _proto._updateModels = function _updateModels() {
                if (!this.enabledInHierarchy || !this._mesh) {
                  return;
                }

                var model = this._model;

                if (model) {
                  model.destroy();
                  model.initialize();
                  model.node = model.transform = this.node;
                } else {
                  this._createModel();
                }

                if (this._model) {
                  this._model.createBoundingShape(this._mesh.struct.minPosition, this._mesh.struct.maxPosition);

                  this._updateModelParams();

                  this._onUpdateLightingmap();
                }
              };

              _proto._createModel = function _createModel() {
                var preferMorphOverPlain = !!this._morphInstance;
                var modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
                var model = this._model = legacyCC.director.root.createModel(modelType);
                model.visFlags = this.visibility;
                model.node = model.transform = this.node;
                this._models.length = 0;

                this._models.push(this._model);

                if (this._morphInstance && model instanceof MorphModel) {
                  model.setMorphRendering(this._morphInstance);
                }
              };

              _proto._attachToScene = function _attachToScene() {
                if (!this.node.scene || !this._model) {
                  return;
                }

                var renderScene = this._getRenderScene();

                if (this._model.scene !== null) {
                  this._detachFromScene();
                }

                renderScene.addModel(this._model);
              };

              _proto._detachFromScene = function _detachFromScene() {
                if (this._model && this._model.scene) {
                  this._model.scene.removeModel(this._model);
                }
              };

              _proto._updateModelParams = function _updateModelParams() {
                if (!this._mesh || !this._model) {
                  return;
                }

                this.node.hasChangedFlags |= TransformBit.POSITION;
                this._model.transform.hasChangedFlags |= TransformBit.POSITION;
                this._model.isDynamicBatching = this._isBatchingEnabled();
                var meshCount = this._mesh ? this._mesh.renderingSubMeshes.length : 0;
                var renderingMesh = this._mesh.renderingSubMeshes;

                if (renderingMesh) {
                  for (var i = 0; i < meshCount; ++i) {
                    var material = this.getRenderMaterial(i);

                    if (material && !material.isValid) {
                      material = null;
                    }

                    var subMeshData = renderingMesh[i];

                    if (subMeshData) {
                      this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                    }
                  }
                }

                this._model.enabled = true;
              };

              _proto._onUpdateLightingmap = function _onUpdateLightingmap() {
                if (this.model !== null) {
                  this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam);
                }

                this.setInstancedAttribute('a_lightingMapUVParam', [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w]);
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }

                this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
              };

              _proto._onRebuildPSO = function _onRebuildPSO(idx, material) {
                if (!this._model || !this._model.inited) {
                  return;
                }

                this._model.isDynamicBatching = this._isBatchingEnabled();

                this._model.setSubModelMaterial(idx, material);

                this._onUpdateLightingmap();
              };

              _proto._onMeshChanged = function _onMeshChanged(old) {};

              _proto._clearMaterials = function _clearMaterials() {
                if (!this._model) {
                  return;
                }

                var subModels = this._model.subModels;

                for (var i = 0; i < subModels.length; ++i) {
                  this._onMaterialModified(i, null);
                }
              };

              _proto._getBuiltinMaterial = function _getBuiltinMaterial() {
                return builtinResMgr.get('missing-material');
              };

              _proto._onVisibilityChange = function _onVisibilityChange(val) {
                if (!this._model) {
                  return;
                }

                this._model.visFlags = val;
              };

              _proto._updateCastShadow = function _updateCastShadow() {
                if (!this._model) {
                  return;
                }

                if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
                  this._model.castShadow = false;
                } else {
                  assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, "ShadowCastingMode " + this._shadowCastingMode + " is not supported.");
                  this._model.castShadow = true;
                }
              };

              _proto._updateReceiveShadow = function _updateReceiveShadow() {
                if (!this._model) {
                  return;
                }

                if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
                  this._model.receiveShadow = false;
                } else {
                  this._model.receiveShadow = true;
                }
              };

              _proto._isBatchingEnabled = function _isBatchingEnabled() {
                for (var i = 0; i < this._materials.length; ++i) {
                  var mat = this._materials[i];

                  if (!mat) {
                    continue;
                  }

                  for (var p = 0; p < mat.passes.length; ++p) {
                    var pass = mat.passes[p];

                    if (pass.batchingScheme) {
                      return true;
                    }
                  }
                }

                return false;
              };

              _proto._watchMorphInMesh = function _watchMorphInMesh() {
                if (this._morphInstance) {
                  this._morphInstance.destroy();

                  this._morphInstance = null;
                }

                if (!this._enableMorph) {
                  return;
                }

                if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
                  return;
                }

                var morph = this._mesh.struct.morph;
                this._morphInstance = this._mesh.morphRendering.createInstance();
                var nSubMeshes = this._mesh.struct.primitives.length;

                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var subMeshMorph = morph.subMeshMorphs[iSubMesh];

                  if (!subMeshMorph) {
                    continue;
                  }

                  var initialWeights = subMeshMorph.weights || morph.weights;
                  var weights = initialWeights ? initialWeights.slice() : new Array(subMeshMorph.targets.length).fill(0);

                  this._morphInstance.setWeights(iSubMesh, weights);
                }

                if (this._model && this._model instanceof MorphModel) {
                  this._model.setMorphRendering(this._morphInstance);
                }
              };

              _proto._syncMorphWeights = function _syncMorphWeights(subMeshIndex) {
                if (!this._morphInstance) {
                  return;
                }

                var subMeshMorphInstance = this._morphInstance[subMeshIndex];

                if (!subMeshMorphInstance || !subMeshMorphInstance.renderResources) {
                  return;
                }

                subMeshMorphInstance.renderResources.setWeights(subMeshMorphInstance.weights);
              };

              return MeshRenderer;
            }(RenderableComponent), _class6.ShadowCastingMode = ModelShadowCastingMode, _class6.ShadowReceivingMode = ModelShadowReceivingMode, _temp2), (_descriptor7 = _applyDecoratedDescriptor(_class5.prototype, "lightmapSettings", [serializable, editable, disallowAnimation], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new ModelLightmapSettings();
              }
            }), _descriptor8 = _applyDecoratedDescriptor(_class5.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor9 = _applyDecoratedDescriptor(_class5.prototype, "_shadowCastingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ModelShadowCastingMode.OFF;
              }
            }), _descriptor10 = _applyDecoratedDescriptor(_class5.prototype, "_shadowReceivingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ModelShadowReceivingMode.ON;
              }
            }), _applyDecoratedDescriptor(_class5.prototype, "shadowCastingMode", [_dec7, _dec8, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "shadowCastingMode"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "receiveShadow", [_dec9, _dec10, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "receiveShadow"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "mesh", [_dec11, _dec12], Object.getOwnPropertyDescriptor(_class5.prototype, "mesh"), _class5.prototype), _applyDecoratedDescriptor(_class5.prototype, "enableMorph", [_dec13, disallowAnimation], Object.getOwnPropertyDescriptor(_class5.prototype, "enableMorph"), _class5.prototype), _descriptor11 = _applyDecoratedDescriptor(_class5.prototype, "_enableMorph", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            })), _class5)) || _class4) || _class4) || _class4) || _class4) || _class4));

            function checkMaterialisSame(comp1, comp2) {
              var matNum = comp1.sharedMaterials.length;

              if (matNum !== comp2.sharedMaterials.length) {
                return false;
              }

              for (var i = 0; i < matNum; i++) {
                if (comp1.getRenderMaterial(i) !== comp2.getRenderMaterial(i)) {
                  return false;
                }
              }

              return true;
            }

            var BatchingUtility = exports('BatchingUtility', function () {
              function BatchingUtility() {}

              BatchingUtility.batchStaticModel = function batchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren(MeshRenderer);

                if (models.length < 2) {
                  console.error('the number of static models to batch is less than 2,it needn\'t batch.');
                  return false;
                }

                for (var i = 1; i < models.length; i++) {
                  if (!models[0].mesh.validateMergingMesh(models[i].mesh)) {
                    console.error("the meshes of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }

                  if (!checkMaterialisSame(models[0], models[i])) {
                    console.error("the materials of " + models[0].node.name + " and " + models[i].node.name + " can't be merged");
                    return false;
                  }
                }

                var batchedMesh = new Mesh();
                var worldMat = new Mat4();
                var rootWorldMatInv = new Mat4();
                staticModelRoot.getWorldMatrix(rootWorldMatInv);
                Mat4.invert(rootWorldMatInv, rootWorldMatInv);

                for (var _i = 0; _i < models.length; _i++) {
                  var comp = models[_i];
                  comp.node.getWorldMatrix(worldMat);
                  Mat4.multiply(worldMat, rootWorldMatInv, worldMat);
                  batchedMesh.merge(models[_i].mesh, worldMat);
                  comp.enabled = false;
                }

                var batchedModel = batchedRoot.addComponent(MeshRenderer);
                batchedModel.mesh = batchedMesh;
                batchedModel.sharedMaterials = models[0].sharedMaterials;
                return true;
              };

              BatchingUtility.unbatchStaticModel = function unbatchStaticModel(staticModelRoot, batchedRoot) {
                var models = staticModelRoot.getComponentsInChildren('cc.MeshRenderer');

                for (var i = 0; i < models.length; i++) {
                  var comp = models[i];
                  comp.enabled = true;
                }

                var batchedModel = batchedRoot.getComponent('cc.MeshRenderer');

                if (batchedModel) {
                  batchedModel.destroy();
                }

                return true;
              };

              return BatchingUtility;
            }());

            replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'renderingMesh',
              newName: 'renderingSubMeshes'
            }]);
            removeProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'hasFlatBuffers'
            }, {
              name: 'destroyFlatBuffers'
            }]);

            var _dec$2, _dec2$1, _dec3$1, _class$2, _class2$2, _descriptor$2, _descriptor2$2, _descriptor3$2, _temp$2;
            var Skeleton = exports('Skeleton', (_dec$2 = ccclass('cc.Skeleton'), _dec2$1 = type([CCString]), _dec3$1 = type([Mat4]), _dec$2(_class$2 = (_class2$2 = (_temp$2 = function (_Asset) {
              _inheritsLoose(Skeleton, _Asset);

              function Skeleton() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_joints", _descriptor$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_bindposes", _descriptor2$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_hash", _descriptor3$2, _assertThisInitialized(_this));

                _this._invBindposes = null;
                return _this;
              }

              var _proto = Skeleton.prototype;

              _proto.destroy = function destroy() {
                legacyCC.director.root.dataPoolManager.releaseSkeleton(this);
                return _Asset.prototype.destroy.call(this);
              };

              _createClass(Skeleton, [{
                key: "joints",
                get: function get() {
                  return this._joints;
                },
                set: function set(value) {
                  this._joints = value;
                }
              }, {
                key: "bindposes",
                get: function get() {
                  return this._bindposes;
                },
                set: function set(value) {
                  this._bindposes = value;
                }
              }, {
                key: "inverseBindposes",
                get: function get() {
                  if (!this._invBindposes) {
                    this._invBindposes = [];

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var inv = new Mat4();
                      Mat4.invert(inv, this._bindposes[i]);

                      this._invBindposes.push(inv);
                    }
                  }

                  return this._invBindposes;
                }
              }, {
                key: "hash",
                get: function get() {
                  if (!this._hash) {
                    var str = '';

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var ibm = this._bindposes[i];
                      str += ibm.m00.toPrecision(2) + " " + ibm.m01.toPrecision(2) + " " + ibm.m02.toPrecision(2) + " " + ibm.m03.toPrecision(2) + " " + ibm.m04.toPrecision(2) + " " + ibm.m05.toPrecision(2) + " " + ibm.m06.toPrecision(2) + " " + ibm.m07.toPrecision(2) + " " + ibm.m08.toPrecision(2) + " " + ibm.m09.toPrecision(2) + " " + ibm.m10.toPrecision(2) + " " + ibm.m11.toPrecision(2) + " " + ibm.m12.toPrecision(2) + " " + ibm.m13.toPrecision(2) + " " + ibm.m14.toPrecision(2) + " " + ibm.m15.toPrecision(2) + "\n";
                    }

                    this._hash = murmurhash2_32_gc(str, 666);
                  }

                  return this._hash;
                }
              }]);

              return Skeleton;
            }(Asset), _temp$2), (_descriptor$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_joints", [_dec2$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_bindposes", [_dec3$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$2.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$2)) || _class$2));
            legacyCC.Skeleton = Skeleton;

            removeProperty(MeshRenderer.prototype, 'MeshRenderer.prototype', [{
              name: 'enableDynamicBatching'
            }, {
              name: 'recieveShadows'
            }]);
            legacyCC.ModelComponent = MeshRenderer;
            js.setClassAlias(MeshRenderer, 'cc.ModelComponent');

            var _dec$3, _class$3, _class2$3, _descriptor$3, _descriptor2$3, _descriptor3$3, _descriptor4$1, _temp$3, _dec2$2, _dec3$2, _dec4$1, _dec5$1, _dec6$1, _dec7$1, _class4$1, _class5$1, _descriptor5$1, _descriptor6$1, _descriptor7$1, _descriptor8$1, _class6$1, _temp2$1;
            var PhotometricTerm = Enum({
              LUMINOUS_POWER: 0,
              LUMINANCE: 1
            });

            var _color_tmp = new Vec3();

            var StaticLightSettings = (_dec$3 = ccclass('cc.StaticLightSettings'), _dec$3(_class$3 = (_class2$3 = (_temp$3 = function () {
              function StaticLightSettings() {
                _initializerDefineProperty(this, "_baked", _descriptor$3, this);

                _initializerDefineProperty(this, "_editorOnly", _descriptor2$3, this);

                _initializerDefineProperty(this, "_bakeable", _descriptor3$3, this);

                _initializerDefineProperty(this, "_castShadow", _descriptor4$1, this);
              }

              _createClass(StaticLightSettings, [{
                key: "editorOnly",
                get: function get() {
                  return this._editorOnly;
                },
                set: function set(val) {
                  this._editorOnly = val;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this._baked;
                },
                set: function set(val) {
                  this._baked = val;
                }
              }, {
                key: "bakeable",
                get: function get() {
                  return this._bakeable;
                },
                set: function set(val) {
                  this._bakeable = val;
                }
              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
              }]);

              return StaticLightSettings;
            }(), _temp$3), (_descriptor$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_baked", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_editorOnly", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$3.prototype, "_bakeable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$3.prototype, "_castShadow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$3.prototype, "editorOnly", [editable], Object.getOwnPropertyDescriptor(_class2$3.prototype, "editorOnly"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$3.prototype, "bakeable"), _class2$3.prototype), _applyDecoratedDescriptor(_class2$3.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$3.prototype, "castShadow"), _class2$3.prototype)), _class2$3)) || _class$3);
            var Light = function (v) { return exports({ Light: v, LightComponent: v }), v; }((_dec2$2 = ccclass('cc.Light'), _dec3$2 = tooltip(), _dec4$1 = tooltip(), _dec5$1 = range(), _dec6$1 = tooltip(), _dec7$1 = type(StaticLightSettings), _dec2$2(_class4$1 = (_class5$1 = (_temp2$1 = _class6$1 = function (_Component) {
              _inheritsLoose(Light, _Component);

              _createClass(Light, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(val) {
                  this._color = val;

                  if (this._light) {
                    _color_tmp.x = val.r / 255.0;
                    _color_tmp.y = val.g / 255.0;
                    _color_tmp.z = val.b / 255.0;
                    this._light.color = _color_tmp;
                  }
                }
              }, {
                key: "useColorTemperature",
                get: function get() {
                  return this._useColorTemperature;
                },
                set: function set(enable) {
                  this._useColorTemperature = enable;

                  if (this._light) {
                    this._light.useColorTemperature = enable;
                  }
                }
              }, {
                key: "colorTemperature",
                get: function get() {
                  return this._colorTemperature;
                },
                set: function set(val) {
                  this._colorTemperature = val;

                  if (this._light) {
                    this._light.colorTemperature = val;
                  }
                }
              }, {
                key: "staticSettings",
                get: function get() {
                  return this._staticSettings;
                },
                set: function set(val) {
                  this._staticSettings = val;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "baked",
                get: function get() {
                  return this.staticSettings.baked;
                },
                set: function set(val) {
                  this.staticSettings.baked = val;

                  if (this._light !== null) {
                    this._light.baked = val;
                  }
                }
              }]);

              function Light() {
                var _this;

                _this = _Component.call(this) || this;

                _initializerDefineProperty(_this, "_color", _descriptor5$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_useColorTemperature", _descriptor6$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_colorTemperature", _descriptor7$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_staticSettings", _descriptor8$1, _assertThisInitialized(_this));

                _this._type = LightType.UNKNOWN;
                _this._lightType = void 0;
                _this._light = null;
                _this._lightType = Light$1;
                return _this;
              }

              var _proto = Light.prototype;

              _proto.onLoad = function onLoad() {
                this._createLight();
              };

              _proto.onEnable = function onEnable() {
                this._attachToScene();
              };

              _proto.onDisable = function onDisable() {
                this._detachFromScene();
              };

              _proto.onDestroy = function onDestroy() {
                this._destroyLight();
              };

              _proto._createLight = function _createLight() {
                if (!this._light) {
                  this._light = legacyCC.director.root.createLight(this._lightType);
                }

                this.color = this._color;
                this.useColorTemperature = this._useColorTemperature;
                this.colorTemperature = this._colorTemperature;
                this._light.node = this.node;
                this._light.baked = this.baked;
              };

              _proto._destroyLight = function _destroyLight() {
                if (this._light) {
                  legacyCC.director.root.destroyLight(this);
                  this._light = null;
                }
              };

              _proto._attachToScene = function _attachToScene() {
                this._detachFromScene();

                if (this._light && !this._light.scene && this.node.scene) {
                  var renderScene = this._getRenderScene();

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.addDirectionalLight(this._light);
                      renderScene.setMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.addSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.addSpotLight(this._light);
                      break;
                  }
                }
              };

              _proto._detachFromScene = function _detachFromScene() {
                if (this._light && this._light.scene) {
                  var renderScene = this._light.scene;

                  switch (this._type) {
                    case LightType.DIRECTIONAL:
                      renderScene.removeDirectionalLight(this._light);
                      renderScene.unsetMainLight(this._light);
                      break;

                    case LightType.SPHERE:
                      renderScene.removeSphereLight(this._light);
                      break;

                    case LightType.SPOT:
                      renderScene.removeSpotLight(this._light);
                      break;
                  }
                }
              };

              return Light;
            }(Component), _class6$1.Type = LightType, _class6$1.PhotometricTerm = PhotometricTerm, _temp2$1), (_descriptor5$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.WHITE.clone();
              }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_useColorTemperature", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor7$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_colorTemperature", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 6550;
              }
            }), _descriptor8$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_staticSettings", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new StaticLightSettings();
              }
            }), _applyDecoratedDescriptor(_class5$1.prototype, "color", [_dec3$2], Object.getOwnPropertyDescriptor(_class5$1.prototype, "color"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "useColorTemperature", [_dec4$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "useColorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "colorTemperature", [slide, _dec5$1, _dec6$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "colorTemperature"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "staticSettings", [_dec7$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "staticSettings"), _class5$1.prototype)), _class5$1)) || _class4$1));

            var _dec$4, _dec2$3, _dec3$3, _dec4$2, _dec5$2, _class$4, _class2$4, _descriptor$4, _temp$4;
            var DirectionalLight = function (v) { return exports({ DirectionalLight: v, DirectionalLightComponent: v }), v; }((_dec$4 = ccclass('cc.DirectionalLight'), _dec2$3 = help(), _dec3$3 = menu(), _dec4$2 = unit(), _dec5$2 = tooltip(), _dec$4(_class$4 = _dec2$3(_class$4 = _dec3$3(_class$4 = executeInEditMode(_class$4 = (_class2$4 = (_temp$4 = function (_Light) {
              _inheritsLoose(DirectionalLight, _Light);

              _createClass(DirectionalLight, [{
                key: "illuminance",
                get: function get() {
                  return this._illuminance;
                },
                set: function set(val) {
                  this._illuminance = val;

                  if (this._light) {
                    this._light.illuminance = this._illuminance;
                  }
                }
              }]);

              function DirectionalLight() {
                var _this;

                _this = _Light.call(this) || this;

                _initializerDefineProperty(_this, "_illuminance", _descriptor$4, _assertThisInitialized(_this));

                _this._type = LightType.DIRECTIONAL;
                _this._light = null;
                _this._lightType = DirectionalLight$1;
                return _this;
              }

              var _proto = DirectionalLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                if (!this._light) {
                  return;
                }

                this.illuminance = this._illuminance;
              };

              return DirectionalLight;
            }(Light), _temp$4), (_descriptor$4 = _applyDecoratedDescriptor(_class2$4.prototype, "_illuminance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 65000;
              }
            }), _applyDecoratedDescriptor(_class2$4.prototype, "illuminance", [_dec4$2, _dec5$2], Object.getOwnPropertyDescriptor(_class2$4.prototype, "illuminance"), _class2$4.prototype)), _class2$4)) || _class$4) || _class$4) || _class$4) || _class$4));

            var _dec$5, _dec2$4, _dec3$4, _dec4$3, _dec5$3, _dec6$2, _dec7$2, _dec8$1, _dec9$1, _dec10$1, _dec11$1, _class$5, _class2$5, _descriptor$5, _descriptor2$4, _descriptor3$4, _descriptor4$2, _temp$5;
            var SphereLight = function (v) { return exports({ SphereLight: v, SphereLightComponent: v }), v; }((_dec$5 = ccclass('cc.SphereLight'), _dec2$4 = help(), _dec3$4 = menu(), _dec4$3 = unit(), _dec5$3 = tooltip(), _dec6$2 = unit(), _dec7$2 = tooltip(), _dec8$1 = type(PhotometricTerm), _dec9$1 = tooltip(), _dec10$1 = tooltip(), _dec11$1 = tooltip(), _dec$5(_class$5 = _dec2$4(_class$5 = _dec3$4(_class$5 = executeInEditMode(_class$5 = (_class2$5 = (_temp$5 = function (_Light) {
              _inheritsLoose(SphereLight, _Light);

              _createClass(SphereLight, [{
                key: "luminousPower",
                get: function get() {
                  return this._luminance * nt2lm(this._size);
                },
                set: function set(val) {
                  this._luminance = val / nt2lm(this._size);

                  if (this._light) {
                    this._light.luminance = this._luminance;
                  }
                }
              }, {
                key: "luminance",
                get: function get() {
                  return this._luminance;
                },
                set: function set(val) {
                  this._luminance = val;

                  if (this._light) {
                    this._light.luminance = val;
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;

                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;

                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }]);

              function SphereLight() {
                var _this;

                _this = _Light.call(this) || this;

                _initializerDefineProperty(_this, "_size", _descriptor$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_luminance", _descriptor2$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_term", _descriptor3$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_range", _descriptor4$2, _assertThisInitialized(_this));

                _this._type = LightType.SPHERE;
                _this._light = null;
                _this._lightType = SphereLight$1;
                return _this;
              }

              var _proto = SphereLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                if (!this._light) {
                  return;
                }

                this.luminance = this._luminance;
                this.size = this._size;
                this.range = this._range;
              };

              return SphereLight;
            }(Light), _temp$5), (_descriptor$5 = _applyDecoratedDescriptor(_class2$5.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.15;
              }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_luminance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1700 / nt2lm(0.15);
              }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_term", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return PhotometricTerm.LUMINOUS_POWER;
              }
            }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$5.prototype, "_range", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _applyDecoratedDescriptor(_class2$5.prototype, "luminousPower", [_dec4$3, _dec5$3], Object.getOwnPropertyDescriptor(_class2$5.prototype, "luminousPower"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "luminance", [_dec6$2, _dec7$2], Object.getOwnPropertyDescriptor(_class2$5.prototype, "luminance"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "term", [_dec8$1, _dec9$1], Object.getOwnPropertyDescriptor(_class2$5.prototype, "term"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "size", [_dec10$1], Object.getOwnPropertyDescriptor(_class2$5.prototype, "size"), _class2$5.prototype), _applyDecoratedDescriptor(_class2$5.prototype, "range", [_dec11$1], Object.getOwnPropertyDescriptor(_class2$5.prototype, "range"), _class2$5.prototype)), _class2$5)) || _class$5) || _class$5) || _class$5) || _class$5));

            var _dec$6, _dec2$5, _dec3$5, _dec4$4, _dec5$4, _dec6$3, _dec7$3, _dec8$2, _dec9$2, _dec10$2, _dec11$2, _dec12$1, _dec13$1, _class$6, _class2$6, _descriptor$6, _descriptor2$5, _descriptor3$5, _descriptor4$3, _descriptor5$2, _temp$6;
            var SpotLight = function (v) { return exports({ SpotLight: v, SpotLightComponent: v }), v; }((_dec$6 = ccclass('cc.SpotLight'), _dec2$5 = help(), _dec3$5 = menu(), _dec4$4 = unit(), _dec5$4 = tooltip(), _dec6$3 = unit(), _dec7$3 = tooltip(), _dec8$2 = type(PhotometricTerm), _dec9$2 = tooltip(), _dec10$2 = tooltip(), _dec11$2 = tooltip(), _dec12$1 = range(), _dec13$1 = tooltip(), _dec$6(_class$6 = _dec2$5(_class$6 = _dec3$5(_class$6 = executeInEditMode(_class$6 = (_class2$6 = (_temp$6 = function (_Light) {
              _inheritsLoose(SpotLight, _Light);

              _createClass(SpotLight, [{
                key: "luminousPower",
                get: function get() {
                  return this._luminance * nt2lm(this._size);
                },
                set: function set(val) {
                  this._luminance = val / nt2lm(this._size);

                  if (this._light) {
                    this._light.luminance = this._luminance;
                  }
                }
              }, {
                key: "luminance",
                get: function get() {
                  return this._luminance;
                },
                set: function set(val) {
                  this._luminance = val;

                  if (this._light) {
                    this._light.luminance = val;
                  }
                }
              }, {
                key: "term",
                get: function get() {
                  return this._term;
                },
                set: function set(val) {
                  this._term = val;
                }
              }, {
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(val) {
                  this._size = val;

                  if (this._light) {
                    this._light.size = val;
                  }
                }
              }, {
                key: "range",
                get: function get() {
                  return this._range;
                },
                set: function set(val) {
                  this._range = val;

                  if (this._light) {
                    this._light.range = val;
                  }
                }
              }, {
                key: "spotAngle",
                get: function get() {
                  return this._spotAngle;
                },
                set: function set(val) {
                  this._spotAngle = val;

                  if (this._light) {
                    this._light.spotAngle = toRadian(val);
                  }
                }
              }]);

              function SpotLight() {
                var _this;

                _this = _Light.call(this) || this;

                _initializerDefineProperty(_this, "_size", _descriptor$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_luminance", _descriptor2$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_term", _descriptor3$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_range", _descriptor4$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spotAngle", _descriptor5$2, _assertThisInitialized(_this));

                _this._type = LightType.SPOT;
                _this._light = null;
                _this._lightType = SpotLight$1;
                return _this;
              }

              var _proto = SpotLight.prototype;

              _proto._createLight = function _createLight() {
                _Light.prototype._createLight.call(this);

                if (!this._light) {
                  return;
                }

                this.luminance = this._luminance;
                this.size = this._size;
                this.range = this._range;
                this.spotAngle = this._spotAngle;
              };

              return SpotLight;
            }(Light), _temp$6), (_descriptor$6 = _applyDecoratedDescriptor(_class2$6.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.15;
              }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$6.prototype, "_luminance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1700 / nt2lm(0.15);
              }
            }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$6.prototype, "_term", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return PhotometricTerm.LUMINOUS_POWER;
              }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$6.prototype, "_range", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$6.prototype, "_spotAngle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 60;
              }
            }), _applyDecoratedDescriptor(_class2$6.prototype, "luminousPower", [_dec4$4, _dec5$4], Object.getOwnPropertyDescriptor(_class2$6.prototype, "luminousPower"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "luminance", [_dec6$3, _dec7$3], Object.getOwnPropertyDescriptor(_class2$6.prototype, "luminance"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "term", [_dec8$2, _dec9$2], Object.getOwnPropertyDescriptor(_class2$6.prototype, "term"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "size", [_dec10$2], Object.getOwnPropertyDescriptor(_class2$6.prototype, "size"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "range", [_dec11$2], Object.getOwnPropertyDescriptor(_class2$6.prototype, "range"), _class2$6.prototype), _applyDecoratedDescriptor(_class2$6.prototype, "spotAngle", [slide, _dec12$1, _dec13$1], Object.getOwnPropertyDescriptor(_class2$6.prototype, "spotAngle"), _class2$6.prototype)), _class2$6)) || _class$6) || _class$6) || _class$6) || _class$6));

            legacyCC.LightComponent = Light;
            js.setClassAlias(Light, 'cc.LightComponent');
            legacyCC.DirectionalLightComponent = DirectionalLight;
            js.setClassAlias(DirectionalLight, 'cc.DirectionalLightComponent');
            legacyCC.SphereLightComponent = SphereLight;
            js.setClassAlias(SphereLight, 'cc.SphereLightComponent');
            legacyCC.SpotLightComponent = SpotLight;
            js.setClassAlias(SpotLight, 'cc.SpotLightComponent');

            var uploadJointData = uploadJointDataLBS;
            var MINIMUM_JOINT_TEXTURE_SIZE =  480;
            function selectJointsMediumFormat(device) {
              if (device.hasFeature(Feature.TEXTURE_FLOAT)) {
                return Format.RGBA32F;
              }

              return Format.RGBA8;
            }

            function uploadJointDataLBS(out, base, mat, firstBone) {
              out[base + 0] = mat.m00;
              out[base + 1] = mat.m01;
              out[base + 2] = mat.m02;
              out[base + 3] = mat.m12;
              out[base + 4] = mat.m04;
              out[base + 5] = mat.m05;
              out[base + 6] = mat.m06;
              out[base + 7] = mat.m13;
              out[base + 8] = mat.m08;
              out[base + 9] = mat.m09;
              out[base + 10] = mat.m10;
              out[base + 11] = mat.m14;
            }

            var dq_0 = new Quat();
            var dq_1 = new Quat();
            var v3_1$2 = new Vec3();
            var qt_1 = new Quat();
            var v3_2$1 = new Vec3();

            function roundUpTextureSize(targetLength, formatSize) {
              var formatScale = 4 / Math.sqrt(formatSize);
              return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
            }

            var jointTextureSamplerHash = genSamplerHash([Filter.POINT, Filter.POINT, Filter.NONE, Address.CLAMP, Address.CLAMP, Address.CLAMP]);
            var v3_3 = new Vec3();
            var v3_4 = new Vec3();
            var v3_min = new Vec3();
            var v3_max = new Vec3();
            var m4_1 = new Mat4();
            var m4_2 = new Mat4();
            var ab_1 = new AABB();
            var Inf = Number.MAX_SAFE_INTEGER;
            var JointTexturePool = function () {
              _createClass(JointTexturePool, [{
                key: "pixelsPerJoint",
                get: function get() {
                  return this._pixelsPerJoint;
                }
              }]);

              function JointTexturePool(device) {
                this._device = void 0;
                this._pool = void 0;
                this._textureBuffers = new Map();
                this._formatSize = void 0;
                this._pixelsPerJoint = void 0;
                this._customPool = void 0;
                this._chunkIdxMap = new Map();
                this._device = device;
                var format = selectJointsMediumFormat(this._device);
                this._formatSize = FormatInfos[format].size;
                this._pixelsPerJoint = 48 / this._formatSize;
                this._pool = new TextureBufferPool(device);

                this._pool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });

                this._customPool = new TextureBufferPool(device);

                this._customPool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });
              }

              var _proto = JointTexturePool.prototype;

              _proto.clear = function clear() {
                this._pool.destroy();

                this._textureBuffers.clear();
              };

              _proto.registerCustomTextureLayouts = function registerCustomTextureLayouts(layouts) {
                for (var i = 0; i < layouts.length; i++) {
                  var layout = layouts[i];

                  var chunkIdx = this._customPool.createChunk(layout.textureLength);

                  for (var j = 0; j < layout.contents.length; j++) {
                    var content = layout.contents[j];
                    var skeleton = content.skeleton;

                    this._chunkIdxMap.set(skeleton, chunkIdx);

                    for (var k = 0; k < content.clips.length; k++) {
                      var clip = content.clips[k];

                      this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                    }
                  }
                }
              };

              _proto.getDefaultPoseTexture = function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
                var hash = skeleton.hash ^ 0;
                var texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;

                if (!texture) {
                  var bufSize = jointCount * 12;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return texture;
                  }

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: 0,
                    readyToBeDeleted: false,
                    handle: handle
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                Vec3.set(v3_min, Inf, Inf, Inf);
                Vec3.set(v3_max, -Inf, -Inf, -Inf);
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);

                for (var j = 0, offset = 0; j < jointCount; j++, offset += 12) {
                  var node = skinningRoot.getChildByPath(joints[j]);
                  var mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1) : skeleton.inverseBindposes[j];
                  var bound = boneSpaceBounds[j];

                  if (bound) {
                    AABB.transform(ab_1, bound, mat);
                    ab_1.getBoundary(v3_3, v3_4);
                    Vec3.min(v3_min, v3_min, v3_3);
                    Vec3.max(v3_max, v3_max, v3_4);
                  }

                  if (buildTexture) {
                    if (node) {
                      Mat4.multiply(mat, mat, bindposes[j]);
                    }

                    uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
                  }
                }

                var bounds = [new AABB()];
                texture.bounds.set(mesh.hash, bounds);
                AABB.fromPoints(bounds[0], v3_min, v3_max);

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              };

              _proto.getSequencePoseTexture = function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
                var hash = skeleton.hash ^ clip.hash;
                var texture = this._textureBuffers.get(hash) || null;

                if (texture && texture.bounds.has(mesh.hash)) {
                  texture.refCount++;
                  return texture;
                }

                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var clipData = SkelAnimDataHub.getOrExtract(clip);
                var frames = clipData.info.frames;
                var textureBuffer = null;
                var buildTexture = false;
                var jointCount = joints.length;

                if (!texture) {
                  var bufSize = jointCount * 12 * frames;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                  if (!handle) {
                    return null;
                  }

                  var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);

                  texture = {
                    pixelOffset: handle.start / this._formatSize,
                    refCount: 1,
                    bounds: new Map(),
                    skeletonHash: skeleton.hash,
                    clipHash: clip.hash,
                    readyToBeDeleted: false,
                    handle: handle,
                    animInfos: animInfos
                  };
                  textureBuffer = new Float32Array(bufSize);
                  buildTexture = true;
                } else {
                  texture.refCount++;
                }

                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var bounds = [];
                texture.bounds.set(mesh.hash, bounds);

                for (var f = 0; f < frames; f++) {
                  bounds.push(new AABB(Inf, Inf, Inf, -Inf, -Inf, -Inf));
                }

                for (var _f = 0, offset = 0; _f < frames; _f++) {
                  var bound = bounds[_f];

                  for (var j = 0; j < jointCount; j++, offset += 12) {
                    var _j = texture.animInfos[j],
                        curveData = _j.curveData,
                        downstream = _j.downstream,
                        bindposeIdx = _j.bindposeIdx,
                        bindposeCorrection = _j.bindposeCorrection;
                    var mat = void 0;
                    var transformValid = true;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1, curveData[_f], downstream);
                    } else if (curveData) {
                      mat = curveData[_f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = skeleton.inverseBindposes[bindposeIdx];
                      transformValid = false;
                    }

                    var boneSpaceBound = boneSpaceBounds[j];

                    if (boneSpaceBound) {
                      var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                      AABB.transform(ab_1, boneSpaceBound, transform);
                      ab_1.getBoundary(v3_3, v3_4);
                      Vec3.min(bound.center, bound.center, v3_3);
                      Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                    }

                    if (buildTexture) {
                      if (transformValid) {
                        Mat4.multiply(m4_1, mat, bindposes[bindposeIdx]);
                      }

                      uploadJointData(textureBuffer, offset, transformValid ? m4_1 : Mat4.IDENTITY);
                    }
                  }

                  AABB.fromPoints(bound, bound.center, bound.halfExtents);
                }

                if (buildTexture) {
                  this._pool.update(texture.handle, textureBuffer.buffer);

                  this._textureBuffers.set(hash, texture);
                }

                return texture;
              };

              _proto.releaseHandle = function releaseHandle(handle) {
                if (handle.refCount > 0) {
                  handle.refCount--;
                }

                if (!handle.refCount && handle.readyToBeDeleted) {
                  var hash = handle.skeletonHash ^ handle.clipHash;

                  var customChunkIdx = this._chunkIdxMap.get(hash);

                  (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);

                  if (this._textureBuffers.get(hash) === handle) {
                    this._textureBuffers["delete"](hash);
                  }
                }
              };

              _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
                var it = this._textureBuffers.values();

                var res = it.next();

                while (!res.done) {
                  var handle = res.value;

                  if (handle.skeletonHash === skeleton.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              };

              _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
                var it = this._textureBuffers.values();

                var res = it.next();

                while (!res.done) {
                  var handle = res.value;

                  if (handle.clipHash === clip.hash) {
                    handle.readyToBeDeleted = true;

                    if (handle.refCount) {
                      this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                    } else {
                      this.releaseHandle(handle);
                    }
                  }

                  res = it.next();
                }
              };

              _proto._createAnimInfos = function _createAnimInfos(skeleton, clip, skinningRoot) {
                var animInfos = [];
                var joints = skeleton.joints,
                    bindposes = skeleton.bindposes;
                var jointCount = joints.length;
                var clipData = SkelAnimDataHub.getOrExtract(clip);

                for (var j = 0; j < jointCount; j++) {
                  var animPath = joints[j];
                  var source = clipData.data[animPath];
                  var animNode = skinningRoot.getChildByPath(animPath);
                  var downstream = void 0;
                  var correctionPath = void 0;

                  while (!source) {
                    var idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.data[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = new Mat4();
                      }

                      Mat4.fromRTS(m4_1, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1, downstream);
                      animNode = animNode.parent;
                    } else {
                      correctionPath = animPath;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  var bindposeIdx = j;
                  var bindposeCorrection = void 0;

                  if (correctionPath !== undefined && source) {
                    bindposeIdx = j - 1;

                    for (var t = 0; t < jointCount; t++) {
                      if (joints[t] === correctionPath) {
                        bindposeIdx = t;
                        bindposeCorrection = new Mat4();
                        Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                        break;
                      }
                    }
                  }

                  animInfos.push({
                    curveData: source && source.worldMatrix.values,
                    downstream: downstream,
                    bindposeIdx: bindposeIdx,
                    bindposeCorrection: bindposeCorrection
                  });
                }

                return animInfos;
              };

              return JointTexturePool;
            }();
            var JointAnimationInfo = function () {
              function JointAnimationInfo(device) {
                this._pool = new Map();
                this._device = void 0;
                this._device = device;
              }

              var _proto2 = JointAnimationInfo.prototype;

              _proto2.getData = function getData(nodeID) {
                if (nodeID === void 0) {
                  nodeID = '-1';
                }

                var res = this._pool.get(nodeID);

                if (res) {
                  return res;
                }

                var buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinningAnimation.SIZE, UBOSkinningAnimation.SIZE));

                var data = new Float32Array([0, 0, 0, 0]);
                buffer.update(data);
                var info = {
                  buffer: buffer,
                  data: data,
                  dirty: false
                };

                this._pool.set(nodeID, info);

                return info;
              };

              _proto2.destroy = function destroy(nodeID) {
                var info = this._pool.get(nodeID);

                if (!info) {
                  return;
                }

                info.buffer.destroy();

                this._pool["delete"](nodeID);
              };

              _proto2.switchClip = function switchClip(info, clip) {
                info.data[0] = 0;
                info.buffer.update(info.data);
                info.dirty = false;
                return info;
              };

              _proto2.clear = function clear() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._pool.values()), _step; !(_step = _iterator()).done;) {
                  var info = _step.value;
                  info.buffer.destroy();
                }

                this._pool.clear();
              };

              return JointAnimationInfo;
            }();

            var DataPoolManager = function () {
              function DataPoolManager(device) {
                this.jointTexturePool = void 0;
                this.jointAnimationInfo = void 0;
                this.jointTexturePool = new JointTexturePool(device);
                this.jointAnimationInfo = new JointAnimationInfo(device);
              }

              var _proto = DataPoolManager.prototype;

              _proto.releaseSkeleton = function releaseSkeleton(skeleton) {
                this.jointTexturePool.releaseSkeleton(skeleton);
              };

              _proto.releaseAnimationClip = function releaseAnimationClip(clip) {
                this.jointTexturePool.releaseAnimationClip(clip);
              };

              _proto.clear = function clear() {
                this.jointTexturePool.clear();
                this.jointAnimationInfo.clear();
              };

              return DataPoolManager;
            }();
            legacyCC.internal.DataPoolManager = DataPoolManager;

            var myPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }];

            function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
              for (var i = 0; i < jointMaps.length; i++) {
                var idxMap = jointMaps[i];
                var index = -1;

                for (var j = 0; j < idxMap.length; j++) {
                  if (idxMap[j] === targetJoint) {
                    index = j;
                    break;
                  }
                }

                if (index >= 0) {
                  outBuffers.push(i);
                  outIndices.push(index);
                }
              }
            }

            var v3_min$1 = new Vec3();
            var v3_max$1 = new Vec3();
            var v3_1$3 = new Vec3();
            var v3_2$2 = new Vec3();
            var m4_1$1 = new Mat4();
            var ab_1$1 = new AABB();
            var SkinningModel = function (_MorphModel) {
              _inheritsLoose(SkinningModel, _MorphModel);

              function SkinningModel() {
                var _this;

                _this = _MorphModel.call(this) || this;
                _this.uploadAnimation = null;
                _this._buffers = [];
                _this._dataArray = [];
                _this._joints = [];
                _this._bufferIndices = null;
                _this.type = ModelType.SKINNING;
                return _this;
              }

              var _proto = SkinningModel.prototype;

              _proto.destroy = function destroy() {
                this.bindSkeleton();

                if (this._buffers.length) {
                  for (var i = 0; i < this._buffers.length; i++) {
                    this._buffers[i].destroy();
                  }

                  this._buffers.length = 0;
                }

                _MorphModel.prototype.destroy.call(this);
              };

              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === void 0) {
                  skeleton = null;
                }

                if (skinningRoot === void 0) {
                  skinningRoot = null;
                }

                if (mesh === void 0) {
                  mesh = null;
                }

                for (var i = 0; i < this._joints.length; i++) {
                  deleteTransform(this._joints[i].target);
                }

                this._bufferIndices = null;
                this._joints.length = 0;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this.transform = skinningRoot;
                var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                var jointMaps = mesh.struct.jointMaps;

                this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);

                this._bufferIndices = mesh.jointBufferIndices;

                for (var index = 0; index < skeleton.joints.length; index++) {
                  var bound = boneSpaceBounds[index];
                  var target = skinningRoot.getChildByPath(skeleton.joints[index]);

                  if (!bound || !target) {
                    continue;
                  }

                  var transform = getTransform(target, skinningRoot);
                  var bindpose = skeleton.bindposes[index];
                  var indices = [];
                  var buffers = [];

                  if (!jointMaps) {
                    indices.push(index);
                    buffers.push(0);
                  } else {
                    getRelevantBuffers(indices, buffers, jointMaps, index);
                  }

                  this._joints.push({
                    indices: indices,
                    buffers: buffers,
                    bound: bound,
                    target: target,
                    bindpose: bindpose,
                    transform: transform
                  });
                }
              };

              _proto.updateTransform = function updateTransform(stamp) {
                var root = this.transform;

                if (root.hasChangedFlags || root._dirtyFlags) {
                  root.updateWorldTransform();
                  this._transformUpdated = true;
                }

                Vec3.set(v3_min$1, Infinity, Infinity, Infinity);
                Vec3.set(v3_max$1, -Infinity, -Infinity, -Infinity);

                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i = this._joints[i],
                      bound = _this$_joints$i.bound,
                      transform = _this$_joints$i.transform;
                  var worldMatrix = getWorldMatrix(transform, stamp);
                  AABB.transform(ab_1$1, bound, worldMatrix);
                  ab_1$1.getBoundary(v3_1$3, v3_2$2);
                  Vec3.min(v3_min$1, v3_min$1, v3_1$3);
                  Vec3.max(v3_max$1, v3_max$1, v3_2$2);
                }

                var worldBounds = this._worldBounds;

                if (this._modelBounds && worldBounds) {
                  AABB.fromPoints(this._modelBounds, v3_min$1, v3_max$1);

                  this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);

                  AABBPool.setVec3(this._hWorldBounds, AABBView.CENTER, worldBounds.center);
                  AABBPool.setVec3(this._hWorldBounds, AABBView.HALF_EXTENSION, worldBounds.halfExtents);
                }
              };

              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);

                for (var i = 0; i < this._joints.length; i++) {
                  var _this$_joints$i2 = this._joints[i],
                      indices = _this$_joints$i2.indices,
                      buffers = _this$_joints$i2.buffers,
                      transform = _this$_joints$i2.transform,
                      bindpose = _this$_joints$i2.bindpose;
                  Mat4.multiply(m4_1$1, transform.world, bindpose);

                  for (var b = 0; b < buffers.length; b++) {
                    uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1$1);
                  }
                }

                for (var _b = 0; _b < this._buffers.length; _b++) {
                  this._buffers[_b].update(this._dataArray[_b]);
                }

                return true;
              };

              _proto.initSubModel = function initSubModel(idx, subMeshData, mat) {
                var original = subMeshData.vertexBuffers;
                var iaInfo = subMeshData.iaInfo;
                iaInfo.vertexBuffers = subMeshData.jointMappedBuffers;

                _MorphModel.prototype.initSubModel.call(this, idx, subMeshData, mat);

                iaInfo.vertexBuffers = original;
              };

              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var superMacroPatches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

                if (superMacroPatches) {
                  return myPatches.concat(superMacroPatches);
                }

                return myPatches;
              };

              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

                var buffer = this._buffers[this._bufferIndices[submodelIdx]];

                if (buffer) {
                  descriptorSet.bindBuffer(UBOSkinning.BINDING, buffer);
                }
              };

              _proto._ensureEnoughBuffers = function _ensureEnoughBuffers(count) {
                for (var i = 0; i < count; i++) {
                  if (!this._buffers[i]) {
                    this._buffers[i] = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinning.SIZE, UBOSkinning.SIZE));
                  }

                  if (!this._dataArray[i]) {
                    this._dataArray[i] = new Float32Array(UBOSkinning.COUNT);
                  }
                }
              };

              return SkinningModel;
            }(MorphModel);

            var myPatches$1 = [{
              name: 'CC_USE_SKINNING',
              value: true
            }, {
              name: 'CC_USE_BAKED_ANIMATION',
              value: true
            }];
            var BakedSkinningModel = function (_MorphModel) {
              _inheritsLoose(BakedSkinningModel, _MorphModel);

              function BakedSkinningModel() {
                var _this;

                _this = _MorphModel.call(this) || this;
                _this.uploadedAnim = undefined;
                _this._jointsMedium = void 0;
                _this._skeleton = null;
                _this._mesh = null;
                _this._dataPoolManager = void 0;
                _this._instAnimInfoIdx = -1;
                _this.type = ModelType.BAKED_SKINNING;
                _this._dataPoolManager = legacyCC.director.root.dataPoolManager;
                var jointTextureInfo = new Float32Array(4);

                var animInfo = _this._dataPoolManager.jointAnimationInfo.getData();

                _this._jointsMedium = {
                  buffer: null,
                  jointTextureInfo: jointTextureInfo,
                  animInfo: animInfo,
                  texture: null,
                  boundsInfo: null
                };
                return _this;
              }

              var _proto = BakedSkinningModel.prototype;

              _proto.destroy = function destroy() {
                this.uploadedAnim = undefined;
                this._jointsMedium.boundsInfo = null;

                if (this._jointsMedium.buffer) {
                  this._jointsMedium.buffer.destroy();

                  this._jointsMedium.buffer = null;
                }

                this._applyJointTexture();

                _MorphModel.prototype.destroy.call(this);
              };

              _proto.bindSkeleton = function bindSkeleton(skeleton, skinningRoot, mesh) {
                if (skeleton === void 0) {
                  skeleton = null;
                }

                if (skinningRoot === void 0) {
                  skinningRoot = null;
                }

                if (mesh === void 0) {
                  mesh = null;
                }

                this._skeleton = skeleton;
                this._mesh = mesh;

                if (!skeleton || !skinningRoot || !mesh) {
                  return;
                }

                this.transform = skinningRoot;
                var resMgr = this._dataPoolManager;
                this._jointsMedium.animInfo = resMgr.jointAnimationInfo.getData(skinningRoot.uuid);

                if (!this._jointsMedium.buffer) {
                  this._jointsMedium.buffer = this._device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOSkinningTexture.SIZE, UBOSkinningTexture.SIZE));
                }
              };

              _proto.updateTransform = function updateTransform(stamp) {
                _MorphModel.prototype.updateTransform.call(this, stamp);

                if (!this.uploadedAnim) {
                  return;
                }

                var _this$_jointsMedium = this._jointsMedium,
                    animInfo = _this$_jointsMedium.animInfo,
                    boundsInfo = _this$_jointsMedium.boundsInfo;
                var skelBound = boundsInfo[animInfo.data[0]];
                var worldBounds = this._worldBounds;

                if (worldBounds && skelBound) {
                  var node = this.transform;
                  skelBound.transform(node._mat, node._pos, node._rot, node._scale, worldBounds);
                  AABBPool.setVec3(this._hWorldBounds, AABBView.CENTER, worldBounds.center);
                  AABBPool.setVec3(this._hWorldBounds, AABBView.HALF_EXTENSION, worldBounds.halfExtents);
                }
              };

              _proto.updateUBOs = function updateUBOs(stamp) {
                _MorphModel.prototype.updateUBOs.call(this, stamp);

                var info = this._jointsMedium.animInfo;
                var idx = this._instAnimInfoIdx;

                if (idx >= 0) {
                  var view = this.instancedAttributes.views[idx];
                  view[0] = info.data[0];
                } else if (info.dirty) {
                  info.buffer.update(info.data);
                  info.dirty = false;
                }

                return true;
              };

              _proto.uploadAnimation = function uploadAnimation(anim) {
                if (!this._skeleton || !this._mesh || this.uploadedAnim === anim) {
                  return;
                }

                this.uploadedAnim = anim;
                var resMgr = this._dataPoolManager;
                var texture = null;

                if (anim) {
                  texture = resMgr.jointTexturePool.getSequencePoseTexture(this._skeleton, anim, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = texture && texture.bounds.get(this._mesh.hash);
                  this._modelBounds = null;
                } else {
                  texture = resMgr.jointTexturePool.getDefaultPoseTexture(this._skeleton, this._mesh, this.transform);
                  this._jointsMedium.boundsInfo = null;
                  this._modelBounds = texture && texture.bounds.get(this._mesh.hash)[0];
                }

                this._applyJointTexture(texture);
              };

              _proto._applyJointTexture = function _applyJointTexture(texture) {
                if (texture === void 0) {
                  texture = null;
                }

                var oldTex = this._jointsMedium.texture;

                if (oldTex && oldTex !== texture) {
                  this._dataPoolManager.jointTexturePool.releaseHandle(oldTex);
                }

                this._jointsMedium.texture = texture;

                if (!texture) {
                  return;
                }

                var _this$_jointsMedium2 = this._jointsMedium,
                    buffer = _this$_jointsMedium2.buffer,
                    jointTextureInfo = _this$_jointsMedium2.jointTextureInfo;
                jointTextureInfo[0] = texture.handle.texture.width;
                jointTextureInfo[1] = this._skeleton.joints.length;
                jointTextureInfo[2] = texture.pixelOffset + 0.1;
                jointTextureInfo[3] = 1 / jointTextureInfo[0];
                this.updateInstancedJointTextureInfo();

                if (buffer) {
                  buffer.update(jointTextureInfo);
                }

                var tex = texture.handle.texture;

                for (var i = 0; i < this._subModels.length; ++i) {
                  var descriptorSet = this._subModels[i].descriptorSet;
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, tex);
                }
              };

              _proto.getMacroPatches = function getMacroPatches(subModelIndex) {
                var patches = _MorphModel.prototype.getMacroPatches.call(this, subModelIndex);

                return patches ? patches.concat(myPatches$1) : myPatches$1;
              };

              _proto._updateLocalDescriptors = function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                _MorphModel.prototype._updateLocalDescriptors.call(this, submodelIdx, descriptorSet);

                var _this$_jointsMedium3 = this._jointsMedium,
                    buffer = _this$_jointsMedium3.buffer,
                    texture = _this$_jointsMedium3.texture,
                    animInfo = _this$_jointsMedium3.animInfo;
                descriptorSet.bindBuffer(UBOSkinningTexture.BINDING, buffer);
                descriptorSet.bindBuffer(UBOSkinningAnimation.BINDING, animInfo.buffer);

                if (texture) {
                  var sampler = samplerLib.getSampler(this._device, jointTextureSamplerHash);
                  descriptorSet.bindTexture(UNIFORM_JOINT_TEXTURE_BINDING, texture.handle.texture);
                  descriptorSet.bindSampler(UNIFORM_JOINT_TEXTURE_BINDING, sampler);
                }
              };

              _proto._updateInstancedAttributes = function _updateInstancedAttributes(attributes, pass) {
                _MorphModel.prototype._updateInstancedAttributes.call(this, attributes, pass);

                this._instAnimInfoIdx = this._getInstancedAttributeIndex(INST_JOINT_ANIM_INFO);
                this.updateInstancedJointTextureInfo();
              };

              _proto.updateInstancedJointTextureInfo = function updateInstancedJointTextureInfo() {
                var _this$_jointsMedium4 = this._jointsMedium,
                    jointTextureInfo = _this$_jointsMedium4.jointTextureInfo,
                    animInfo = _this$_jointsMedium4.animInfo;
                var idx = this._instAnimInfoIdx;

                if (idx >= 0) {
                  var view = this.instancedAttributes.views[idx];
                  view[0] = animInfo.data[0];
                  view[1] = jointTextureInfo[1];
                  view[2] = jointTextureInfo[2];
                }
              };

              return BakedSkinningModel;
            }(MorphModel);

            var _dec$7, _dec2$6, _dec3$6, _dec4$5, _dec5$5, _dec6$4, _dec7$4, _dec8$3, _dec9$3, _class$7, _class2$7, _descriptor$7, _descriptor2$6, _temp$7;
            var SkinnedMeshRenderer = function (v) { return exports({ SkinnedMeshRenderer: v, SkinningModelComponent: v }), v; }((_dec$7 = ccclass('cc.SkinnedMeshRenderer'), _dec2$6 = help(), _dec3$6 = executionOrder(100), _dec4$5 = menu(), _dec5$5 = type(Skeleton), _dec6$4 = type(Node), _dec7$4 = type(Skeleton), _dec8$3 = type(Node), _dec9$3 = tooltip(), _dec$7(_class$7 = _dec2$6(_class$7 = _dec3$6(_class$7 = executeInEditMode(_class$7 = _dec4$5(_class$7 = (_class2$7 = (_temp$7 = function (_MeshRenderer) {
              _inheritsLoose(SkinnedMeshRenderer, _MeshRenderer);

              _createClass(SkinnedMeshRenderer, [{
                key: "skeleton",
                get: function get() {
                  return this._skeleton;
                },
                set: function set(val) {
                  if (val === this._skeleton) {
                    return;
                  }

                  this._skeleton = val;

                  this._update();
                }
              }, {
                key: "skinningRoot",
                get: function get() {
                  return this._skinningRoot;
                },
                set: function set(value) {
                  if (value === this._skinningRoot) {
                    return;
                  }

                  this._skinningRoot = value;

                  this._updateModelType();

                  this._update();
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }]);

              function SkinnedMeshRenderer() {
                var _this;

                _this = _MeshRenderer.call(this) || this;

                _initializerDefineProperty(_this, "_skeleton", _descriptor$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_skinningRoot", _descriptor2$6, _assertThisInitialized(_this));

                _this._clip = null;
                _this._modelType = BakedSkinningModel;
                return _this;
              }

              var _proto = SkinnedMeshRenderer.prototype;

              _proto.__preload = function __preload() {
                this._updateModelType();
              };

              _proto.uploadAnimation = function uploadAnimation(clip) {
                this._clip = clip;

                if (this.model && this.model.uploadAnimation) {
                  this.model.uploadAnimation(clip);
                }
              };

              _proto.setUseBakedAnimation = function setUseBakedAnimation(val) {
                if (val === void 0) {
                  val = true;
                }

                var modelType = val ? BakedSkinningModel : SkinningModel;

                if (this._modelType === modelType) {
                  return;
                }

                this._modelType = modelType;

                if (this._model) {
                  legacyCC.director.root.destroyModel(this._model);
                  this._model = null;
                  this._models.length = 0;

                  this._updateModels();

                  this._updateCastShadow();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              };

              _proto.setMaterial = function setMaterial(material, index) {
                _MeshRenderer.prototype.setMaterial.call(this, material, index);

                if (this._modelType === SkinningModel) {
                  this.getMaterialInstance(index);
                }
              };

              _proto._updateModelParams = function _updateModelParams() {
                this._update();

                _MeshRenderer.prototype._updateModelParams.call(this);
              };

              _proto._updateModelType = function _updateModelType() {
                if (!this._skinningRoot) {
                  return;
                }

                var comp = this._skinningRoot.getComponent('cc.SkeletalAnimation');

                if (comp) {
                  this.setUseBakedAnimation(comp.useBakedAnimation);
                }
              };

              _proto._update = function _update() {
                if (this.model) {
                  this.model.bindSkeleton(this._skeleton, this._skinningRoot, this._mesh);

                  if (this.model.uploadAnimation) {
                    this.model.uploadAnimation(this._clip);
                  }
                }
              };

              return SkinnedMeshRenderer;
            }(MeshRenderer), _temp$7), (_descriptor$7 = _applyDecoratedDescriptor(_class2$7.prototype, "_skeleton", [_dec5$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$7.prototype, "_skinningRoot", [_dec6$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$7.prototype, "skeleton", [_dec7$4], Object.getOwnPropertyDescriptor(_class2$7.prototype, "skeleton"), _class2$7.prototype), _applyDecoratedDescriptor(_class2$7.prototype, "skinningRoot", [_dec8$3, _dec9$3], Object.getOwnPropertyDescriptor(_class2$7.prototype, "skinningRoot"), _class2$7.prototype)), _class2$7)) || _class$7) || _class$7) || _class$7) || _class$7) || _class$7));

            var _dec$8, _dec2$7, _dec3$7, _dec4$6, _dec5$6, _class$8, _class2$8, _descriptor$8, _descriptor2$7, _descriptor3$6, _descriptor4$4, _descriptor5$3, _descriptor6$2, _temp$8, _dec6$5, _dec7$5, _dec8$4, _dec9$4, _dec10$3, _dec11$3, _dec12$2, _dec13$2, _dec14, _dec15, _dec16, _class4$2, _class5$2, _descriptor7$2, _descriptor8$2, _descriptor9$1, _temp2$2;

            var repeat = function repeat(n) {
              return n - Math.floor(n);
            };

            var batch_id = new Attribute(AttributeName.ATTR_BATCH_ID, Format.R32F);
            var batch_uv = new Attribute(AttributeName.ATTR_BATCH_UV, Format.RG32F);
            var batch_extras_size = FormatInfos[batch_id.format].size + FormatInfos[batch_uv.format].size;
            var SkinnedMeshUnit = function (v) { return exports({ SkinnedMeshUnit: v, SkinningModelUnit: v }), v; }((_dec$8 = ccclass('cc.SkinnedMeshUnit'), _dec2$7 = type(Mesh), _dec3$7 = type(Skeleton), _dec4$6 = type(Material), _dec5$6 = type(SkinnedMeshRenderer), _dec$8(_class$8 = (_class2$8 = (_temp$8 = function () {
              function SkinnedMeshUnit() {
                _initializerDefineProperty(this, "mesh", _descriptor$8, this);

                _initializerDefineProperty(this, "skeleton", _descriptor2$7, this);

                _initializerDefineProperty(this, "material", _descriptor3$6, this);

                _initializerDefineProperty(this, "_localTransform", _descriptor4$4, this);

                _initializerDefineProperty(this, "_offset", _descriptor5$3, this);

                _initializerDefineProperty(this, "_size", _descriptor6$2, this);
              }

              _createClass(SkinnedMeshUnit, [{
                key: "offset",
                set: function set(offset) {
                  Vec2.copy(this._offset, offset);
                },
                get: function get() {
                  return this._offset;
                }
              }, {
                key: "size",
                set: function set(size) {
                  Vec2.copy(this._size, size);
                },
                get: function get() {
                  return this._size;
                }
              }, {
                key: "copyFrom",
                set: function set(comp) {
                  if (!comp) {
                    return;
                  }

                  this.mesh = comp.mesh;
                  this.skeleton = comp.skeleton;
                  this.material = comp.getMaterial(0);

                  if (comp.skinningRoot) {
                    getWorldTransformUntilRoot(comp.node, comp.skinningRoot, this._localTransform);
                  }
                },
                get: function get() {
                  return null;
                }
              }]);

              return SkinnedMeshUnit;
            }(), _temp$8), (_descriptor$8 = _applyDecoratedDescriptor(_class2$8.prototype, "mesh", [_dec2$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$8.prototype, "skeleton", [_dec3$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$8.prototype, "material", [_dec4$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$8.prototype, "_localTransform", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Mat4();
              }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$8.prototype, "_offset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(0, 0);
              }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$8.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(1, 1);
              }
            }), _applyDecoratedDescriptor(_class2$8.prototype, "offset", [editable], Object.getOwnPropertyDescriptor(_class2$8.prototype, "offset"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "size", [editable], Object.getOwnPropertyDescriptor(_class2$8.prototype, "size"), _class2$8.prototype), _applyDecoratedDescriptor(_class2$8.prototype, "copyFrom", [_dec5$6], Object.getOwnPropertyDescriptor(_class2$8.prototype, "copyFrom"), _class2$8.prototype)), _class2$8)) || _class$8));
            var m4_local = new Mat4();
            var m4_1$2 = new Mat4();
            var v3_1$4 = new Vec3();
            var SkinnedMeshBatchRenderer = function (v) { return exports({ SkinnedMeshBatchRenderer: v, BatchedSkinningModelComponent: v }), v; }((_dec6$5 = ccclass('cc.SkinnedMeshBatchRenderer'), _dec7$5 = help(), _dec8$4 = executionOrder(100), _dec9$4 = menu(), _dec10$3 = tooltip(), _dec11$3 = type([CCString]), _dec12$2 = tooltip(), _dec13$2 = type([SkinnedMeshUnit]), _dec14 = tooltip(), _dec15 = visible(), _dec16 = visible(), _dec6$5(_class4$2 = _dec7$5(_class4$2 = _dec8$4(_class4$2 = executeInEditMode(_class4$2 = _dec9$4(_class4$2 = (_class5$2 = (_temp2$2 = function (_SkinnedMeshRenderer) {
              _inheritsLoose(SkinnedMeshBatchRenderer, _SkinnedMeshRenderer);

              function SkinnedMeshBatchRenderer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _SkinnedMeshRenderer.call.apply(_SkinnedMeshRenderer, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "atlasSize", _descriptor7$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "batchableTextureNames", _descriptor8$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "units", _descriptor9$1, _assertThisInitialized(_this));

                _this._textures = {};
                _this._batchMaterial = null;
                return _this;
              }

              var _proto = SkinnedMeshBatchRenderer.prototype;

              _proto.onLoad = function onLoad() {
                _SkinnedMeshRenderer.prototype.onLoad.call(this);

                this.cook();
              };

              _proto.onDestroy = function onDestroy() {
                for (var tex in this._textures) {
                  this._textures[tex].destroy();
                }

                this._textures = {};

                if (this._mesh) {
                  this._mesh.destroy();

                  this._mesh = null;
                }

                _SkinnedMeshRenderer.prototype.onDestroy.call(this);
              };

              _proto._onMaterialModified = function _onMaterialModified(idx, material) {
                this.cookMaterials();

                _SkinnedMeshRenderer.prototype._onMaterialModified.call(this, idx, this.getMaterialInstance(idx));
              };

              _proto.cook = function cook() {
                this.cookMaterials();
                this.cookSkeletons();
                this.cookMeshes();
              };

              _proto.cookMaterials = function cookMaterials() {
                var _this2 = this;

                if (!this._batchMaterial) {
                  this._batchMaterial = this.getMaterial(0);
                }

                var mat = this.getMaterialInstance(0);

                if (!mat || !this._batchMaterial || !this._batchMaterial.effectAsset) {
                  console.warn('incomplete batch material!');
                  return;
                }

                mat.copy(this._batchMaterial);
                this.resizeAtlases();
                var tech = mat.effectAsset.techniques[mat.technique];

                var _loop = function _loop(i) {
                  var pass = tech.passes[i];

                  if (!pass.properties) {
                    return "continue";
                  }

                  var _loop2 = function _loop2(prop) {
                    if (pass.properties[prop].type >= Type$1.SAMPLER1D) {
                      var tex = null;

                      if (_this2.batchableTextureNames.find(function (n) {
                        return n === prop;
                      })) {
                        tex = _this2._textures[prop];

                        if (!tex) {
                          tex = _this2.createTexture(prop);
                        }

                        _this2.cookTextures(tex, prop, i);
                      } else {
                        _this2.units.some(function (u) {
                          return tex = u.material && u.material.getProperty(prop, i);
                        });
                      }

                      if (tex) {
                        mat.setProperty(prop, tex, i);
                      }
                    } else {
                      var value = [];

                      for (var u = 0; u < _this2.units.length; u++) {
                        var unit = _this2.units[u];

                        if (!unit.material) {
                          continue;
                        }

                        value.push(unit.material.getProperty(prop.slice(0, -3), i));
                      }

                      mat.setProperty(prop, value, i);
                    }
                  };

                  for (var prop in pass.properties) {
                    _loop2(prop);
                  }
                };

                for (var i = 0; i < tech.passes.length; i++) {
                  var _ret = _loop(i);

                  if (_ret === "continue") continue;
                }
              };

              _proto.cookSkeletons = function cookSkeletons() {

                if (!this._skinningRoot) {
                  console.warn('no skinning root specified!');
                  return;
                }

                var joints = [];
                var bindposes = [];

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (!unit || !unit.skeleton) {
                    continue;
                  }

                  var partial = unit.skeleton;
                  Mat4.invert(m4_local, unit._localTransform);

                  var _loop3 = function _loop3(i) {
                    var path = partial.joints[i];
                    var idx = joints.findIndex(function (p) {
                      return p === path;
                    });

                    if (idx >= 0) {

                      return "continue";
                    }

                    joints.push(path);
                    bindposes.push(Mat4.multiply(new Mat4(), partial.bindposes[i] || Mat4.IDENTITY, m4_local));
                  };

                  for (var i = 0; i < partial.joints.length; i++) {
                    var _ret2 = _loop3(i);

                    if (_ret2 === "continue") continue;
                  }
                }

                var idxMap = Array.from(Array(joints.length).keys()).sort(function (a, b) {
                  if (joints[a] > joints[b]) {
                    return 1;
                  }

                  if (joints[a] < joints[b]) {
                    return -1;
                  }

                  return 0;
                });
                var skeleton = new Skeleton();
                skeleton.joints = joints.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });
                skeleton.bindposes = bindposes.map(function (_, idx, arr) {
                  return arr[idxMap[idx]];
                });

                if (this._skeleton) {
                  this._skeleton.destroy();
                }

                this.skeleton = skeleton;
              };

              _proto.cookMeshes = function cookMeshes() {
                var _this4 = this;

                var isValid = false;

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (unit.mesh) {
                    isValid = true;
                    break;
                  }
                }

                if (!isValid || !this._skinningRoot) {
                  return;
                }

                if (this._mesh) {
                  this._mesh.destroyRenderingMesh();
                } else {
                  this._mesh = new Mesh();
                }

                var posOffset = 0;
                var posFormat = Format.UNKNOWN;
                var normalOffset = 0;
                var normalFormat = Format.UNKNOWN;
                var tangentOffset = 0;
                var tangentFormat = Format.UNKNOWN;
                var uvOffset = 0;
                var uvFormat = Format.UNKNOWN;
                var jointOffset = 0;
                var jointFormat = Format.UNKNOWN;
                var jointIndexMap = new Array(this.units.length);
                var unitLen = this.units.length;

                for (var i = 0; i < unitLen; i++) {
                  var _unit = this.units[i];

                  if (!_unit || !_unit.skeleton) {
                    continue;
                  }

                  jointIndexMap[i] = _unit.skeleton.joints.map(function (j) {
                    return _this4._skeleton.joints.findIndex(function (ref) {
                      return j === ref;
                    });
                  });
                }

                var _loop4 = function _loop4(_i) {
                  var unit = _this4.units[_i];

                  if (!unit || !unit.mesh || !unit.mesh.data) {
                    return "continue";
                  }

                  var newMesh = _this4._createUnitMesh(_i, unit.mesh);

                  var dataView = new DataView(newMesh.data.buffer);
                  Mat4.inverseTranspose(m4_local, unit._localTransform);
                  var offset = unit.offset;
                  var size = unit.size;

                  var _loop5 = function _loop5(b) {
                    var bundle = newMesh.struct.vertexBundles[b];
                    posOffset = bundle.view.offset;
                    posFormat = Format.UNKNOWN;

                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_POSITION) {
                        posFormat = attr.format;
                        break;
                      }

                      posOffset += FormatInfos[attr.format].size;
                    }

                    if (posFormat) {
                      var pos = readBuffer(dataView, posFormat, posOffset, bundle.view.length, bundle.view.stride);

                      for (var j = 0; j < pos.length; j += 3) {
                        Vec3.fromArray(v3_1$4, pos, j);
                        Vec3.transformMat4(v3_1$4, v3_1$4, unit._localTransform);
                        Vec3.toArray(pos, v3_1$4, j);
                      }

                      writeBuffer(dataView, pos, posFormat, posOffset, bundle.view.stride);
                    }

                    normalOffset = bundle.view.offset;
                    normalFormat = Format.UNKNOWN;

                    for (var _a = 0; _a < bundle.attributes.length; _a++) {
                      var _attr = bundle.attributes[_a];

                      if (_attr.name === AttributeName.ATTR_NORMAL) {
                        normalFormat = _attr.format;
                        break;
                      }

                      normalOffset += FormatInfos[_attr.format].size;
                    }

                    if (normalFormat) {
                      var normal = readBuffer(dataView, normalFormat, normalOffset, bundle.view.length, bundle.view.stride);

                      for (var _j = 0; _j < normal.length; _j += 3) {
                        Vec3.fromArray(v3_1$4, normal, _j);
                        Vec3.transformMat4Normal(v3_1$4, v3_1$4, m4_local);
                        Vec3.toArray(normal, v3_1$4, _j);
                      }

                      writeBuffer(dataView, normal, normalFormat, normalOffset, bundle.view.stride);
                    }

                    tangentOffset = bundle.view.offset;
                    tangentFormat = Format.UNKNOWN;

                    for (var _a2 = 0; _a2 < bundle.attributes.length; _a2++) {
                      var _attr2 = bundle.attributes[_a2];

                      if (_attr2.name === AttributeName.ATTR_TANGENT) {
                        tangentFormat = _attr2.format;
                        break;
                      }

                      tangentOffset += FormatInfos[_attr2.format].size;
                    }

                    if (tangentFormat) {
                      var tangent = readBuffer(dataView, tangentFormat, tangentOffset, bundle.view.length, bundle.view.stride);

                      for (var _j2 = 0; _j2 < tangent.length; _j2 += 3) {
                        Vec3.fromArray(v3_1$4, tangent, _j2);
                        Vec3.transformMat4Normal(v3_1$4, v3_1$4, m4_local);
                        Vec3.toArray(tangent, v3_1$4, _j2);
                      }

                      writeBuffer(dataView, tangent, tangentFormat, tangentOffset, bundle.view.stride);
                    }

                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (var _a3 = 0; _a3 < bundle.attributes.length; _a3++) {
                      var _attr3 = bundle.attributes[_a3];

                      if (_attr3.name === AttributeName.ATTR_BATCH_UV) {
                        uvFormat = _attr3.format;
                        break;
                      }

                      uvOffset += FormatInfos[_attr3.format].size;
                    }

                    if (uvFormat) {
                      mapBuffer(dataView, function (cur, idx) {
                        cur = repeat(cur);
                        var comp = idx === 0 ? 'x' : 'y';
                        return cur * size[comp] + offset[comp];
                      }, uvFormat, uvOffset, bundle.view.length, bundle.view.stride, dataView);
                    }

                    var idxMap = jointIndexMap[_i];

                    if (!idxMap) {
                      return "continue";
                    }

                    jointOffset = bundle.view.offset;
                    jointFormat = Format.UNKNOWN;

                    for (var _a4 = 0; _a4 < bundle.attributes.length; _a4++) {
                      var _attr4 = bundle.attributes[_a4];

                      if (_attr4.name === AttributeName.ATTR_JOINTS) {
                        jointFormat = _attr4.format;
                        break;
                      }

                      jointOffset += FormatInfos[_attr4.format].size;
                    }

                    if (jointFormat) {
                      mapBuffer(dataView, function (cur) {
                        return idxMap[cur];
                      }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                    }
                  };

                  for (var b = 0; b < newMesh.struct.vertexBundles.length; b++) {
                    var _ret4 = _loop5(b);

                    if (_ret4 === "continue") continue;
                  }

                  _this4._mesh.merge(newMesh);
                };

                for (var _i = 0; _i < unitLen; _i++) {
                  var _ret3 = _loop4(_i);

                  if (_ret3 === "continue") continue;
                }

                this._onMeshChanged(this._mesh);

                this._updateModels();
              };

              _proto.cookTextures = function cookTextures(target, prop, passIdx) {
                var texImages = [];
                var texImageRegions = [];
                var texBuffers = [];
                var texBufferRegions = [];

                for (var u = 0; u < this.units.length; u++) {
                  var unit = this.units[u];

                  if (!unit.material) {
                    continue;
                  }

                  var partial = unit.material.getProperty(prop, passIdx);

                  if (partial && partial.image && partial.image.data) {
                    var region = new BufferTextureCopy();
                    region.texOffset.x = unit.offset.x * this.atlasSize;
                    region.texOffset.y = unit.offset.y * this.atlasSize;
                    region.texExtent.width = unit.size.x * this.atlasSize;
                    region.texExtent.height = unit.size.y * this.atlasSize;
                    var data = partial.image.data;

                    if (!ArrayBuffer.isView(data)) {
                      texImages.push(data);
                      texImageRegions.push(region);
                    } else {
                      texBuffers.push(data);
                      texBufferRegions.push(region);
                    }
                  }
                }

                var gfxTex = target.getGFXTexture();
                var _ref = legacyCC.director.root,
                    device = _ref.device;

                if (texBuffers.length > 0) {
                  device.copyBuffersToTexture(texBuffers, gfxTex, texBufferRegions);
                }

                if (texImages.length > 0) {
                  device.copyTexImagesToTexture(texImages, gfxTex, texImageRegions);
                }
              };

              _proto.createTexture = function createTexture(prop) {
                var tex = new Texture2D();
                tex.setFilters(Filter$1.LINEAR, Filter$1.LINEAR);
                tex.setMipFilter(Filter$1.NEAREST);
                tex.reset({
                  width: this.atlasSize,
                  height: this.atlasSize,
                  format: PixelFormat.RGBA8888
                });
                tex.loaded = true;
                this._textures[prop] = tex;
                return tex;
              };

              _proto.resizeAtlases = function resizeAtlases() {
                for (var prop in this._textures) {
                  var tex = this._textures[prop];
                  tex.reset({
                    width: this.atlasSize,
                    height: this.atlasSize,
                    format: PixelFormat.RGBA8888
                  });
                }
              };

              _proto._createUnitMesh = function _createUnitMesh(unitIdx, mesh) {
                var newMeshStruct = JSON.parse(JSON.stringify(mesh.struct));
                var modifiedBundles = {};

                for (var p = 0; p < mesh.struct.primitives.length; p++) {
                  var primitive = mesh.struct.primitives[p];
                  var uvOffset = 0;
                  var uvFormat = Format.UNKNOWN;
                  var bundleIdx = 0;

                  for (; bundleIdx < primitive.vertexBundelIndices.length; bundleIdx++) {
                    var bundle = mesh.struct.vertexBundles[primitive.vertexBundelIndices[bundleIdx]];
                    uvOffset = bundle.view.offset;
                    uvFormat = Format.UNKNOWN;

                    for (var a = 0; a < bundle.attributes.length; a++) {
                      var attr = bundle.attributes[a];

                      if (attr.name === AttributeName.ATTR_TEX_COORD) {
                        uvFormat = attr.format;
                        break;
                      }

                      uvOffset += FormatInfos[attr.format].size;
                    }

                    if (uvFormat) {
                      break;
                    }
                  }

                  if (modifiedBundles[bundleIdx] !== undefined) {
                    continue;
                  }

                  modifiedBundles[bundleIdx] = [uvFormat, uvOffset];
                  var newBundle = newMeshStruct.vertexBundles[bundleIdx];
                  newBundle.attributes.push(batch_id);
                  newBundle.attributes.push(batch_uv);
                  newBundle.view.offset = 0;
                  newBundle.view.length += newBundle.view.count * batch_extras_size;
                  newBundle.view.stride += batch_extras_size;
                }

                var totalLength = 0;

                for (var b = 0; b < newMeshStruct.vertexBundles.length; b++) {
                  totalLength += newMeshStruct.vertexBundles[b].view.length;
                }

                for (var _p = 0; _p < newMeshStruct.primitives.length; _p++) {
                  var pm = newMeshStruct.primitives[_p];

                  if (pm.indexView) {
                    pm.indexView.offset = totalLength;
                    totalLength += pm.indexView.length;
                  }
                }

                var newMeshData = new Uint8Array(totalLength);
                var oldMeshData = mesh.data;
                var newDataView = new DataView(newMeshData.buffer);
                var oldDataView = new DataView(oldMeshData.buffer);
                var isLittleEndian = legacyCC.sys.isLittleEndian;

                for (var _b in modifiedBundles) {
                  var _newBundle = newMeshStruct.vertexBundles[_b];
                  var oldBundle = mesh.struct.vertexBundles[_b];
                  var _modifiedBundles$_b = modifiedBundles[_b],
                      _uvFormat = _modifiedBundles$_b[0],
                      _uvOffset = _modifiedBundles$_b[1];
                  var uvs = readBuffer(oldDataView, _uvFormat, _uvOffset, oldBundle.view.length, oldBundle.view.stride);
                  var oldView = oldBundle.view;
                  var newView = _newBundle.view;
                  var oldStride = oldView.stride;
                  var newStride = newView.stride;
                  var oldOffset = oldView.offset;
                  var newOffset = newView.offset;

                  for (var j = 0; j < newView.count; j++) {
                    var srcVertex = oldMeshData.subarray(oldOffset, oldOffset + oldStride);
                    newMeshData.set(srcVertex, newOffset);
                    newDataView.setFloat32(newOffset + oldStride, unitIdx);
                    newDataView.setFloat32(newOffset + oldStride + 4, uvs[j * 2], isLittleEndian);
                    newDataView.setFloat32(newOffset + oldStride + 8, uvs[j * 2 + 1], isLittleEndian);
                    newOffset += newStride;
                    oldOffset += oldStride;
                  }
                }

                for (var k = 0; k < newMeshStruct.primitives.length; k++) {
                  var oldPrimitive = mesh.struct.primitives[k];
                  var newPrimitive = newMeshStruct.primitives[k];

                  if (oldPrimitive.indexView && newPrimitive.indexView) {
                    var _oldStride = oldPrimitive.indexView.stride;
                    var _newStride = newPrimitive.indexView.stride;
                    var _oldOffset = oldPrimitive.indexView.offset;
                    var _newOffset = newPrimitive.indexView.offset;

                    for (var _j3 = 0; _j3 < newPrimitive.indexView.count; _j3++) {
                      var srcIndices = oldMeshData.subarray(_oldOffset, _oldOffset + _oldStride);
                      newMeshData.set(srcIndices, _newOffset);
                      _newOffset += _newStride;
                      _oldOffset += _oldStride;
                    }
                  }
                }

                var newMesh = new Mesh();
                newMesh.reset({
                  struct: newMeshStruct,
                  data: newMeshData
                });
                return newMesh;
              };

              _createClass(SkinnedMeshBatchRenderer, [{
                key: "mesh",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.mesh;
                },
                set: function set(val) {
                  this.mesh = val;
                }
              }, {
                key: "skeleton",
                get: function get() {
                  return _SkinnedMeshRenderer.prototype.skeleton;
                },
                set: function set(val) {
                  this.skeleton = val;
                }
              }]);

              return SkinnedMeshBatchRenderer;
            }(SkinnedMeshRenderer), _temp2$2), (_descriptor7$2 = _applyDecoratedDescriptor(_class5$2.prototype, "atlasSize", [serializable, _dec10$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1024;
              }
            }), _descriptor8$2 = _applyDecoratedDescriptor(_class5$2.prototype, "batchableTextureNames", [_dec11$3, serializable, _dec12$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor9$1 = _applyDecoratedDescriptor(_class5$2.prototype, "units", [_dec13$2, serializable, _dec14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _applyDecoratedDescriptor(_class5$2.prototype, "mesh", [override, _dec15], Object.getOwnPropertyDescriptor(_class5$2.prototype, "mesh"), _class5$2.prototype), _applyDecoratedDescriptor(_class5$2.prototype, "skeleton", [override, _dec16], Object.getOwnPropertyDescriptor(_class5$2.prototype, "skeleton"), _class5$2.prototype)), _class5$2)) || _class4$2) || _class4$2) || _class4$2) || _class4$2) || _class4$2));

            legacyCC.SkinningModelComponent = SkinnedMeshRenderer;
            js.setClassAlias(SkinnedMeshRenderer, 'cc.SkinningModelComponent');
            legacyCC.SkinningModelUnit = SkinnedMeshUnit;
            js.setClassAlias(SkinnedMeshUnit, 'cc.SkinningModelUnit');
            legacyCC.BatchedSkinningModelComponent = SkinnedMeshBatchRenderer;
            js.setClassAlias(SkinnedMeshBatchRenderer, 'cc.BatchedSkinningModelComponent');

            var m4_1$3 = new Mat4();
            var m4_2$1 = new Mat4();
            var noCurves = [];
            var SkeletalAnimationState = exports('SkeletalAnimationState', function (_AnimationState) {
              _inheritsLoose(SkeletalAnimationState, _AnimationState);

              function SkeletalAnimationState(clip, name) {
                var _this;

                if (name === void 0) {
                  name = '';
                }

                _this = _AnimationState.call(this, clip, name) || this;
                _this._frames = 1;
                _this._bakedDuration = 0;
                _this._animInfo = null;
                _this._sockets = [];
                _this._animInfoMgr = void 0;
                _this._comps = [];
                _this._parent = null;
                _this._curvesInited = false;
                _this._animInfoMgr = legacyCC.director.root.dataPoolManager.jointAnimationInfo;
                return _this;
              }

              var _proto = SkeletalAnimationState.prototype;

              _proto.initialize = function initialize(root) {
                if (this._curveLoaded) {
                  return;
                }

                this._comps.length = 0;
                var comps = root.getComponentsInChildren(SkinnedMeshRenderer);

                for (var i = 0; i < comps.length; ++i) {
                  var comp = comps[i];

                  if (comp.skinningRoot === root) {
                    this._comps.push(comp);
                  }
                }

                this._parent = root.getComponent('cc.SkeletalAnimation');
                var baked = this._parent.useBakedAnimation;

                _AnimationState.prototype.initialize.call(this, root, baked ? noCurves : undefined);

                this._curvesInited = !baked;

                var _SkelAnimDataHub$getO = SkelAnimDataHub.getOrExtract(this.clip),
                    info = _SkelAnimDataHub$getO.info;

                this._frames = info.frames - 1;
                this._animInfo = this._animInfoMgr.getData(root.uuid);
                this._bakedDuration = this._frames / info.sample;
              };

              _proto.onPlay = function onPlay() {
                _AnimationState.prototype.onPlay.call(this);

                var baked = this._parent.useBakedAnimation;

                if (baked) {
                  this._sampleCurves = this._sampleCurvesBaked;
                  this.duration = this._bakedDuration;

                  this._animInfoMgr.switchClip(this._animInfo, this.clip);

                  for (var i = 0; i < this._comps.length; ++i) {
                    this._comps[i].uploadAnimation(this.clip);
                  }
                } else {
                  this._sampleCurves = _AnimationState.prototype._sampleCurves;
                  this.duration = this.clip.duration;

                  if (!this._curvesInited) {
                    this._curveLoaded = false;

                    _AnimationState.prototype.initialize.call(this, this._targetNode);

                    this._curvesInited = true;
                  }
                }
              };

              _proto.rebuildSocketCurves = function rebuildSocketCurves(sockets) {
                this._sockets.length = 0;

                if (!this._targetNode) {
                  return;
                }

                var root = this._targetNode;

                for (var i = 0; i < sockets.length; ++i) {
                  var socket = sockets[i];
                  var targetNode = root.getChildByPath(socket.path);

                  if (!socket.target) {
                    continue;
                  }

                  var clipData = SkelAnimDataHub.getOrExtract(this.clip);
                  var animPath = socket.path;
                  var source = clipData.data[animPath];
                  var animNode = targetNode;
                  var downstream = void 0;

                  while (!source) {
                    var idx = animPath.lastIndexOf('/');
                    animPath = animPath.substring(0, idx);
                    source = clipData.data[animPath];

                    if (animNode) {
                      if (!downstream) {
                        downstream = Mat4.identity(m4_2$1);
                      }

                      Mat4.fromRTS(m4_1$3, animNode.rotation, animNode.position, animNode.scale);
                      Mat4.multiply(downstream, m4_1$3, downstream);
                      animNode = animNode.parent;
                    }

                    if (idx < 0) {
                      break;
                    }
                  }

                  var curveData = source && source.worldMatrix.values;
                  var frames = clipData.info.frames;
                  var transforms = [];

                  for (var f = 0; f < frames; f++) {
                    var mat = void 0;

                    if (curveData && downstream) {
                      mat = Mat4.multiply(m4_1$3, curveData[f], downstream);
                    } else if (curveData) {
                      mat = curveData[f];
                    } else if (downstream) {
                      mat = downstream;
                    } else {
                      mat = Mat4.IDENTITY;
                    }

                    var tfm = {
                      pos: new Vec3(),
                      rot: new Quat(),
                      scale: new Vec3()
                    };
                    Mat4.toRTS(mat, tfm.rot, tfm.pos, tfm.scale);
                    transforms.push(tfm);
                  }

                  this._sockets.push({
                    target: socket.target,
                    frames: transforms
                  });
                }
              };

              _proto._sampleCurvesBaked = function _sampleCurvesBaked(ratio) {
                var info = this._animInfo;
                var curFrame = ratio * this._frames + 0.5 | 0;

                if (curFrame === info.data[0]) {
                  return;
                }

                info.data[0] = curFrame;
                info.dirty = true;

                for (var i = 0; i < this._sockets.length; ++i) {
                  var _this$_sockets$i = this._sockets[i],
                      target = _this$_sockets$i.target,
                      frames = _this$_sockets$i.frames;
                  var _frames$curFrame = frames[curFrame],
                      pos = _frames$curFrame.pos,
                      rot = _frames$curFrame.rot,
                      scale = _frames$curFrame.scale;
                  target.setRTS(rot, pos, scale);
                }
              };

              return SkeletalAnimationState;
            }(AnimationState));

            var _dec$9, _dec2$8, _class$9, _class2$9, _descriptor$9, _descriptor2$8, _temp$9, _dec3$8, _dec4$7, _dec5$7, _dec6$6, _dec7$6, _dec8$5, _dec9$5, _dec10$4, _class4$3, _class5$3, _descriptor3$7, _descriptor4$5, _class6$2, _temp2$3;
            var Socket = exports('Socket', (_dec$9 = ccclass('cc.SkeletalAnimation.Socket'), _dec2$8 = type(Node), _dec$9(_class$9 = (_class2$9 = (_temp$9 = function Socket(path, target) {
              if (path === void 0) {
                path = '';
              }

              if (target === void 0) {
                target = null;
              }

              _initializerDefineProperty(this, "path", _descriptor$9, this);

              _initializerDefineProperty(this, "target", _descriptor2$8, this);

              this.path = path;
              this.target = target;
            }, _temp$9), (_descriptor$9 = _applyDecoratedDescriptor(_class2$9.prototype, "path", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$9.prototype, "target", [_dec2$8], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$9)) || _class$9));
            js.setClassAlias(Socket, 'cc.SkeletalAnimationComponent.Socket');
            var m4_1$4 = new Mat4();
            var m4_2$2 = new Mat4();

            function collectRecursively(node, prefix, out) {
              if (prefix === void 0) {
                prefix = '';
              }

              if (out === void 0) {
                out = [];
              }

              for (var i = 0; i < node.children.length; i++) {
                var child = node.children[i];

                if (!child) {
                  continue;
                }

                var path = prefix ? prefix + "/" + child.name : child.name;
                out.push(path);
                collectRecursively(child, path, out);
              }

              return out;
            }

            var SkeletalAnimation = function (v) { return exports({ SkeletalAnimation: v, SkeletalAnimationComponent: v }), v; }((_dec3$8 = ccclass('cc.SkeletalAnimation'), _dec4$7 = help(), _dec5$7 = executionOrder(99), _dec6$6 = menu(), _dec7$6 = type([Socket]), _dec8$5 = tooltip(), _dec9$5 = tooltip(), _dec10$4 = type([Socket]), _dec3$8(_class4$3 = _dec4$7(_class4$3 = _dec5$7(_class4$3 = executeInEditMode(_class4$3 = _dec6$6(_class4$3 = (_class5$3 = (_temp2$3 = _class6$2 = function (_Animation) {
              _inheritsLoose(SkeletalAnimation, _Animation);

              function SkeletalAnimation() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Animation.call.apply(_Animation, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_useBakedAnimation", _descriptor3$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_sockets", _descriptor4$5, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = SkeletalAnimation.prototype;

              _proto.onDestroy = function onDestroy() {
                _Animation.prototype.onDestroy.call(this);

                legacyCC.director.root.dataPoolManager.jointAnimationInfo.destroy(this.node.uuid);
                legacyCC.director.getAnimationManager().removeSockets(this.node, this._sockets);
              };

              _proto.start = function start() {
                this.sockets = this._sockets;
                this.useBakedAnimation = this._useBakedAnimation;

                _Animation.prototype.start.call(this);
              };

              _proto.querySockets = function querySockets() {
                var animPaths = this._defaultClip && Object.keys(SkelAnimDataHub.getOrExtract(this._defaultClip).data).sort().reduce(function (acc, cur) {
                  return cur.startsWith(acc[acc.length - 1]) ? acc : (acc.push(cur), acc);
                }, []) || [];

                if (!animPaths.length) {
                  return ['please specify a valid default animation clip first'];
                }

                var out = [];

                for (var i = 0; i < animPaths.length; i++) {
                  var path = animPaths[i];
                  var node = this.node.getChildByPath(path);

                  if (!node) {
                    continue;
                  }

                  out.push(path);
                  collectRecursively(node, path, out);
                }

                return out;
              };

              _proto.rebuildSocketAnimations = function rebuildSocketAnimations() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._sockets), _step; !(_step = _iterator()).done;) {
                  var socket = _step.value;
                  var joint = this.node.getChildByPath(socket.path);
                  var target = socket.target;

                  if (joint && target) {
                    target.name = socket.path.substring(socket.path.lastIndexOf('/') + 1) + " Socket";
                    target.parent = this.node;
                    getWorldTransformUntilRoot(joint, this.node, m4_1$4);
                    Mat4.fromRTS(m4_2$2, target.rotation, target.position, target.scale);

                    if (!Mat4.equals(m4_2$2, m4_1$4)) {
                      target.matrix = m4_1$4;
                    }
                  }
                }

                for (var _i = 0, _Object$keys = Object.keys(this._nameToState); _i < _Object$keys.length; _i++) {
                  var stateName = _Object$keys[_i];
                  var state = this._nameToState[stateName];
                  state.rebuildSocketCurves(this._sockets);
                }
              };

              _proto.createSocket = function createSocket(path) {
                var socket = this._sockets.find(function (s) {
                  return s.path === path;
                });

                if (socket) {
                  return socket.target;
                }

                var joint = this.node.getChildByPath(path);

                if (!joint) {
                  console.warn('illegal socket path');
                  return null;
                }

                var target = new Node();
                target.parent = this.node;

                this._sockets.push(new Socket(path, target));

                this.rebuildSocketAnimations();
                return target;
              };

              _proto._createState = function _createState(clip, name) {
                return new SkeletalAnimationState(clip, name);
              };

              _proto._doCreateState = function _doCreateState(clip, name) {
                var state = _Animation.prototype._doCreateState.call(this, clip, name);

                state.rebuildSocketCurves(this._sockets);
                return state;
              };

              _createClass(SkeletalAnimation, [{
                key: "sockets",
                get: function get() {
                  return this._sockets;
                },
                set: function set(val) {
                  if (!this._useBakedAnimation) {
                    var animMgr = legacyCC.director.getAnimationManager();
                    animMgr.removeSockets(this.node, this._sockets);
                    animMgr.addSockets(this.node, val);
                  }

                  this._sockets = val;
                  this.rebuildSocketAnimations();
                }
              }, {
                key: "useBakedAnimation",
                get: function get() {
                  return this._useBakedAnimation;
                },
                set: function set(val) {
                  this._useBakedAnimation = val;
                  var comps = this.node.getComponentsInChildren(SkinnedMeshRenderer);

                  for (var i = 0; i < comps.length; ++i) {
                    var comp = comps[i];

                    if (comp.skinningRoot === this.node) {
                      comp.setUseBakedAnimation(this._useBakedAnimation);
                    }
                  }

                  if (this._useBakedAnimation) {
                    legacyCC.director.getAnimationManager().removeSockets(this.node, this._sockets);
                  } else {
                    legacyCC.director.getAnimationManager().addSockets(this.node, this._sockets);
                  }
                }
              }]);

              return SkeletalAnimation;
            }(Animation), _class6$2.Socket = Socket, _temp2$3), (_applyDecoratedDescriptor(_class5$3.prototype, "sockets", [_dec7$6, _dec8$5], Object.getOwnPropertyDescriptor(_class5$3.prototype, "sockets"), _class5$3.prototype), _applyDecoratedDescriptor(_class5$3.prototype, "useBakedAnimation", [_dec9$5], Object.getOwnPropertyDescriptor(_class5$3.prototype, "useBakedAnimation"), _class5$3.prototype), _descriptor3$7 = _applyDecoratedDescriptor(_class5$3.prototype, "_useBakedAnimation", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor4$5 = _applyDecoratedDescriptor(_class5$3.prototype, "_sockets", [_dec10$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class5$3)) || _class4$3) || _class4$3) || _class4$3) || _class4$3) || _class4$3));

            legacyCC.SkeletalAnimationComponent = SkeletalAnimation;
            js.setClassAlias(SkeletalAnimation, 'cc.SkeletalAnimationComponent');

            legacyCC.utils = utils;

            var vec3_temp = new Vec3();

            var _worldMatrix = new Mat4();

            function fillVertices3D(node, renderer, renderData, color) {
              var dataList = renderData.data;
              var buffer = renderer.acquireBufferBatch();
              var vertexOffset = buffer.byteOffset >> 2;
              var vertexCount = renderData.vertexCount;
              var indicesOffset = buffer.indicesOffset;
              var vertexId = buffer.vertexOffset;
              var isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexCount = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              var vBuf = buffer.vData;
              node.getWorldMatrix(_worldMatrix);

              for (var i = 0; i < vertexCount; i++) {
                var vert = dataList[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0);
                Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix);
                vBuf[vertexOffset++] = vec3_temp.x;
                vBuf[vertexOffset++] = vec3_temp.y;
                vBuf[vertexOffset++] = vec3_temp.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              var iBuf = buffer.iData;

              for (var _i = 0; _i < renderData.dataLength; _i++) {
                iBuf[indicesOffset + _i] = vertexId + _i;
              }
            }
            function fillMeshVertices3D(node, renderer, renderData, color) {
              var dataList = renderData.data;
              var buffer = renderer.acquireBufferBatch();
              var vertexOffset = buffer.byteOffset >> 2;
              var vertexCount = renderData.vertexCount;
              var indicesOffset = buffer.indicesOffset;
              var vertexId = buffer.vertexOffset;
              var isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexCount = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              var vBuf = buffer.vData;
              var iBuf = buffer.iData;
              node.getWorldMatrix(_worldMatrix);

              for (var i = 0; i < vertexCount; i++) {
                var vert = dataList[i];
                Vec3.set(vec3_temp, vert.x, vert.y, 0);
                Vec3.transformMat4(vec3_temp, vec3_temp, _worldMatrix);
                vBuf[vertexOffset++] = vec3_temp.x;
                vBuf[vertexOffset++] = vec3_temp.y;
                vBuf[vertexOffset++] = vec3_temp.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              for (var _i2 = 0, count = vertexCount / 4; _i2 < count; _i2++) {
                var start = vertexId + _i2 * 4;
                iBuf[indicesOffset++] = start;
                iBuf[indicesOffset++] = start + 1;
                iBuf[indicesOffset++] = start + 2;
                iBuf[indicesOffset++] = start + 1;
                iBuf[indicesOffset++] = start + 3;
                iBuf[indicesOffset++] = start + 2;
              }
            }
            function fillVerticesWithoutCalc3D(node, renderer, renderData, color) {
              var dataList = renderData.data;
              var buffer = renderer.acquireBufferBatch();
              var vertexOffset = buffer.byteOffset >> 2;
              var vertexCount = renderData.vertexCount;
              var indicesOffset = buffer.indicesOffset;
              var vertexId = buffer.vertexOffset;
              var isRecreate = buffer.request(vertexCount, renderData.indicesCount);

              if (!isRecreate) {
                buffer = renderer.currBufferBatch;
                vertexCount = 0;
                indicesOffset = 0;
                vertexId = 0;
              }

              var vBuf = buffer.vData;

              for (var i = 0; i < vertexCount; i++) {
                var vert = dataList[i];
                vBuf[vertexOffset++] = vert.x;
                vBuf[vertexOffset++] = vert.y;
                vBuf[vertexOffset++] = vert.z;
                vBuf[vertexOffset++] = vert.u;
                vBuf[vertexOffset++] = vert.v;
                Color.toArray(vBuf, color, vertexOffset);
                vertexOffset += 4;
              }

              var iBuf = buffer.iData;
              iBuf[indicesOffset++] = vertexId;
              iBuf[indicesOffset++] = vertexId + 1;
              iBuf[indicesOffset++] = vertexId + 2;
              iBuf[indicesOffset++] = vertexId + 1;
              iBuf[indicesOffset++] = vertexId + 3;
              iBuf[indicesOffset++] = vertexId + 2;
            }

            var space = 2;
            var Atlas = function () {
              function Atlas(width, height) {
                this._texture = void 0;
                this._width = void 0;
                this._height = void 0;
                this._x = void 0;
                this._y = void 0;
                this._nexty = void 0;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = void 0;
                this._count = void 0;
                var texture = new DynamicAtlasTexture();
                texture.initWithSize(width, height);
                this._texture = texture;
                this._width = width;
                this._height = height;
                this._x = space;
                this._y = space;
                this._nexty = space;
                this._innerTextureInfos = {};
                this._innerSpriteFrames = [];
                this._count = 0;
              }

              var _proto = Atlas.prototype;

              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                var rect = spriteFrame.rect;
                var texture = spriteFrame.texture;

                var info = this._innerTextureInfos[texture.getId()];

                var sx = rect.x;
                var sy = rect.y;

                if (info) {
                  sx += info.x;
                  sy += info.y;
                } else {
                  var width = texture.width;
                  var height = texture.height;

                  if (this._x + width + space > this._width) {
                    this._x = space;
                    this._y = this._nexty;
                  }

                  if (this._y + height + space > this._nexty) {
                    this._nexty = this._y + height + space;
                  }

                  if (this._nexty > this._height) {
                    return null;
                  }

                  if (legacyCC.internal.dynamicAtlasManager.textureBleeding) {
                    if (width <= 8 || height <= 8) {
                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x - 1, this._y + 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y - 1);

                      this._texture.drawTextureAt(texture.image, this._x + 1, this._y + 1);
                    }

                    this._texture.drawTextureAt(texture.image, this._x - 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x + 1, this._y);

                    this._texture.drawTextureAt(texture.image, this._x, this._y - 1);

                    this._texture.drawTextureAt(texture.image, this._x, this._y + 1);
                  }

                  this._texture.drawTextureAt(texture.image, this._x, this._y);

                  this._innerTextureInfos[texture.getId()] = {
                    x: this._x,
                    y: this._y,
                    texture: texture
                  };
                  this._count++;
                  sx += this._x;
                  sy += this._y;
                  this._x += width + space;
                }

                var frame = {
                  x: sx,
                  y: sy,
                  texture: this._texture
                };

                this._innerSpriteFrames.push(spriteFrame);

                return frame;
              };

              _proto.deleteInnerTexture = function deleteInnerTexture(texture) {
                if (texture && this._innerTextureInfos[texture.getId()]) {
                  delete this._innerTextureInfos[texture.getId()];
                  this._count--;
                }
              };

              _proto.isEmpty = function isEmpty() {
                return this._count <= 0;
              };

              _proto.reset = function reset() {
                this._x = space;
                this._y = space;
                this._nexty = space;
                var frames = this._innerSpriteFrames;

                for (var i = 0, l = frames.length; i < l; i++) {
                  var frame = frames[i];

                  if (!frame.isValid) {
                    continue;
                  }

                  frame._resetDynamicAtlasFrame();
                }

                this._innerSpriteFrames.length = 0;
                this._innerTextureInfos = {};
              };

              _proto.destroy = function destroy() {
                this.reset();

                this._texture.destroy();
              };

              return Atlas;
            }();
            var DynamicAtlasTexture = function (_Texture2D) {
              _inheritsLoose(DynamicAtlasTexture, _Texture2D);

              function DynamicAtlasTexture() {
                return _Texture2D.apply(this, arguments) || this;
              }

              var _proto2 = DynamicAtlasTexture.prototype;

              _proto2.initWithSize = function initWithSize(width, height, format) {
                if (format === void 0) {
                  format = PixelFormat.RGBA8888;
                }

                this.reset({
                  width: width,
                  height: height,
                  format: format
                });
                this.loaded = true;
                this.emit('load');
              };

              _proto2.drawTextureAt = function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                var gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                var region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              };

              return DynamicAtlasTexture;
            }(Texture2D);

            var DynamicAtlasManager = function () {
              function DynamicAtlasManager() {
                this._atlases = [];
                this._atlasIndex = -1;
                this._maxAtlasCount = 5;
                this._textureSize = 2048;
                this._maxFrameSize = 512;
                this._textureBleeding = true;
                this._enabled = false;
              }

              var _proto = DynamicAtlasManager.prototype;

              _proto.newAtlas = function newAtlas() {
                var atlas = this._atlases[++this._atlasIndex];

                if (!atlas) {
                  atlas = new Atlas(this._textureSize, this._textureSize);

                  this._atlases.push(atlas);
                }

                return atlas;
              };

              _proto.beforeSceneLoad = function beforeSceneLoad() {
                this.reset();
              };

              _proto.insertSpriteFrame = function insertSpriteFrame(spriteFrame) {
                if (!this._enabled || this._atlasIndex === this._maxAtlasCount || !spriteFrame || spriteFrame._original) return null;
                if (!spriteFrame.packable) return null;
                var atlas = this._atlases[this._atlasIndex];

                if (!atlas) {
                  atlas = this.newAtlas();
                }

                var frame = atlas.insertSpriteFrame(spriteFrame);

                if (!frame && this._atlasIndex !== this._maxAtlasCount) {
                  atlas = this.newAtlas();
                  return atlas.insertSpriteFrame(spriteFrame);
                }

                return frame;
              };

              _proto.reset = function reset() {
                for (var i = 0, l = this._atlases.length; i < l; i++) {
                  this._atlases[i].destroy();
                }

                this._atlases.length = 0;
                this._atlasIndex = -1;
              };

              _proto.deleteAtlasSpriteFrame = function deleteAtlasSpriteFrame(spriteFrame) {
                if (!spriteFrame._original) return;
                var texture = spriteFrame._original._texture;
                this.deleteAtlasTexture(texture);
              };

              _proto.deleteAtlasTexture = function deleteAtlasTexture(texture) {
                if (texture) {
                  for (var i = this._atlases.length - 1; i >= 0; i--) {
                    this._atlases[i].deleteInnerTexture(texture);

                    if (this._atlases[i].isEmpty()) {
                      this._atlases[i].destroy();

                      this._atlases.splice(i, 1);

                      this._atlasIndex--;
                    }
                  }
                }
              };

              _proto.packToDynamicAtlas = function packToDynamicAtlas(comp, frame) {

                if (!frame._original && frame.packable) {
                  var packedFrame = this.insertSpriteFrame(frame);

                  if (packedFrame) {
                    frame._setDynamicAtlasFrame(packedFrame);
                  }
                }
              };

              _createClass(DynamicAtlasManager, [{
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(value) {
                  if (this._enabled === value) return;

                  if (value) {
                    this.reset();
                    legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                  } else {
                    legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
                  }

                  this._enabled = value;
                }
              }, {
                key: "maxAtlasCount",
                get: function get() {
                  return this._maxAtlasCount;
                },
                set: function set(value) {
                  this._maxAtlasCount = value;
                }
              }, {
                key: "atlasCount",
                get: function get() {
                  return this._atlases.length;
                }
              }, {
                key: "textureBleeding",
                get: function get() {
                  return this._textureBleeding;
                },
                set: function set(enable) {
                  this._textureBleeding = enable;
                }
              }, {
                key: "textureSize",
                get: function get() {
                  return this._textureSize;
                },
                set: function set(value) {
                  this._textureSize = value;
                }
              }, {
                key: "maxFrameSize",
                get: function get() {
                  return this._maxFrameSize;
                },
                set: function set(value) {
                  this._maxFrameSize = value;
                }
              }]);

              return DynamicAtlasManager;
            }();
            DynamicAtlasManager.instance = void 0;
            var dynamicAtlasManager = exports('dynamicAtlasManager', DynamicAtlasManager.instance = new DynamicAtlasManager());
            legacyCC.internal.dynamicAtlasManager = dynamicAtlasManager;

            var _dec$a, _class$a, _temp$a;
            var INSET_LEFT = 0;
            var INSET_TOP = 1;
            var INSET_RIGHT = 2;
            var INSET_BOTTOM = 3;
            var temp_uvs = [{
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }];
            var SpriteFrame = exports('SpriteFrame', (_dec$a = ccclass('cc.SpriteFrame'), _dec$a(_class$a = (_temp$a = function (_Asset) {
              _inheritsLoose(SpriteFrame, _Asset);

              SpriteFrame.createWithImage = function createWithImage(imageSourceOrImageAsset) {
                var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
                var tex = new Texture2D();
                tex.image = img;
                var spf = new SpriteFrame();
                spf.texture = tex;
                return spf;
              };

              _createClass(SpriteFrame, [{
                key: "insetTop",
                get: function get() {
                  return this._capInsets[INSET_TOP];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_TOP] === value) {
                    return;
                  }

                  this._capInsets[INSET_TOP] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetBottom",
                get: function get() {
                  return this._capInsets[INSET_BOTTOM];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_BOTTOM] === value) {
                    return;
                  }

                  this._capInsets[INSET_BOTTOM] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetLeft",
                get: function get() {
                  return this._capInsets[INSET_LEFT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_LEFT] === value) {
                    return;
                  }

                  this._capInsets[INSET_LEFT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "insetRight",
                get: function get() {
                  return this._capInsets[INSET_RIGHT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_RIGHT] === value) {
                    return;
                  }

                  this._capInsets[INSET_RIGHT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(value) {
                  if (this._rect.equals(value)) {
                    return;
                  }

                  this._rect.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
              }, {
                key: "originalSize",
                get: function get() {
                  return this._originalSize;
                },
                set: function set(value) {
                  if (this._originalSize.equals(value)) {
                    return;
                  }

                  this._originalSize.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset.set(value);
                }
              }, {
                key: "rotated",
                get: function get() {
                  return this._rotated;
                },
                set: function set(rotated) {
                  if (this._rotated === rotated) {
                    return;
                  }

                  this._rotated = rotated;

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(value) {
                  if (!value) {
                    console.warn("Error Texture in " + this.name);
                    return;
                  }

                  this.reset({
                    texture: value
                  }, true);
                }
              }, {
                key: "atlasUuid",
                get: function get() {
                  return this._atlasUuid;
                },
                set: function set(value) {
                  this._atlasUuid = value;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._texture.width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._texture.height;
                }
              }, {
                key: "_textureSource",
                set: function set(value) {
                  if (window.Build) {
                    this._texture = value;
                    return;
                  }

                  if (value) {
                    this._refreshTexture(value);

                    this._calculateUV();
                  }
                }
              }, {
                key: "flipUVX",
                get: function get() {
                  return this._isFlipUVX;
                },
                set: function set(value) {
                  this._isFlipUVX = value;

                  this._calculateUV();
                }
              }, {
                key: "flipUVY",
                get: function get() {
                  return this._isFlipUVY;
                },
                set: function set(value) {
                  this._isFlipUVY = value;

                  this._calculateUV();
                }
              }, {
                key: "packable",
                get: function get() {
                  return this._packable;
                },
                set: function set(value) {
                  this._packable = value;
                }
              }, {
                key: "original",
                get: function get() {
                  return this._original;
                }
              }]);

              function SpriteFrame() {
                var _this;

                _this = _Asset.call(this) || this;
                _this.vertices = null;
                _this.uv = [];
                _this.uvHash = 0;
                _this.unbiasUV = [];
                _this.uvSliced = [];
                _this._rect = new Rect$1();
                _this._offset = new Vec2();
                _this._originalSize = new Size();
                _this._rotated = false;
                _this._capInsets = [0, 0, 0, 0];
                _this._atlasUuid = '';
                _this._texture = void 0;
                _this._isFlipUVY = false;
                _this._isFlipUVX = false;
                _this._original = null;
                _this._packable = true;

                return _this;
              }

              var _proto = SpriteFrame.prototype;

              _proto.textureLoaded = function textureLoaded() {
                return this.texture && this.texture.loaded;
              };

              _proto.isRotated = function isRotated() {
                return this._rotated;
              };

              _proto.setRotated = function setRotated(rotated) {
                this.rotated = rotated;
              };

              _proto.getRect = function getRect(out) {
                if (out) {
                  out.set(this._rect);
                  return out;
                }

                return this._rect.clone();
              };

              _proto.setRect = function setRect(rect) {
                this.rect = rect;
              };

              _proto.getOriginalSize = function getOriginalSize(out) {
                if (out) {
                  out.set(this._originalSize);
                  return out;
                }

                return this._originalSize.clone();
              };

              _proto.setOriginalSize = function setOriginalSize(size) {
                this.originalSize = size;
              };

              _proto.getOffset = function getOffset(out) {
                if (out) {
                  out.set(this._offset);
                  return out;
                }

                return this._offset.clone();
              };

              _proto.setOffset = function setOffset(offset) {
                this.offset = offset;
              };

              _proto.getGFXTexture = function getGFXTexture() {
                return this._texture.getGFXTexture();
              };

              _proto.getGFXSampler = function getGFXSampler() {
                return this._texture.getGFXSampler();
              };

              _proto.getHash = function getHash() {
                return this._texture.getHash();
              };

              _proto.getSamplerHash = function getSamplerHash() {
                return this._texture.getSamplerHash();
              };

              _proto.reset = function reset(info, clearData) {
                if (clearData === void 0) {
                  clearData = false;
                }

                var calUV = false;

                if (clearData) {
                  this._originalSize.set(0, 0);

                  this._rect.set(0, 0, 0, 0);

                  this._offset.set(0, 0);

                  this._capInsets = [0, 0, 0, 0];
                  this._rotated = false;
                  calUV = true;
                }

                if (info) {
                  if (info.texture) {
                    this.loaded = false;
                    this._rect.x = this._rect.y = 0;
                    this._rect.width = info.texture.width;
                    this._rect.height = info.texture.height;

                    this._refreshTexture(info.texture);

                    this.checkRect(this._texture);
                  }

                  if (info.originalSize) {
                    this._originalSize.set(info.originalSize);
                  }

                  if (info.rect) {
                    this._rect.set(info.rect);
                  }

                  if (info.offset) {
                    this._offset.set(info.offset);
                  }

                  if (info.borderTop !== undefined) {
                    this._capInsets[INSET_TOP] = info.borderTop;
                  }

                  if (info.borderBottom !== undefined) {
                    this._capInsets[INSET_BOTTOM] = info.borderBottom;
                  }

                  if (info.borderLeft !== undefined) {
                    this._capInsets[INSET_LEFT] = info.borderLeft;
                  }

                  if (info.borderRight !== undefined) {
                    this._capInsets[INSET_RIGHT] = info.borderRight;
                  }

                  if (info.isRotate !== undefined) {
                    this._rotated = !!info.isRotate;
                  }

                  if (info.isFlipUv !== undefined) {
                    this._isFlipUVY = !!info.isFlipUv;
                  }

                  calUV = true;
                }

                if (calUV && this.texture) {
                  this._calculateUV();
                }
              };

              _proto.checkRect = function checkRect(texture) {
                var rect = this._rect;
                var maxX = rect.x;
                var maxY = rect.y;

                if (this._rotated) {
                  maxX += rect.height;
                  maxY += rect.width;
                } else {
                  maxX += rect.width;
                  maxY += rect.height;
                }

                if (maxX > texture.width) {
                  errorID(3300, this.name + "/" + texture.name, maxX, texture.width);
                  return false;
                }

                if (maxY > texture.height) {
                  errorID(3301, this.name + "/" + texture.name, maxY, texture.height);
                  return false;
                }

                return true;
              };

              _proto.onLoaded = function onLoaded() {
                this.loaded = true;
                this.emit('load');
              };

              _proto.destroy = function destroy() {
                if (this._packable && dynamicAtlasManager) {
                  dynamicAtlasManager.deleteAtlasSpriteFrame(this);
                }

                return _Asset.prototype.destroy.call(this);
              };

              _proto._calculateSlicedUV = function _calculateSlicedUV() {
                var rect = this._rect;
                var tex = this.texture;
                var atlasWidth = tex.width;
                var atlasHeight = tex.height;
                var leftWidth = this._capInsets[INSET_LEFT];
                var rightWidth = this._capInsets[INSET_RIGHT];
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = this._capInsets[INSET_TOP];
                var bottomHeight = this._capInsets[INSET_BOTTOM];
                var centerHeight = rect.height - topHeight - bottomHeight;
                var uvSliced = this.uvSliced;
                uvSliced.length = 0;

                if (this._rotated) {
                  temp_uvs[0].u = (rect.x + 0.5) / atlasWidth;
                  temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
                  temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.height - 0.5) / atlasWidth;
                  temp_uvs[3].v = (rect.y + 0.5) / atlasHeight;
                  temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
                  temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.width - 0.5) / atlasHeight;

                  for (var row = 0; row < 4; ++row) {
                    var rowD = temp_uvs[row];

                    for (var col = 0; col < 4; ++col) {
                      var colD = temp_uvs[3 - col];
                      uvSliced.push({
                        u: rowD.u,
                        v: colD.v
                      });
                    }
                  }
                } else {
                  temp_uvs[0].u = (rect.x + 0.5) / atlasWidth;
                  temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
                  temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
                  temp_uvs[3].u = (rect.x + rect.width - 0.5) / atlasWidth;
                  temp_uvs[3].v = (rect.y + 0.5) / atlasHeight;
                  temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
                  temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
                  temp_uvs[0].v = (rect.y + rect.height - 0.5) / atlasHeight;

                  for (var _row = 0; _row < 4; ++_row) {
                    var _rowD = temp_uvs[_row];

                    for (var _col = 0; _col < 4; ++_col) {
                      var _colD = temp_uvs[_col];
                      uvSliced.push({
                        u: _colD.u,
                        v: _rowD.v
                      });
                    }
                  }
                }
              };

              _proto._calculateUV = function _calculateUV() {
                var rect = this._rect;
                var uv = this.uv;
                var unbiasUV = this.unbiasUV;
                var tex = this.texture;
                var texw = tex.width;
                var texh = tex.height;

                if (this._rotated) {
                  var l = texw === 0 ? 0 : (rect.x + 0.5) / texw;
                  var r = texw === 0 ? 0 : (rect.x + rect.height - 0.5) / texw;
                  var t = texh === 0 ? 0 : (rect.y + 0.5) / texh;
                  var b = texh === 0 ? 0 : (rect.y + rect.width - 0.5) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = r;
                    uv[1] = b;
                    uv[2] = r;
                    uv[3] = t;
                    uv[4] = l;
                    uv[5] = b;
                    uv[6] = l;
                    uv[7] = t;
                  } else if (this._isFlipUVX) {
                    uv[0] = r;
                    uv[1] = t;
                    uv[2] = r;
                    uv[3] = b;
                    uv[4] = l;
                    uv[5] = t;
                    uv[6] = l;
                    uv[7] = b;
                  } else if (this._isFlipUVY) {
                    uv[0] = l;
                    uv[1] = b;
                    uv[2] = l;
                    uv[3] = t;
                    uv[4] = r;
                    uv[5] = b;
                    uv[6] = r;
                    uv[7] = t;
                  } else {
                    uv[0] = l;
                    uv[1] = t;
                    uv[2] = l;
                    uv[3] = b;
                    uv[4] = r;
                    uv[5] = t;
                    uv[6] = r;
                    uv[7] = b;
                  }

                  var ul = texw === 0 ? 0 : rect.x / texw;
                  var ur = texw === 0 ? 0 : (rect.x + rect.height) / texw;
                  var ut = texh === 0 ? 0 : rect.y / texh;
                  var ub = texh === 0 ? 0 : (rect.y + rect.width) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ut;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = ur;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ur;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ul;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ul;
                    unbiasUV[7] = ub;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ub;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ut;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ub;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ut;
                  } else {
                    unbiasUV[0] = ul;
                    unbiasUV[1] = ut;
                    unbiasUV[2] = ul;
                    unbiasUV[3] = ub;
                    unbiasUV[4] = ur;
                    unbiasUV[5] = ut;
                    unbiasUV[6] = ur;
                    unbiasUV[7] = ub;
                  }
                } else {
                  var _l = texw === 0 ? 0 : (rect.x + 0.5) / texw;

                  var _r = texw === 0 ? 0 : (rect.x + rect.width - 0.5) / texw;

                  var _b = texh === 0 ? 0 : (rect.y + rect.height - 0.5) / texh;

                  var _t = texh === 0 ? 0 : (rect.y + 0.5) / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    uv[0] = _r;
                    uv[1] = _t;
                    uv[2] = _l;
                    uv[3] = _t;
                    uv[4] = _r;
                    uv[5] = _b;
                    uv[6] = _l;
                    uv[7] = _b;
                  } else if (this._isFlipUVX) {
                    uv[0] = _r;
                    uv[1] = _b;
                    uv[2] = _l;
                    uv[3] = _b;
                    uv[4] = _r;
                    uv[5] = _t;
                    uv[6] = _l;
                    uv[7] = _t;
                  } else if (this._isFlipUVY) {
                    uv[0] = _l;
                    uv[1] = _t;
                    uv[2] = _r;
                    uv[3] = _t;
                    uv[4] = _l;
                    uv[5] = _b;
                    uv[6] = _r;
                    uv[7] = _b;
                  } else {
                    uv[0] = _l;
                    uv[1] = _b;
                    uv[2] = _r;
                    uv[3] = _b;
                    uv[4] = _l;
                    uv[5] = _t;
                    uv[6] = _r;
                    uv[7] = _t;
                  }

                  var _ul = texw === 0 ? 0 : rect.x / texw;

                  var _ur = texw === 0 ? 0 : (rect.x + rect.width) / texw;

                  var _ub = texh === 0 ? 0 : (rect.y + rect.height) / texh;

                  var _ut = texh === 0 ? 0 : rect.y / texh;

                  if (this._isFlipUVX && this._isFlipUVY) {
                    unbiasUV[0] = _ur;
                    unbiasUV[1] = _ut;
                    unbiasUV[2] = _ul;
                    unbiasUV[3] = _ut;
                    unbiasUV[4] = _ur;
                    unbiasUV[5] = _ub;
                    unbiasUV[6] = _ul;
                    unbiasUV[7] = _ub;
                  } else if (this._isFlipUVX) {
                    unbiasUV[0] = _ur;
                    unbiasUV[1] = _ub;
                    unbiasUV[2] = _ul;
                    unbiasUV[3] = _ub;
                    unbiasUV[4] = _ur;
                    unbiasUV[5] = _ut;
                    unbiasUV[6] = _ul;
                    unbiasUV[7] = _ut;
                  } else if (this._isFlipUVY) {
                    unbiasUV[0] = _ul;
                    unbiasUV[1] = _ut;
                    unbiasUV[2] = _ur;
                    unbiasUV[3] = _ut;
                    unbiasUV[4] = _ul;
                    unbiasUV[5] = _ub;
                    unbiasUV[6] = _ur;
                    unbiasUV[7] = _ub;
                  } else {
                    unbiasUV[0] = _ul;
                    unbiasUV[1] = _ub;
                    unbiasUV[2] = _ur;
                    unbiasUV[3] = _ub;
                    unbiasUV[4] = _ul;
                    unbiasUV[5] = _ut;
                    unbiasUV[6] = _ur;
                    unbiasUV[7] = _ut;
                  }
                }

                var uvHashStr = '';

                for (var i = 0; i < uv.length; i++) {
                  uvHashStr += uv[i];
                }

                this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
                var vertices = this.vertices;

                if (vertices) {
                  vertices.nu.length = 0;
                  vertices.nv.length = 0;

                  for (var _i = 0; _i < vertices.u.length; _i++) {
                    vertices.nu[_i] = vertices.u[_i] / texw;
                    vertices.nv[_i] = vertices.v[_i] / texh;
                  }
                }

                this._calculateSlicedUV();
              };

              _proto._setDynamicAtlasFrame = function _setDynamicAtlasFrame(frame) {
                if (!frame) return;
                this._original = {
                  _texture: this._texture,
                  _x: this._rect.x,
                  _y: this._rect.y
                };
                this._texture = frame.texture;
                this._rect.x = frame.x;
                this._rect.y = frame.y;

                this._calculateUV();
              };

              _proto._resetDynamicAtlasFrame = function _resetDynamicAtlasFrame() {
                if (!this._original) return;
                this._rect.x = this._original._x;
                this._rect.y = this._original._y;
                this._texture = this._original._texture;
                this._original = null;

                this._calculateUV();
              };

              _proto._checkPackable = function _checkPackable() {
                var dynamicAtlas = dynamicAtlasManager;
                if (!dynamicAtlas) return;
                var texture = this._texture;

                if (!(texture instanceof Texture2D) || texture.isCompressed) {
                  this._packable = false;
                  return;
                }

                var w = this.width;
                var h = this.height;

                if (!texture.image || w > dynamicAtlas.maxFrameSize || h > dynamicAtlas.maxFrameSize) {
                  this._packable = false;
                  return;
                }

                if (texture.image && texture.image instanceof HTMLCanvasElement) {
                  this._packable = true;
                }
              };

              _proto._serialize = function _serialize(ctxForExporting) {
              };

              _proto._deserialize = function _deserialize(serializeData, handle) {
                var data = serializeData;
                var rect = data.rect;

                if (rect) {
                  this._rect = new Rect$1(rect.x, rect.y, rect.width, rect.height);
                }

                var offset = data.offset;

                if (data.offset) {
                  this._offset = new Vec2(offset.x, offset.y);
                }

                var originalSize = data.originalSize;

                if (data.originalSize) {
                  this._originalSize = new Size(originalSize.width, originalSize.height);
                }

                this._rotated = !!data.rotated;
                this._name = data.name;
                this._packable = !!data.packable;
                var capInsets = data.capInsets;

                if (capInsets) {
                  this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
                  this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
                  this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
                  this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
                }

                this.vertices = data.vertices;

                if (this.vertices) {
                  this.vertices.nu = [];
                  this.vertices.nv = [];
                }
              };

              _proto.clone = function clone() {
                var _v$nu, _v$u, _v$nv, _v$v, _sp$uv, _sp$unbiasUV, _sp$uvSliced, _sp$_capInsets;

                var sp = new SpriteFrame();
                var v = this.vertices;
                sp.vertices = v ? {
                  x: v.x,
                  y: v.y,
                  triangles: v.triangles,
                  nu: (_v$nu = v.nu) === null || _v$nu === void 0 ? void 0 : _v$nu.slice(0),
                  u: (_v$u = v.u) === null || _v$u === void 0 ? void 0 : _v$u.slice(0),
                  nv: (_v$nv = v.nv) === null || _v$nv === void 0 ? void 0 : _v$nv.slice(0),
                  v: (_v$v = v.v) === null || _v$v === void 0 ? void 0 : _v$v.slice(0)
                } : null;

                (_sp$uv = sp.uv).splice.apply(_sp$uv, [0, sp.uv.length].concat(this.uv));

                sp.uvHash = this.uvHash;

                (_sp$unbiasUV = sp.unbiasUV).splice.apply(_sp$unbiasUV, [0, sp.unbiasUV.length].concat(this.unbiasUV));

                (_sp$uvSliced = sp.uvSliced).splice.apply(_sp$uvSliced, [0, sp.uvSliced.length].concat(this.uvSliced));

                sp._rect.set(this._rect);

                sp._offset.set(this._offset);

                sp._originalSize.set(this._originalSize);

                sp._rotated = this._rotated;

                (_sp$_capInsets = sp._capInsets).splice.apply(_sp$_capInsets, [0, sp._capInsets.length].concat(this._capInsets));

                sp._atlasUuid = this._atlasUuid;
                sp._texture = this._texture;
                sp._isFlipUVX = this._isFlipUVX;
                sp._isFlipUVY = this._isFlipUVY;
                return sp;
              };

              _proto._textureLoaded = function _textureLoaded() {
                var tex = this._texture;
                var config = {};
                var isReset = false;

                if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
                  config.rect = new Rect$1(0, 0, tex.width, tex.height);
                  isReset = true;
                }

                if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
                  config.originalSize = new Size(tex.width, tex.height);
                  isReset = true;
                }

                if (isReset) {
                  this.reset(config);
                  this.onLoaded();
                }

                this._checkPackable();
              };

              _proto._refreshTexture = function _refreshTexture(texture) {
                this._texture = texture;

                if (texture.loaded) {
                  this._textureLoaded();
                } else {
                  texture.once('load', this._textureLoaded, this);
                }
              };

              return SpriteFrame;
            }(Asset), _temp$a)) || _class$a));
            legacyCC.SpriteFrame = SpriteFrame;

            var _dec$b, _class$b, _class2$a, _descriptor$a, _temp$b;
            var SpriteAtlas = exports('SpriteAtlas', (_dec$b = ccclass('cc.SpriteAtlas'), _dec$b(_class$b = (_class2$a = (_temp$b = function (_Asset) {
              _inheritsLoose(SpriteAtlas, _Asset);

              function SpriteAtlas() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Asset.call.apply(_Asset, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "spriteFrames", _descriptor$a, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = SpriteAtlas.prototype;

              _proto.getTexture = function getTexture() {
                var keys = Object.keys(this.spriteFrames);

                if (keys.length > 0) {
                  var spriteFrame = this.spriteFrames[keys[0]];
                  return spriteFrame && spriteFrame.texture;
                } else {
                  return null;
                }
              };

              _proto.getSpriteFrame = function getSpriteFrame(key) {
                var sf = this.spriteFrames[key];

                if (!sf) {
                  return null;
                }

                if (!sf.name) {
                  sf.name = key;
                }

                return sf;
              };

              _proto.getSpriteFrames = function getSpriteFrames() {
                var frames = [];
                var spriteFrames = this.spriteFrames;

                for (var _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                  var _key2 = _Object$keys[_i];
                  frames.push(spriteFrames[_key2]);
                }

                return frames;
              };

              _proto._serialize = function _serialize(ctxForExporting) {
              };

              _proto._deserialize = function _deserialize(serializeData, handle) {
                var data = serializeData;
                this._name = data.name;
                var frames = data.spriteFrames;
                this.spriteFrames = createMap();

                for (var i = 0; i < frames.length; i += 2) {
                  handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
                }
              };

              return SpriteAtlas;
            }(Asset), _temp$b), (_descriptor$a = _applyDecoratedDescriptor(_class2$a.prototype, "spriteFrames", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return createMap();
              }
            })), _class2$a)) || _class$b));
            legacyCC.SpriteAtlas = SpriteAtlas;

            var _dec$c, _class$c;
            var Font = exports('Font', (_dec$c = ccclass('cc.Font'), _dec$c(_class$c = function (_Asset) {
              _inheritsLoose(Font, _Asset);

              function Font() {
                return _Asset.apply(this, arguments) || this;
              }

              return Font;
            }(Asset)) || _class$c));
            legacyCC.Font = Font;

            var _dec$d, _class$d, _class2$b, _descriptor$b, _temp$c;
            var TTFFont = exports('TTFFont', (_dec$d = ccclass('cc.TTFFont'), _dec$d(_class$d = (_class2$b = (_temp$c = function (_Font) {
              _inheritsLoose(TTFFont, _Font);

              function TTFFont() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Font.call.apply(_Font, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_fontFamily", _descriptor$b, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(TTFFont, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  this._fontFamily = value || 'Arial';
                }
              }, {
                key: "_nativeDep",
                get: function get() {
                  return {
                    uuid: this._uuid,
                    __nativeName__: this._native,
                    ext: extname(this._native),
                    __isNative__: true
                  };
                }
              }]);

              return TTFFont;
            }(Font), _temp$c), (_descriptor$b = _applyDecoratedDescriptor(_class2$b.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$b.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$b.prototype, "_nativeAsset"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "_nativeDep", [override], Object.getOwnPropertyDescriptor(_class2$b.prototype, "_nativeDep"), _class2$b.prototype)), _class2$b)) || _class$d));
            legacyCC.TTFFont = TTFFont;

            var _dec$e, _dec2$9, _class$e, _class2$c, _descriptor$c, _descriptor2$9, _descriptor3$8, _descriptor4$6, _temp$d;
            var FontLetterDefinition = function FontLetterDefinition() {
              this.u = 0;
              this.v = 0;
              this.w = 0;
              this.h = 0;
              this.offsetX = 0;
              this.offsetY = 0;
              this.textureID = 0;
              this.valid = false;
              this.xAdvance = 0;
            };
            var FontAtlas = function () {
              function FontAtlas(texture) {
                this.letterDefinitions = {};
                this.texture = texture;
              }

              var _proto = FontAtlas.prototype;

              _proto.addLetterDefinitions = function addLetterDefinitions(letter, letterDefinition) {
                this.letterDefinitions[letter] = letterDefinition;
              };

              _proto.cloneLetterDefinition = function cloneLetterDefinition() {
                var copyLetterDefinitions = {};

                for (var _i = 0, _Object$keys = Object.keys(this.letterDefinitions); _i < _Object$keys.length; _i++) {
                  var _key = _Object$keys[_i];
                  var value = new FontLetterDefinition();
                  mixin(value, this.letterDefinitions[_key]);
                  copyLetterDefinitions[_key] = value;
                }

                return copyLetterDefinitions;
              };

              _proto.getTexture = function getTexture() {
                return this.texture;
              };

              _proto.getLetter = function getLetter(key) {
                return this.letterDefinitions[key];
              };

              _proto.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char, labelInfo) {
                var key = _char.charCodeAt(0);

                var hasKey = this.letterDefinitions.hasOwnProperty(key);
                var letter;

                if (hasKey) {
                  letter = this.letterDefinitions[key];
                } else {
                  letter = null;
                }

                return letter;
              };

              _proto.clear = function clear() {
                this.letterDefinitions = {};
              };

              return FontAtlas;
            }();
            var BitmapFont = exports('BitmapFont', (_dec$e = ccclass('cc.BitmapFont'), _dec2$9 = type(SpriteFrame), _dec$e(_class$e = (_class2$c = (_temp$d = function (_Font) {
              _inheritsLoose(BitmapFont, _Font);

              function BitmapFont() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                _this = _Font.call.apply(_Font, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "fntDataStr", _descriptor$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "spriteFrame", _descriptor2$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "fontSize", _descriptor3$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "fntConfig", _descriptor4$6, _assertThisInitialized(_this));

                return _this;
              }

              var _proto2 = BitmapFont.prototype;

              _proto2.onLoaded = function onLoaded() {
                var spriteFrame = this.spriteFrame;

                if (!this.fontDefDictionary && spriteFrame) {
                  this.fontDefDictionary = new FontAtlas(spriteFrame.texture);
                }

                var fntConfig = this.fntConfig;

                if (!fntConfig) {
                  warn('The fnt config is not exists!');
                  return;
                }

                var fontDict = fntConfig.fontDefDictionary;

                for (var fontDef in fontDict) {
                  var letter = new FontLetterDefinition();
                  var rect = fontDict[fontDef].rect;
                  letter.offsetX = fontDict[fontDef].xOffset;
                  letter.offsetY = fontDict[fontDef].yOffset;
                  letter.w = rect.width;
                  letter.h = rect.height;
                  letter.u = rect.x;
                  letter.v = rect.y;
                  letter.textureID = 0;
                  letter.valid = true;
                  letter.xAdvance = fontDict[fontDef].xAdvance;
                  this.fontDefDictionary.addLetterDefinitions(fontDef, letter);
                }
              };

              return BitmapFont;
            }(Font), _temp$d), (_descriptor$c = _applyDecoratedDescriptor(_class2$c.prototype, "fntDataStr", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$9 = _applyDecoratedDescriptor(_class2$c.prototype, "spriteFrame", [_dec2$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$c.prototype, "fontSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return -1;
              }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$c.prototype, "fntConfig", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$c)) || _class$e));
            legacyCC.BitmapFont = BitmapFont;

            var _dec$f, _class$f;
            var LabelAtlas = exports('LabelAtlas', (_dec$f = ccclass('cc.LabelAtlas'), _dec$f(_class$f = function (_BitmapFont) {
              _inheritsLoose(LabelAtlas, _BitmapFont);

              function LabelAtlas() {
                return _BitmapFont.apply(this, arguments) || this;
              }

              return LabelAtlas;
            }(BitmapFont)) || _class$f));
            legacyCC.LabelAtlas = LabelAtlas;

            var BASELINE_RATIO = exports('BASELINE_RATIO', 0.26);
            var _BASELINE_OFFSET = 0;

            var MIDDLE_RATIO = exports('MIDDLE_RATIO', (BASELINE_RATIO + 1) / 2 - BASELINE_RATIO);
            function getBaselineOffset() {
              return _BASELINE_OFFSET;
            }
            var MAX_CACHE_SIZE = 100;
            var pool = new Pool$1(2);

            pool.get = function () {
              return this._get() || {
                key: '',
                value: 0,
                prev: null,
                next: null
              };
            };

            var LRUCache = function () {
              function LRUCache(size) {
                this.count = 0;
                this.limit = 0;
                this.datas = {};
                this.limit = size;
              }

              var _proto = LRUCache.prototype;

              _proto.moveToHead = function moveToHead(node) {
                node.next = this.head;
                node.prev = null;
                if (this.head) this.head.prev = node;
                this.head = node;
                if (!this.tail) this.tail = node;
                this.count++;
                this.datas[node.key] = node;
              };

              _proto.put = function put(key, value) {
                var node = pool.get();
                node.key = key;
                node.value = value;

                if (this.count >= this.limit) {
                  var discard = this.tail;
                  delete this.datas[discard.key];
                  this.count--;
                  this.tail = discard.prev;
                  this.tail.next = null;
                  discard.prev = null;
                  discard.next = null;
                  pool.put(discard);
                }

                this.moveToHead(node);
              };

              _proto.remove = function remove(node) {
                if (node.prev) {
                  node.prev.next = node.next;
                } else {
                  this.head = node.next;
                }

                if (node.next) {
                  node.next.prev = node.prev;
                } else {
                  this.tail = node.prev;
                }

                delete this.datas[node.key];
                this.count--;
              };

              _proto.get = function get(key) {
                var node = this.datas[key];

                if (node) {
                  this.remove(node);
                  this.moveToHead(node);
                  return node.value;
                }

                return null;
              };

              _proto.clear = function clear() {
                this.count = 0;
                this.datas = {};
                this.head = null;
                this.tail = null;
              };

              _proto.has = function has(key) {
                return !!this.datas[key];
              };

              _proto["delete"] = function _delete(key) {
                var node = this.datas[key];
                this.remove(node);
              };

              return LRUCache;
            }();

            var measureCache = new LRUCache(MAX_CACHE_SIZE);
            var WORD_REG = /([a-zA-Z0-9--]+|\S)/;
            var SYMBOL_REG = /^[!,.:;'}\]%\?>]/;
            var LAST_WORD_REG = /([a-zA-Z0-9--]+|\S)$/;
            var LAST_ENGLISH_REG = /[a-zA-Z0-9--]+$/;
            var FIRST_ENGLISH_REG = /^[a-zA-Z0-9--]/;
            function isUnicodeCJK(ch) {
              var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
              var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
              var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
              return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
            }
            function isUnicodeSpace(ch) {
              var chCode = ch.charCodeAt(0);
              return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
            }
            function safeMeasureText(ctx, string, desc) {
              var font = desc || ctx.font;
              var key = font + "\uD83C\uDFAE" + string;
              var cache = measureCache.get(key);

              if (cache !== null) {
                return cache;
              }

              var metric = ctx.measureText(string);
              var width = metric && metric.width || 0;
              measureCache.put(key, width);
              return width;
            }

            function _safeSubstring(targetString, startIndex, endIndex) {
              var newStartIndex = startIndex;
              var newEndIndex = endIndex;
              var startChar = targetString[startIndex];

              if (startChar >= "\uDC00" && startChar <= "\uDFFF") {
                newStartIndex--;
              }

              if (endIndex !== undefined) {
                if (endIndex - 1 !== startIndex) {
                  var endChar = targetString[endIndex - 1];

                  if (endChar >= "\uD800" && endChar <= "\uDBFF") {
                    newEndIndex--;
                  }
                } else if (startChar >= "\uD800" && startChar <= "\uDBFF") {
                  newEndIndex++;
                }
              }

              return targetString.substring(newStartIndex, newEndIndex);
            }

            function fragmentText(stringToken, allWidth, maxWidth, measureText) {
              var wrappedWords = [];

              if (stringToken.length === 0 || maxWidth < 0) {
                wrappedWords.push('');
                return wrappedWords;
              }

              var text = stringToken;

              while (allWidth > maxWidth && text.length > 1) {
                var fuzzyLen = text.length * (maxWidth / allWidth) | 0;

                var tmpText = _safeSubstring(text, fuzzyLen);

                var width = allWidth - measureText(tmpText);
                var sLine = tmpText;
                var pushNum = 0;
                var checkWhile = 0;
                var checkCount = 10;

                while (width > maxWidth && checkWhile++ < checkCount) {
                  fuzzyLen *= maxWidth / width;
                  fuzzyLen |= 0;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                checkWhile = 0;

                while (width <= maxWidth && checkWhile++ < checkCount) {
                  if (tmpText) {
                    var exec = WORD_REG.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1;
                    sLine = tmpText;
                  }

                  fuzzyLen += pushNum;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                fuzzyLen -= pushNum;

                if (fuzzyLen === 0) {
                  fuzzyLen = 1;
                  sLine = _safeSubstring(text, 1);
                } else if (fuzzyLen === 1 && text[0] >= "\uD800" && text[0] <= "\uDBFF") {
                  fuzzyLen = 2;
                  sLine = _safeSubstring(text, 2);
                }

                var sText = _safeSubstring(text, 0, fuzzyLen);

                var result = void 0;

                {
                  if (SYMBOL_REG.test(sLine || tmpText)) {
                    result = LAST_WORD_REG.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;

                    if (fuzzyLen === 0) {
                      fuzzyLen = 1;
                    }

                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (FIRST_ENGLISH_REG.test(sLine)) {
                  result = LAST_ENGLISH_REG.exec(sText);

                  if (result && sText !== result[0]) {
                    fuzzyLen -= result[0].length;
                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                }

                if (wrappedWords.length === 0) {
                  wrappedWords.push(sText);
                } else {
                  sText = sText.trim();

                  if (sText.length > 0) {
                    wrappedWords.push(sText);
                  }
                }

                text = sLine || tmpText;
                allWidth = measureText(text);
              }

              if (wrappedWords.length === 0) {
                wrappedWords.push(text);
              } else {
                text = text.trim();

                if (text.length > 0) {
                  wrappedWords.push(text);
                }
              }

              return wrappedWords;
            }

            var _canvasPool;

            var CanvasPool = exports('CanvasPool', function () {
              function CanvasPool() {
                this.pool = [];
              }

              CanvasPool.getInstance = function getInstance() {
                if (!_canvasPool) {
                  _canvasPool = new CanvasPool();
                }

                return _canvasPool;
              };

              var _proto = CanvasPool.prototype;

              _proto.get = function get() {
                var data = this.pool.pop();

                if (!data) {
                  var canvas = document.createElement('canvas');
                  var context = canvas.getContext('2d');
                  data = {
                    canvas: canvas,
                    context: context
                  };
                }

                return data;
              };

              _proto.put = function put(canvas) {
                if (this.pool.length >= macro.MAX_LABEL_CANVAS_POOL_SIZE) {
                  return;
                }

                this.pool.push(canvas);
              };

              return CanvasPool;
            }());
            var WHITE = Color.WHITE.clone();
            var space$1 = 0;
            var bleed = 2;

            var FontLetterDefinition$1 = function FontLetterDefinition() {
              this.u = 0;
              this.v = 0;
              this.w = 0;
              this.h = 0;
              this.texture = null;
              this.offsetX = 0;
              this.offsetY = 0;
              this.valid = false;
              this.xAdvance = 0;
            };

            var _backgroundStyle = "rgba(255, 255, 255, " + (1 / 255).toFixed(3) + ")";

            var BASELINE_OFFSET = getBaselineOffset();

            var LetterTexture = function () {
              function LetterTexture(_char, labelInfo) {
                this.image = null;
                this.labelInfo = void 0;
                this["char"] = void 0;
                this.data = null;
                this.canvas = null;
                this.context = null;
                this.width = 0;
                this.height = 0;
                this.offsetY = 0;
                this.hash = void 0;
                this["char"] = _char;
                this.labelInfo = labelInfo;
                this.hash = _char.charCodeAt(0) + labelInfo.hash;
              }

              var _proto2 = LetterTexture.prototype;

              _proto2.updateRenderData = function updateRenderData() {
                this._updateProperties();

                this._updateTexture();
              };

              _proto2.destroy = function destroy() {
                this.image = null;
              };

              _proto2._updateProperties = function _updateProperties() {
                this.data = CanvasPool.getInstance().get();
                this.canvas = this.data.canvas;
                this.context = this.data.context;

                if (this.context) {
                  this.context.font = this.labelInfo.fontDesc;
                  var width = safeMeasureText(this.context, this["char"], this.labelInfo.fontDesc);
                  var blank = this.labelInfo.margin * 2 + bleed;
                  this.width = parseFloat(width.toFixed(2)) + blank;
                  this.height = (1 + BASELINE_RATIO) * this.labelInfo.fontSize + blank;
                  this.offsetY = -(this.labelInfo.fontSize * BASELINE_RATIO) / 2;
                }

                if (this.canvas.width !== this.width) {
                  this.canvas.width = this.width;
                }

                if (this.canvas.height !== this.height) {
                  this.canvas.height = this.height;
                }

                if (!this.image) {
                  this.image = new ImageAsset();
                }

                this.image.reset(this.canvas);
              };

              _proto2._updateTexture = function _updateTexture() {
                if (!this.context || !this.canvas) {
                  return;
                }

                var context = this.context;
                var labelInfo = this.labelInfo;
                var width = this.canvas.width;
                var height = this.canvas.height;
                context.textAlign = 'center';
                context.textBaseline = 'alphabetic';
                context.clearRect(0, 0, width, height);
                context.fillStyle = _backgroundStyle;
                context.fillRect(0, 0, width, height);
                context.font = labelInfo.fontDesc;
                var fontSize = labelInfo.fontSize;
                var startX = width / 2;
                var startY = height / 2 + fontSize * MIDDLE_RATIO + fontSize * BASELINE_OFFSET;
                var color = labelInfo.color;
                context.lineJoin = 'round';
                context.fillStyle = "rgba(" + color.r + ", " + color.g + ", " + color.b + ", " + 1 + ")";

                if (labelInfo.isOutlined) {
                  var strokeColor = labelInfo.out || WHITE;
                  context.strokeStyle = "rgba(" + strokeColor.r + ", " + strokeColor.g + ", " + strokeColor.b + ", " + strokeColor.a / 255 + ")";
                  context.lineWidth = labelInfo.margin * 2;
                  context.strokeText(this["char"], startX, startY);
                }

                context.fillText(this["char"], startX, startY);
              };

              return LetterTexture;
            }();

            var LetterRenderTexture = function (_Texture2D) {
              _inheritsLoose(LetterRenderTexture, _Texture2D);

              function LetterRenderTexture() {
                return _Texture2D.apply(this, arguments) || this;
              }

              var _proto3 = LetterRenderTexture.prototype;

              _proto3.initWithSize = function initWithSize(width, height, format) {
                if (format === void 0) {
                  format = PixelFormat.RGBA8888;
                }

                this.reset({
                  width: width,
                  height: height,
                  format: format
                });
                this.loaded = true;
                this.emit('load');
              };

              _proto3.drawTextureAt = function drawTextureAt(image, x, y) {
                var gfxTexture = this.getGFXTexture();

                if (!image || !gfxTexture) {
                  return;
                }

                var gfxDevice = this._getGFXDevice();

                if (!gfxDevice) {
                  console.warn('Unable to get device');
                  return;
                }

                var region = new BufferTextureCopy();
                region.texOffset.x = x;
                region.texOffset.y = y;
                region.texExtent.width = image.width;
                region.texExtent.height = image.height;
                gfxDevice.copyTexImagesToTexture([image.data], gfxTexture, [region]);
              };

              return LetterRenderTexture;
            }(Texture2D);
            var LetterAtlas = function () {
              _createClass(LetterAtlas, [{
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }]);

              function LetterAtlas(width, height) {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this._width = 0;
                this._height = 0;
                this._halfBleed = 0;
                this._dirty = false;
                var texture = new LetterRenderTexture();
                texture.initWithSize(width, height);
                this.fontDefDictionary = new FontAtlas(texture);
                this._halfBleed = bleed / 2;
                this._width = width;
                this._height = height;
                director.on(Director.EVENT_BEFORE_SCENE_LAUNCH, this.beforeSceneLoad, this);
              }

              var _proto4 = LetterAtlas.prototype;

              _proto4.insertLetterTexture = function insertLetterTexture(letterTexture) {
                var texture = letterTexture.image;
                var device = director.root.device;

                if (!texture || !this.fontDefDictionary || !device) {
                  return null;
                }

                var width = texture.width;
                var height = texture.height;

                if (this._x + width + space$1 > this._width) {
                  this._x = space$1;
                  this._y = this._nextY;
                }

                if (this._y + height > this._nextY) {
                  this._nextY = this._y + height + space$1;
                }

                if (this._nextY > this._height) {
                  return null;
                }

                this.fontDefDictionary.texture.drawTextureAt(texture, this._x, this._y);
                this._dirty = true;
                var letterDefinition = new FontLetterDefinition$1();
                letterDefinition.u = this._x + this._halfBleed;
                letterDefinition.v = this._y + this._halfBleed;
                letterDefinition.texture = this.fontDefDictionary.texture;
                letterDefinition.valid = true;
                letterDefinition.w = letterTexture.width - bleed;
                letterDefinition.h = letterTexture.height - bleed;
                letterDefinition.xAdvance = letterDefinition.w;
                letterDefinition.offsetY = letterTexture.offsetY;
                this._x += width + space$1;
                this.fontDefDictionary.addLetterDefinitions(letterTexture.hash, letterDefinition);
                return letterDefinition;
              };

              _proto4.update = function update() {
                if (!this._dirty) {
                  return;
                }

                this._dirty = false;
              };

              _proto4.reset = function reset() {
                this._x = space$1;
                this._y = space$1;
                this._nextY = space$1;
                this.fontDefDictionary.clear();
              };

              _proto4.destroy = function destroy() {
                this.reset();

                if (this.fontDefDictionary) {
                  this.fontDefDictionary.texture.destroy();
                  this.fontDefDictionary.texture = null;
                }
              };

              _proto4.getTexture = function getTexture() {
                return this.fontDefDictionary.getTexture();
              };

              _proto4.beforeSceneLoad = function beforeSceneLoad() {
                this.clearAllCache();
              };

              _proto4.clearAllCache = function clearAllCache() {
                this.destroy();
                var texture = new LetterRenderTexture();
                texture.initWithSize(this._width, this._height);
                this.fontDefDictionary.texture = texture;
              };

              _proto4.getLetter = function getLetter(key) {
                return this.fontDefDictionary.letterDefinitions[key];
              };

              _proto4.getLetterDefinitionForChar = function getLetterDefinitionForChar(_char2, labelInfo) {
                var hash = _char2.charCodeAt(0) + labelInfo.hash;
                var letter = this.fontDefDictionary.letterDefinitions[hash];

                if (!letter) {
                  var temp = new LetterTexture(_char2, labelInfo);
                  temp.updateRenderData();
                  letter = this.insertLetterTexture(temp);
                  temp.destroy();
                }

                return letter;
              };

              return LetterAtlas;
            }();
            var shareLabelInfo = {
              fontAtlas: null,
              fontSize: 0,
              lineHeight: 0,
              hAlign: 0,
              vAlign: 0,
              hash: '',
              fontFamily: '',
              fontDesc: 'Arial',
              color: Color.WHITE.clone(),
              isOutlined: false,
              out: Color.WHITE.clone(),
              margin: 0
            };
            function computeHash(labelInfo) {
              var hashData = '';
              var color = labelInfo.color.toHEX();
              var out = '';

              if (labelInfo.isOutlined && labelInfo.margin > 0) {
                out = out + labelInfo.margin + labelInfo.out.toHEX();
              }

              return hashData + labelInfo.fontSize + labelInfo.fontFamily + color + out;
            }

            var BaseRenderData = function BaseRenderData() {
              this.material = null;
              this.vertexCount = 0;
              this.indicesCount = 0;
            };
            var RenderData = function (_BaseRenderData) {
              _inheritsLoose(RenderData, _BaseRenderData);

              function RenderData() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _BaseRenderData.call.apply(_BaseRenderData, [this].concat(args)) || this;
                _this.vData = null;
                _this.uvDirty = true;
                _this.vertDirty = true;
                _this._data = [];
                _this._indices = [];
                _this._pivotX = 0;
                _this._pivotY = 0;
                _this._width = 0;
                _this._height = 0;
                return _this;
              }

              RenderData.add = function add() {
                return _pool.add();
              };

              RenderData.remove = function remove(data) {
                var idx = _pool.data.indexOf(data);

                if (idx === -1) {
                  return;
                }

                _pool.data[idx].clear();

                _pool.removeAt(idx);
              };

              var _proto = RenderData.prototype;

              _proto.updateSizeNPivot = function updateSizeNPivot(width, height, pivotX, pivotY) {
                if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
                  this._width = width;
                  this._height = height;
                  this._pivotX = pivotX;
                  this._pivotY = pivotY;
                  this.vertDirty = true;
                }
              };

              _proto.clear = function clear() {
                this._data.length = 0;
                this._indices.length = 0;
                this._pivotX = 0;
                this._pivotY = 0;
                this._width = 0;
                this._height = 0;
                this.uvDirty = true;
                this.vertDirty = true;
                this.material = null;
                this.vertexCount = 0;
                this.indicesCount = 0;
              };

              _createClass(RenderData, [{
                key: "dataLength",
                get: function get() {
                  return this._data.length;
                },
                set: function set(length) {
                  var data = this._data;

                  if (data.length !== length) {
                    var value = data.length;
                    var i = 0;

                    for (i = length; i < value; i++) {
                      _dataPool.free(data[i]);
                    }

                    for (i = value; i < length; i++) {
                      data[i] = _dataPool.alloc();
                    }

                    data.length = length;
                  }
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }]);

              return RenderData;
            }(BaseRenderData);
            var MeshRenderData = function (_BaseRenderData2) {
              _inheritsLoose(MeshRenderData, _BaseRenderData2);

              function MeshRenderData(vertexFloatCnt) {
                var _this2;

                if (vertexFloatCnt === void 0) {
                  vertexFloatCnt = 9;
                }

                _this2 = _BaseRenderData2.call(this) || this;
                _this2.vData = void 0;
                _this2.iData = void 0;
                _this2.vertexStart = 0;
                _this2.indicesStart = 0;
                _this2.byteStart = 0;
                _this2.byteCount = 0;
                _this2.lastFilledIndices = 0;
                _this2.lastFilledVertex = 0;
                _this2._formatByte = void 0;
                _this2._formatByte = vertexFloatCnt * Float32Array.BYTES_PER_ELEMENT;
                _this2.vData = new Float32Array(256 * vertexFloatCnt * Float32Array.BYTES_PER_ELEMENT);
                _this2.iData = new Uint16Array(256 * 6);
                return _this2;
              }

              MeshRenderData.add = function add() {
                return _meshDataPool.add();
              };

              MeshRenderData.remove = function remove(data) {
                var idx = _meshDataPool.data.indexOf(data);

                if (idx === -1) {
                  return;
                }

                _meshDataPool.data[idx].reset();

                _meshDataPool.removeAt(idx);
              };

              var _proto2 = MeshRenderData.prototype;

              _proto2.request = function request(vertexCount, indicesCount) {
                var byteOffset = this.byteCount + vertexCount * this._formatByte;
                this.reserve(vertexCount, indicesCount);
                this.vertexCount += vertexCount;
                this.indicesCount += indicesCount;
                this.byteCount = byteOffset;
                return true;
              };

              _proto2.reserve = function reserve(vertexCount, indicesCount) {
                var newVBytes = this.byteCount + vertexCount * this._formatByte;
                var newICount = this.indicesCount + indicesCount;

                if (vertexCount + this.vertexCount > 65535) {
                  return false;
                }

                var byteLength = this.vData.byteLength;
                var indicesLength = this.iData.length;
                var vCount = this.vData.length;
                var iCount = this.iData.length;

                if (newVBytes > byteLength || newICount > indicesLength) {
                  while (byteLength < newVBytes || indicesLength < newICount) {
                    vCount *= 2;
                    iCount *= 2;
                    byteLength = vCount * 4;
                    indicesLength = iCount;
                  }

                  this._reallocBuffer(vCount, iCount);
                }

                return true;
              };

              _proto2.advance = function advance(vertexCount, indicesCount) {
                this.vertexCount += vertexCount;
                this.indicesCount += indicesCount;
                this.byteCount += vertexCount * this._formatByte;
              };

              _proto2.reset = function reset() {
                this.vertexCount = 0;
                this.indicesCount = 0;
                this.byteCount = 0;
                this.vertexStart = 0;
                this.indicesStart = 0;
                this.byteStart = 0;
                this.lastFilledIndices = 0;
                this.lastFilledVertex = 0;
              };

              _proto2._reallocBuffer = function _reallocBuffer(vCount, iCount) {
                var oldVData = this.vData;
                this.vData = new Float32Array(vCount);
                this.vData.set(oldVData, 0);
                var oldIData = this.iData;
                this.iData = new Uint16Array(iCount);
                this.iData.set(oldIData, 0);
              };

              _createClass(MeshRenderData, [{
                key: "formatByte",
                set: function set(value) {
                  this._formatByte = value;
                },
                get: function get() {
                  return this._formatByte;
                }
              }, {
                key: "floatStride",
                get: function get() {
                  return this._formatByte >> 2;
                }
              }, {
                key: "vDataOffset",
                get: function get() {
                  return this.byteCount >>> 2;
                }
              }]);

              return MeshRenderData;
            }(BaseRenderData);
            var QuadRenderData = function (_MeshRenderData) {
              _inheritsLoose(QuadRenderData, _MeshRenderData);

              function QuadRenderData() {
                return _MeshRenderData.apply(this, arguments) || this;
              }

              var _proto3 = QuadRenderData.prototype;

              _proto3._fillQuadBuffer = function _fillQuadBuffer() {
                var count = this.iData.length / 6;
                var buffer = this.iData;

                for (var i = 0, idx = 0; i < count; i++) {
                  var vId = i * 4;
                  buffer[idx++] = vId;
                  buffer[idx++] = vId + 1;
                  buffer[idx++] = vId + 2;
                  buffer[idx++] = vId + 1;
                  buffer[idx++] = vId + 3;
                  buffer[idx++] = vId + 2;
                }
              };

              _proto3._reallocBuffer = function _reallocBuffer(vCount, iCount) {
                _MeshRenderData.prototype._reallocBuffer.call(this, vCount, iCount);

                this._fillQuadBuffer();
              };

              return QuadRenderData;
            }(MeshRenderData);

            var _dataPool = new Pool(function () {
              return {
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color.WHITE.clone()
              };
            }, 128);

            var _pool = new RecyclePool(function () {
              return new RenderData();
            }, 32);

            var _meshDataPool = new RecyclePool(function () {
              return new MeshRenderData();
            }, 32);

            var _dec$g, _dec2$a, _dec3$9, _dec4$8, _dec5$8, _dec6$7, _dec7$7, _dec8$6, _dec9$6, _class$g, _class2$d, _descriptor$d, _descriptor2$a, _descriptor3$9, _class3, _temp$e;

            var _vec2a = new Vec2();

            var _vec2b = new Vec2();

            var _mat4_temp = new Mat4();

            var _matrix = new Mat4();

            var _worldMatrix$1 = new Mat4();

            var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

            var _rect = new Rect$1();

            var UITransform = function (v) { return exports({ UITransform: v, UITransformComponent: v }), v; }((_dec$g = ccclass('cc.UITransform'), _dec2$a = help(), _dec3$9 = executionOrder(110), _dec4$8 = menu(), _dec5$8 = displayOrder(), _dec6$7 = tooltip(), _dec7$7 = displayOrder(), _dec8$6 = tooltip(), _dec9$6 = tooltip(), _dec$g(_class$g = _dec2$a(_class$g = _dec3$9(_class$g = _dec4$8(_class$g = disallowMultiple(_class$g = executeInEditMode(_class$g = (_class2$d = (_temp$e = _class3 = function (_Component) {
              _inheritsLoose(UITransform, _Component);

              function UITransform() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_priority", _descriptor$d, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_contentSize", _descriptor2$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_anchorPoint", _descriptor3$9, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = UITransform.prototype;

              _proto.__preload = function __preload() {
                this.node._uiProps.uiTransformComp = this;
              };

              _proto.onEnable = function onEnable() {
                this.node.on(SystemEventType.PARENT_CHANGED, this._parentChanged, this);

                var changed = this._checkAndSortSiblings();

                if (changed) {
                  this.node.parent._updateSiblingIndex();
                }
              };

              _proto.onDisable = function onDisable() {
                this.node.off(SystemEventType.PARENT_CHANGED, this._parentChanged, this);
              };

              _proto.onDestroy = function onDestroy() {
                this.node._uiProps.uiTransformComp = null;
              };

              _proto.setContentSize = function setContentSize(size, height) {
                var locContentSize = this._contentSize;

                if (height === undefined) {
                  size = size;

                  if (size.width === locContentSize.width && size.height === locContentSize.height) {
                    return;
                  }

                  locContentSize.width = size.width;
                  locContentSize.height = size.height;
                } else {
                  if (size === locContentSize.width && height === locContentSize.height) {
                    return;
                  }

                  locContentSize.width = size;
                  locContentSize.height = height;
                }

                {
                  this.node.emit(SystemEventType.SIZE_CHANGED);
                }
              };

              _proto.setAnchorPoint = function setAnchorPoint(point, y) {
                var locAnchorPoint = this._anchorPoint;

                if (y === undefined) {
                  point = point;

                  if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point.x;
                  locAnchorPoint.y = point.y;
                } else {
                  if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                    return;
                  }

                  locAnchorPoint.x = point;
                  locAnchorPoint.y = y;
                }

                this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
              };

              _proto.isHit = function isHit(point, listener) {
                var w = this._contentSize.width;
                var h = this._contentSize.height;
                var cameraPt = _vec2a;
                var testPt = _vec2b;

                var cameras = this._getRenderScene().cameras;

                for (var i = 0; i < cameras.length; i++) {
                  var camera = cameras[i];
                  if (!(camera.visibility & this.node.layer)) continue;
                  camera.node.getWorldRT(_mat4_temp);
                  var m12 = _mat4_temp.m12;
                  var m13 = _mat4_temp.m13;
                  var center = legacyCC.visibleRect.center;
                  _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
                  _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
                  Mat4.invert(_mat4_temp, _mat4_temp);
                  Vec2.transformMat4(cameraPt, point, _mat4_temp);
                  this.node.getWorldMatrix(_worldMatrix$1);
                  Mat4.invert(_mat4_temp, _worldMatrix$1);

                  if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
                    continue;
                  }

                  Vec2.transformMat4(testPt, cameraPt, _mat4_temp);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;
                  var hit = false;

                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    hit = true;

                    if (listener && listener.mask) {
                      var mask = listener.mask;
                      var parent = this.node;
                      var length = mask ? mask.length : 0;

                      for (var _i = 0, j = 0; parent && j < length; ++_i, parent = parent.parent) {
                        var temp = mask[j];

                        if (_i === temp.index) {
                          if (parent === temp.comp.node) {
                            var comp = temp.comp;

                            if (comp && comp._enabled && !comp.isHit(cameraPt)) {
                              hit = false;
                              break;
                            }

                            j++;
                          } else {
                            mask.length = j;
                            break;
                          }
                        } else if (_i > temp.index) {
                          mask.length = j;
                          break;
                        }
                      }
                    }
                  }

                  if (hit) {
                    return true;
                  }
                }

                return false;
              };

              _proto.convertToNodeSpaceAR = function convertToNodeSpaceAR(worldPoint, out) {
                this.node.getWorldMatrix(_worldMatrix$1);
                Mat4.invert(_mat4_temp, _worldMatrix$1);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, worldPoint, _mat4_temp);
              };

              _proto.convertToWorldSpaceAR = function convertToWorldSpaceAR(nodePoint, out) {
                this.node.getWorldMatrix(_worldMatrix$1);

                if (!out) {
                  out = new Vec3();
                }

                return Vec3.transformMat4(out, nodePoint, _worldMatrix$1);
              };

              _proto.getBoundingBox = function getBoundingBox() {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                var rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                rect.transformMat4(_matrix);
                return rect;
              };

              _proto.getBoundingBoxToWorld = function getBoundingBoxToWorld() {
                if (this.node.parent) {
                  this.node.parent.getWorldMatrix(_worldMatrix$1);
                  return this.getBoundingBoxTo(_worldMatrix$1);
                }

                return this.getBoundingBox();
              };

              _proto.getBoundingBoxTo = function getBoundingBoxTo(parentMat) {
                Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                var width = this._contentSize.width;
                var height = this._contentSize.height;
                var rect = new Rect$1(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                Mat4.multiply(_worldMatrix$1, parentMat, _matrix);
                rect.transformMat4(_worldMatrix$1);

                if (!this.node.children) {
                  return rect;
                }

                var locChildren = this.node.children;

                for (var _iterator = _createForOfIteratorHelperLoose(locChildren), _step; !(_step = _iterator()).done;) {
                  var child = _step.value;

                  if (child && child.active) {
                    var uiTransform = child.getComponent(UITransform);

                    if (uiTransform) {
                      var childRect = uiTransform.getBoundingBoxTo(parentMat);

                      if (childRect) {
                        Rect$1.union(rect, rect, childRect);
                      }
                    }
                  }
                }

                return rect;
              };

              _proto.getComputeAABB = function getComputeAABB(out) {
                var width = this._contentSize.width;
                var height = this._contentSize.height;

                _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

                _rect.transformMat4(this.node.worldMatrix);

                var px = _rect.x + _rect.width * 0.5;
                var py = _rect.y + _rect.height * 0.5;
                var pz = this.node.worldPosition.z;
                var w = _rect.width / 2;
                var h = _rect.height / 2;
                var l = 0.001;

                if (out != null) {
                  AABB.set(out, px, py, pz, w, h, l);
                  return out;
                } else {
                  return new AABB(px, py, pz, w, h, l);
                }
              };

              _proto._parentChanged = function _parentChanged(node) {
                if (this.node.getComponent('cc.RenderRoot2D')) {
                  return;
                }

                this._checkAndSortSiblings();
              };

              _proto._checkAndSortSiblings = function _checkAndSortSiblings() {
                var siblings = this.node.parent && this.node.parent.children;
                var changed = false;

                if (siblings) {
                  siblings.sort(function (a, b) {
                    var aComp = a._uiProps.uiTransformComp;
                    var bComp = b._uiProps.uiTransformComp;
                    var ca = aComp ? aComp.priority : 0;
                    var cb = bComp ? bComp.priority : 0;
                    var diff = ca - cb;

                    if (diff === 0) {
                      diff = a.getSiblingIndex() - b.getSiblingIndex();
                    }

                    changed = diff > 0;
                    return diff;
                  });
                }

                return changed;
              };

              _createClass(UITransform, [{
                key: "contentSize",
                get: function get() {
                  return this._contentSize;
                },
                set: function set(value) {
                  if (this._contentSize.equals(value)) {
                    return;
                  }

                  this._contentSize.set(value);

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
              }, {
                key: "width",
                get: function get() {
                  return this._contentSize.width;
                },
                set: function set(value) {
                  if (this._contentSize.width === value) {
                    return;
                  }

                  this._contentSize.width = value;

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._contentSize.height;
                },
                set: function set(value) {
                  if (this.contentSize.height === value) {
                    return;
                  }

                  this._contentSize.height = value;

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
              }, {
                key: "anchorPoint",
                get: function get() {
                  return this._anchorPoint;
                },
                set: function set(value) {
                  if (this._anchorPoint.equals(value)) {
                    return;
                  }

                  this._anchorPoint.set(value);

                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
              }, {
                key: "anchorX",
                get: function get() {
                  return this._anchorPoint.x;
                },
                set: function set(value) {
                  if (this._anchorPoint.x === value) {
                    return;
                  }

                  this._anchorPoint.x = value;
                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
              }, {
                key: "anchorY",
                get: function get() {
                  return this._anchorPoint.y;
                },
                set: function set(value) {
                  if (this._anchorPoint.y === value) {
                    return;
                  }

                  this._anchorPoint.y = value;
                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(value) {
                  if (this._priority === value) {
                    return;
                  }

                  if (this.node.getComponent('cc.RenderRoot2D')) {
                    warnID(6706);
                    return;
                  }

                  this._priority = value;

                  this._checkAndSortSiblings();

                  this.node.parent._updateSiblingIndex();
                }
              }, {
                key: "visibility",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.visibility : 0;
                }
              }, {
                key: "cameraPriority",
                get: function get() {
                  var camera = director.root.batcher2D.getFirstRenderCamera(this.node);
                  return camera ? camera.priority : 0;
                }
              }]);

              return UITransform;
            }(Component), _class3.EventType = SystemEventType, _temp$e), (_applyDecoratedDescriptor(_class2$d.prototype, "contentSize", [_dec5$8, _dec6$7], Object.getOwnPropertyDescriptor(_class2$d.prototype, "contentSize"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "anchorPoint", [_dec7$7, _dec8$6], Object.getOwnPropertyDescriptor(_class2$d.prototype, "anchorPoint"), _class2$d.prototype), _applyDecoratedDescriptor(_class2$d.prototype, "priority", [_dec9$6], Object.getOwnPropertyDescriptor(_class2$d.prototype, "priority"), _class2$d.prototype), _descriptor$d = _applyDecoratedDescriptor(_class2$d.prototype, "_priority", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$a = _applyDecoratedDescriptor(_class2$d.prototype, "_contentSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Size(100, 100);
              }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class2$d.prototype, "_anchorPoint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(0.5, 0.5);
              }
            })), _class2$d)) || _class$g) || _class$g) || _class$g) || _class$g) || _class$g) || _class$g));

            var Stage;

            (function (Stage) {
              Stage[Stage["DISABLED"] = 0] = "DISABLED";
              Stage[Stage["CLEAR"] = 1] = "CLEAR";
              Stage[Stage["ENTER_LEVEL"] = 2] = "ENTER_LEVEL";
              Stage[Stage["ENABLED"] = 3] = "ENABLED";
              Stage[Stage["EXIT_LEVEL"] = 4] = "EXIT_LEVEL";
              Stage[Stage["CLEAR_INVERTED"] = 5] = "CLEAR_INVERTED";
              Stage[Stage["ENTER_LEVEL_INVERTED"] = 6] = "ENTER_LEVEL_INVERTED";
            })(Stage || (Stage = {}));

            var StencilManager = exports('StencilManager', function () {
              function StencilManager() {
                this.stage = Stage.DISABLED;
                this._maskStack = [];
                this._stencilPattern = {
                  stencilTest: true,
                  func: ComparisonFunc.ALWAYS,
                  stencilMask: 0xffff,
                  writeMask: 0xffff,
                  failOp: StencilOp.KEEP,
                  zFailOp: StencilOp.KEEP,
                  passOp: StencilOp.KEEP,
                  ref: 1
                };
                this.stencilStateMap = new Map();
                this.stencilStateMapWithDepth = new Map();
              }

              var _proto = StencilManager.prototype;

              _proto.pushMask = function pushMask(mask) {
                this._maskStack.push(mask);
              };

              _proto.clear = function clear(comp) {
                comp.stencilStage = comp.inverted ? Stage.CLEAR_INVERTED : Stage.CLEAR;
              };

              _proto.enterLevel = function enterLevel(comp) {
                comp.graphics.stencilStage = comp.inverted ? Stage.ENTER_LEVEL_INVERTED : Stage.ENTER_LEVEL;
              };

              _proto.enableMask = function enableMask() {
                this.stage = Stage.ENABLED;
              };

              _proto.exitMask = function exitMask() {
                if (this._maskStack.length === 0) {
                  return;
                }

                this._maskStack.pop();

                if (this._maskStack.length === 0) {
                  this.stage = Stage.DISABLED;
                } else {
                  this.stage = Stage.ENABLED;
                }
              };

              _proto.getWriteMask = function getWriteMask() {
                return 1 << this._maskStack.length - 1;
              };

              _proto.getExitWriteMask = function getExitWriteMask() {
                return 1 << this._maskStack.length;
              };

              _proto.getStencilRef = function getStencilRef() {
                var result = 0;

                for (var i = 0; i < this._maskStack.length; ++i) {
                  result += 0x00000001 << i;
                }

                return result;
              };

              _proto.reset = function reset() {
                this._maskStack.length = 0;
                this.stage = Stage.DISABLED;
              };

              _proto.destroy = function destroy() {
                this.stencilStateMap.forEach(function (value, key) {
                  value.destroy();
                });
                this.stencilStateMap.clear();
              };

              _proto.getStencilStage = function getStencilStage(stage, mat) {
                var key = 0;
                var depthTest = false;
                var depthWrite = false;
                var depthFunc = ComparisonFunc.LESS;
                var cacheMap = this.stencilStateMap;

                if (mat && mat.passes[0]) {
                  var pass = mat.passes[0];
                  var dss = pass.depthStencilState;
                  var depthTestValue = 0;
                  var depthWriteValue = 0;
                  if (dss.depthTest) depthTestValue = 1;
                  if (dss.depthWrite) depthWriteValue = 1;
                  key = depthTestValue | depthWriteValue << 1 | dss.depthFunc << 2 | stage << 6 | this._maskStack.length << 9;
                  depthTest = dss.depthTest;
                  depthWrite = dss.depthWrite;
                  depthFunc = dss.depthFunc;
                  cacheMap = this.stencilStateMapWithDepth;
                } else {
                  key = stage << 16 | this._maskStack.length;
                }

                if (cacheMap && cacheMap.has(key)) {
                  return cacheMap.get(key);
                }

                this.setStateFromStage(stage);
                var depthStencilState = new DepthStencilState(depthTest, depthWrite, depthFunc, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref, this._stencilPattern.stencilTest, this._stencilPattern.func, this._stencilPattern.stencilMask, this._stencilPattern.writeMask, this._stencilPattern.failOp, this._stencilPattern.zFailOp, this._stencilPattern.passOp, this._stencilPattern.ref);
                cacheMap.set(key, depthStencilState);
                return depthStencilState;
              };

              _proto.getStencilHash = function getStencilHash(stage) {
                return stage << 8 | this._maskStack.length;
              };

              _proto.setStateFromStage = function setStateFromStage(stage) {
                var pattern = this._stencilPattern;

                if (stage === Stage.DISABLED) {
                  pattern.stencilTest = false;
                  pattern.func = ComparisonFunc.ALWAYS;
                  pattern.failOp = StencilOp.KEEP;
                  pattern.stencilMask = pattern.writeMask = 0xffff;
                  pattern.ref = 1;
                } else {
                  pattern.stencilTest = true;

                  if (stage === Stage.ENABLED) {
                    pattern.func = ComparisonFunc.EQUAL;
                    pattern.failOp = StencilOp.KEEP;
                    pattern.stencilMask = pattern.ref = this.getStencilRef();
                    pattern.writeMask = this.getWriteMask();
                  } else if (stage === Stage.CLEAR) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.CLEAR_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.REPLACE;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  } else if (stage === Stage.ENTER_LEVEL_INVERTED) {
                    pattern.func = ComparisonFunc.NEVER;
                    pattern.failOp = StencilOp.ZERO;
                    pattern.writeMask = pattern.stencilMask = pattern.ref = this.getWriteMask();
                  }
                }
              };

              _createClass(StencilManager, [{
                key: "pattern",
                get: function get() {
                  return this._stencilPattern;
                }
              }]);

              return StencilManager;
            }());
            StencilManager.sharedManager = null;
            StencilManager.sharedManager = new StencilManager();

            var _dec$h, _dec2$b, _dec3$a, _dec4$9, _dec5$9, _dec6$8, _dec7$8, _dec8$7, _dec9$7, _dec10$5, _dec11$4, _dec12$3, _dec13$3, _dec14$1, _dec15$1, _dec16$1, _dec17, _class$h, _class2$e, _descriptor$e, _descriptor2$b, _descriptor3$a, _descriptor4$7, _descriptor5$4, _class3$1, _temp$f;
            ccenum(BlendFactor);
            var InstanceMaterialType;

            (function (InstanceMaterialType) {
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR"] = 0] = "ADD_COLOR";
              InstanceMaterialType[InstanceMaterialType["ADD_COLOR_AND_TEXTURE"] = 1] = "ADD_COLOR_AND_TEXTURE";
              InstanceMaterialType[InstanceMaterialType["GRAYSCALE"] = 2] = "GRAYSCALE";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED"] = 3] = "USE_ALPHA_SEPARATED";
              InstanceMaterialType[InstanceMaterialType["USE_ALPHA_SEPARATED_AND_GRAY"] = 4] = "USE_ALPHA_SEPARATED_AND_GRAY";
            })(InstanceMaterialType || (InstanceMaterialType = exports('InstanceMaterialType', {})));
            var Renderable2D = function (v) { return exports({ Renderable2D: v, RenderComponent: v, UIRenderable: v }), v; }((_dec$h = ccclass('cc.Renderable2D'), _dec2$b = requireComponent(UITransform), _dec3$a = visible(), _dec4$9 = type(Material), _dec5$9 = type(Material), _dec6$8 = displayOrder(), _dec7$8 = displayName(), _dec8$7 = visible(), _dec9$7 = type(BlendFactor), _dec10$5 = displayOrder(), _dec11$4 = tooltip(), _dec12$3 = visible(), _dec13$3 = type(BlendFactor), _dec14$1 = displayOrder(), _dec15$1 = tooltip(), _dec16$1 = displayOrder(), _dec17 = tooltip(), _dec$h(_class$h = _dec2$b(_class$h = disallowMultiple(_class$h = executeInEditMode(_class$h = (_class2$e = (_temp$f = _class3$1 = function (_RenderableComponent) {
              _inheritsLoose(Renderable2D, _RenderableComponent);

              function Renderable2D() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _RenderableComponent.call.apply(_RenderableComponent, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_materials", _descriptor$e, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_customMaterial", _descriptor2$b, _assertThisInitialized(_this));

                _this.stencilStage = Stage.DISABLED;

                _initializerDefineProperty(_this, "_srcBlendFactor", _descriptor3$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_dstBlendFactor", _descriptor4$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_color", _descriptor5$4, _assertThisInitialized(_this));

                _this._assembler = null;
                _this._postAssembler = null;
                _this._renderData = null;
                _this._renderDataFlag = true;
                _this._renderFlag = true;
                _this._delegateSrc = null;
                _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                _this._blendState = new BlendState();
                _this._blendHash = 0;
                _this._lastParent = null;
                return _this;
              }

              var _proto = Renderable2D.prototype;

              _proto.updateMaterial = function updateMaterial() {
                if (this._customMaterial) {
                  this.setMaterial(this._customMaterial, 0);
                  this._blendHash = -1;
                  return;
                }

                var mat = this._updateBuiltinMaterial();

                this.setMaterial(mat, 0);

                this._updateBlendFunc();
              };

              _proto.updateBlendHash = function updateBlendHash() {
                var dst = this._blendState.targets[0].blendDst << 4;
                this._blendHash = dst | this._blendState.targets[0].blendSrc;
              };

              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;

                if (this._flushAssembler) {
                  this._flushAssembler();
                }
              };

              _proto.onEnable = function onEnable() {
                this.node.on(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.on(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this.updateMaterial();
                this._renderFlag = this._canRender();
              };

              _proto.onRestore = function onRestore() {
                this.updateMaterial();
                this._renderFlag = this._canRender();
              };

              _proto.onDisable = function onDisable() {
                this.node.off(SystemEventType.ANCHOR_CHANGED, this._nodeStateChange, this);
                this.node.off(SystemEventType.SIZE_CHANGED, this._nodeStateChange, this);
                this._renderFlag = false;
              };

              _proto.onDestroy = function onDestroy() {
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }

                this.destroyRenderData();

                if (this._materialInstances) {
                  for (var i = 0; i < this._materialInstances.length; i++) {
                    this._materialInstances[i].destroy();
                  }
                }

                this._renderData = null;

                if (this._blendState) {
                  this._blendState.destroy();
                }
              };

              _proto.markForUpdateRenderData = function markForUpdateRenderData(enable) {
                if (enable === void 0) {
                  enable = true;
                }

                this._renderFlag = this._canRender();

                if (enable && this._renderFlag) {
                  var renderData = this._renderData;

                  if (renderData) {
                    renderData.vertDirty = true;
                  }

                  this._renderDataFlag = enable;
                } else if (!enable) {
                  this._renderDataFlag = enable;
                }
              };

              _proto.requestRenderData = function requestRenderData() {
                var data = RenderData.add();
                this._renderData = data;
                return data;
              };

              _proto.destroyRenderData = function destroyRenderData() {
                if (!this._renderData) {
                  return;
                }

                RenderData.remove(this._renderData);
                this._renderData = null;
              };

              _proto.updateAssembler = function updateAssembler(render) {
                if (this._renderFlag) {
                  this._checkAndUpdateRenderData();

                  this._render(render);
                }
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {
                if (this._renderFlag) {
                  this._postRender(render);
                }
              };

              _proto._render = function _render(render) {};

              _proto._postRender = function _postRender(render) {};

              _proto._checkAndUpdateRenderData = function _checkAndUpdateRenderData() {
                if (this._renderDataFlag) {
                  this._assembler.updateRenderData(this);

                  this._renderDataFlag = false;
                }
              };

              _proto._canRender = function _canRender() {
                return this.isValid && this.getMaterial(0) !== null && this.enabled && (this._delegateSrc ? this._delegateSrc.activeInHierarchy : this.enabledInHierarchy) && this._color.a > 0;
              };

              _proto._postCanRender = function _postCanRender() {};

              _proto._updateColor = function _updateColor() {
                if (this._assembler && this._assembler.updateColor) {
                  this._assembler.updateColor(this);
                }
              };

              _proto._updateBlendFunc = function _updateBlendFunc() {
                var target = this._blendState.targets[0];

                if (!target) {
                  target = new BlendTarget();

                  this._blendState.setTarget(0, target);
                }

                if (target.blendDst !== this._dstBlendFactor || target.blendSrc !== this._srcBlendFactor) {
                  target.blend = true;
                  target.blendDstAlpha = BlendFactor.ONE_MINUS_SRC_ALPHA;
                  target.blendDst = this._dstBlendFactor;
                  target.blendSrc = this._srcBlendFactor;
                }

                this.updateBlendHash();
              };

              _proto.getBlendState = function getBlendState() {
                return this._blendState;
              };

              _proto._nodeStateChange = function _nodeStateChange(transformType) {
                if (this._renderData) {
                  this.markForUpdateRenderData();
                }

                for (var i = 0; i < this.node.children.length; ++i) {
                  var child = this.node.children[i];
                  var renderComp = child.getComponent(Renderable2D);

                  if (renderComp) {
                    renderComp.markForUpdateRenderData();
                  }
                }
              };

              _proto._updateBuiltinMaterial = function _updateBuiltinMaterial() {
                var mat;

                switch (this._instanceMaterialType) {
                  case InstanceMaterialType.ADD_COLOR:
                    mat = builtinResMgr.get('ui-base-material');
                    break;

                  case InstanceMaterialType.GRAYSCALE:
                    mat = builtinResMgr.get('ui-sprite-gray-material');
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED:
                    mat = builtinResMgr.get('ui-sprite-alpha-sep-material');
                    break;

                  case InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY:
                    mat = builtinResMgr.get('ui-sprite-gray-alpha-sep-material');
                    break;

                  default:
                    mat = builtinResMgr.get('ui-sprite-material');
                    break;
                }

                return mat;
              };

              _createClass(Renderable2D, [{
                key: "sharedMaterials",
                get: function get() {
                  return  this._materials;
                },
                set: function set(val) {
                  for (var i = 0; i < val.length; i++) {
                    if (val[i] !== this._materials[i]) {
                      this.setMaterial(val[i], i);
                    }
                  }

                  if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) {
                      this.setMaterial(null, _i);
                    }

                    this._materials.splice(val.length);
                  }
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  return this._customMaterial;
                },
                set: function set(val) {
                  this._customMaterial = val;
                  this.updateMaterial();
                }
              }, {
                key: "srcBlendFactor",
                get: function get() {
                  if ( this._customMaterial) {
                    warnID(12001);
                  }

                  return this._srcBlendFactor;
                },
                set: function set(value) {
                  if (this._customMaterial) {
                    warnID(12001);
                    return;
                  }

                  if (this._srcBlendFactor === value) {
                    return;
                  }

                  this._srcBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "dstBlendFactor",
                get: function get() {
                  if ( this._customMaterial) {
                    warnID(12001);
                  }

                  return this._dstBlendFactor;
                },
                set: function set(value) {
                  if (this._customMaterial) {
                    warnID(12001);
                    return;
                  }

                  if (this._dstBlendFactor === value) {
                    return;
                  }

                  this._dstBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color.equals(value)) {
                    return;
                  }

                  this._color.set(value);

                  this._updateColor();

                  this.markForUpdateRenderData();
                }
              }, {
                key: "renderData",
                get: function get() {
                  return this._renderData;
                }
              }, {
                key: "delegateSrc",
                set: function set(value) {
                  this._delegateSrc = value;
                }
              }, {
                key: "blendHash",
                get: function get() {
                  return this._blendHash;
                }
              }]);

              return Renderable2D;
            }(RenderableComponent), _class3$1.BlendState = BlendFactor, _class3$1.Assembler = null, _class3$1.PostAssembler = null, _temp$f), (_descriptor$e = _applyDecoratedDescriptor(_class2$e.prototype, "_materials", [override], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _applyDecoratedDescriptor(_class2$e.prototype, "sharedMaterials", [override, _dec3$a], Object.getOwnPropertyDescriptor(_class2$e.prototype, "sharedMaterials"), _class2$e.prototype), _descriptor2$b = _applyDecoratedDescriptor(_class2$e.prototype, "_customMaterial", [_dec4$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$e.prototype, "customMaterial", [_dec5$9, _dec6$8, _dec7$8], Object.getOwnPropertyDescriptor(_class2$e.prototype, "customMaterial"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "srcBlendFactor", [_dec8$7, _dec9$7, _dec10$5, _dec11$4], Object.getOwnPropertyDescriptor(_class2$e.prototype, "srcBlendFactor"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "dstBlendFactor", [_dec12$3, _dec13$3, _dec14$1, _dec15$1], Object.getOwnPropertyDescriptor(_class2$e.prototype, "dstBlendFactor"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "color", [_dec16$1, _dec17], Object.getOwnPropertyDescriptor(_class2$e.prototype, "color"), _class2$e.prototype), _descriptor3$a = _applyDecoratedDescriptor(_class2$e.prototype, "_srcBlendFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return BlendFactor.SRC_ALPHA;
              }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$e.prototype, "_dstBlendFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return BlendFactor.ONE_MINUS_SRC_ALPHA;
              }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$e.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.WHITE.clone();
              }
            })), _class2$e)) || _class$h) || _class$h) || _class$h) || _class$h));
            legacyCC.internal.Renderable2D = Renderable2D;

            var _dec$i, _dec2$c, _dec3$b, _dec4$a, _dec5$a, _dec6$9, _dec7$9, _dec8$8, _dec9$8, _dec10$6, _dec11$5, _dec12$4, _dec13$4, _dec14$2, _dec15$2, _dec16$2, _dec17$1, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _class$i, _class2$f, _descriptor$f, _descriptor2$c, _descriptor3$b, _descriptor4$8, _descriptor5$5, _descriptor6$3, _descriptor7$3, _descriptor8$3, _descriptor9$2, _descriptor10$1, _descriptor11$1, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16, _class3$2, _temp$g;
            var HorizontalTextAlignment;

            (function (HorizontalTextAlignment) {
              HorizontalTextAlignment[HorizontalTextAlignment["LEFT"] = 0] = "LEFT";
              HorizontalTextAlignment[HorizontalTextAlignment["CENTER"] = 1] = "CENTER";
              HorizontalTextAlignment[HorizontalTextAlignment["RIGHT"] = 2] = "RIGHT";
            })(HorizontalTextAlignment || (HorizontalTextAlignment = exports('HorizontalTextAlignment', {})));

            ccenum(HorizontalTextAlignment);
            var VerticalTextAlignment;

            (function (VerticalTextAlignment) {
              VerticalTextAlignment[VerticalTextAlignment["TOP"] = 0] = "TOP";
              VerticalTextAlignment[VerticalTextAlignment["CENTER"] = 1] = "CENTER";
              VerticalTextAlignment[VerticalTextAlignment["BOTTOM"] = 2] = "BOTTOM";
            })(VerticalTextAlignment || (VerticalTextAlignment = exports('VerticalTextAlignment', {})));

            ccenum(VerticalTextAlignment);
            var Overflow;

            (function (Overflow) {
              Overflow[Overflow["NONE"] = 0] = "NONE";
              Overflow[Overflow["CLAMP"] = 1] = "CLAMP";
              Overflow[Overflow["SHRINK"] = 2] = "SHRINK";
              Overflow[Overflow["RESIZE_HEIGHT"] = 3] = "RESIZE_HEIGHT";
            })(Overflow || (Overflow = exports('Overflow', {})));

            ccenum(Overflow);
            var CacheMode;

            (function (CacheMode) {
              CacheMode[CacheMode["NONE"] = 0] = "NONE";
              CacheMode[CacheMode["BITMAP"] = 1] = "BITMAP";
              CacheMode[CacheMode["CHAR"] = 2] = "CHAR";
            })(CacheMode || (CacheMode = exports('CacheMode', {})));

            ccenum(CacheMode);
            var Label = function (v) { return exports({ Label: v, LabelComponent: v }), v; }((_dec$i = ccclass('cc.Label'), _dec2$c = help(), _dec3$b = executionOrder(110), _dec4$a = menu(), _dec5$a = displayOrder(), _dec6$9 = tooltip(), _dec7$9 = type(HorizontalTextAlignment), _dec8$8 = displayOrder(), _dec9$8 = tooltip(), _dec10$6 = type(VerticalTextAlignment), _dec11$5 = displayOrder(), _dec12$4 = tooltip(), _dec13$4 = displayOrder(), _dec14$2 = tooltip(), _dec15$2 = displayOrder(), _dec16$2 = visible(), _dec17$1 = tooltip(), _dec18 = displayOrder(), _dec19 = tooltip(), _dec20 = type(Overflow), _dec21 = displayOrder(), _dec22 = tooltip(), _dec23 = displayOrder(), _dec24 = tooltip(), _dec25 = type(Font), _dec26 = displayOrder(), _dec27 = visible(), _dec28 = tooltip(), _dec29 = displayOrder(), _dec30 = tooltip(), _dec31 = type(CacheMode), _dec32 = displayOrder(), _dec33 = tooltip(), _dec34 = displayOrder(), _dec35 = tooltip(), _dec36 = displayOrder(), _dec37 = tooltip(), _dec38 = displayOrder(), _dec39 = tooltip(), _dec40 = visible(), _dec$i(_class$i = _dec2$c(_class$i = _dec3$b(_class$i = _dec4$a(_class$i = (_class2$f = (_temp$g = _class3$2 = function (_Renderable2D) {
              _inheritsLoose(Label, _Renderable2D);

              _createClass(Label, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  value += '';

                  if (this._string === value) {
                    return;
                  }

                  this._string = value;
                  this.updateRenderData();
                }
              }, {
                key: "horizontalAlign",
                get: function get() {
                  return this._horizontalAlign;
                },
                set: function set(value) {
                  if (this._horizontalAlign === value) {
                    return;
                  }

                  this._horizontalAlign = value;
                  this.updateRenderData();
                }
              }, {
                key: "verticalAlign",
                get: function get() {
                  return this._verticalAlign;
                },
                set: function set(value) {
                  if (this._verticalAlign === value) {
                    return;
                  }

                  this._verticalAlign = value;
                  this.updateRenderData();
                }
              }, {
                key: "actualFontSize",
                get: function get() {
                  return this._actualFontSize;
                },
                set: function set(value) {
                  this._actualFontSize = value;
                }
              }, {
                key: "fontSize",
                get: function get() {
                  return this._fontSize;
                },
                set: function set(value) {
                  if (this._fontSize === value) {
                    return;
                  }

                  this._fontSize = value;
                  this.updateRenderData();
                }
              }, {
                key: "fontFamily",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  if (this._fontFamily === value) {
                    return;
                  }

                  this._fontFamily = value;
                  this.updateRenderData();
                }
              }, {
                key: "lineHeight",
                get: function get() {
                  return this._lineHeight;
                },
                set: function set(value) {
                  if (this._lineHeight === value) {
                    return;
                  }

                  this._lineHeight = value;
                  this.updateRenderData();
                }
              }, {
                key: "overflow",
                get: function get() {
                  return this._overflow;
                },
                set: function set(value) {
                  if (this._overflow === value) {
                    return;
                  }

                  this._overflow = value;
                  this.updateRenderData();
                }
              }, {
                key: "enableWrapText",
                get: function get() {
                  return this._enableWrapText;
                },
                set: function set(value) {
                  if (this._enableWrapText === value) {
                    return;
                  }

                  this._enableWrapText = value;
                  this.updateRenderData();
                }
              }, {
                key: "font",
                get: function get() {
                  return this._font;
                },
                set: function set(value) {
                  if (this._font === value) {
                    return;
                  }

                  this._isSystemFontUsed = !value;

                  this._font = value;

                  if (this._renderData) {
                    this.destroyRenderData();
                    this._renderData = null;
                  }

                  this._fontAtlas = null;
                  this.updateRenderData(true);
                }
              }, {
                key: "useSystemFont",
                get: function get() {
                  return this._isSystemFontUsed;
                },
                set: function set(value) {
                  if (this._isSystemFontUsed === value) {
                    return;
                  }

                  this.destroyRenderData();
                  this._renderData = null;

                  this._isSystemFontUsed = !!value;

                  if (value) {
                    this.font = null;
                  }

                  this._flushAssembler();

                  this.updateRenderData();
                }
              }, {
                key: "cacheMode",
                get: function get() {
                  return this._cacheMode;
                },
                set: function set(value) {
                  if (this._cacheMode === value) {
                    return;
                  }

                  if (this._cacheMode === CacheMode.BITMAP && !(this._font instanceof BitmapFont) && this._ttfSpriteFrame) {
                    this._ttfSpriteFrame._resetDynamicAtlasFrame();
                  }

                  if (this._cacheMode === CacheMode.CHAR) {
                    this._ttfSpriteFrame = null;
                  }

                  this._cacheMode = value;
                  this.updateRenderData(true);
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._texture;
                }
              }, {
                key: "ttfSpriteFrame",
                get: function get() {
                  return this._ttfSpriteFrame;
                }
              }, {
                key: "isBold",
                get: function get() {
                  return this._isBold;
                },
                set: function set(value) {
                  if (this._isBold === value) {
                    return;
                  }

                  this._isBold = value;
                  this.updateRenderData();
                }
              }, {
                key: "isItalic",
                get: function get() {
                  return this._isItalic;
                },
                set: function set(value) {
                  if (this._isItalic === value) {
                    return;
                  }

                  this._isItalic = value;
                  this.updateRenderData();
                }
              }, {
                key: "isUnderline",
                get: function get() {
                  return this._isUnderline;
                },
                set: function set(value) {
                  if (this._isUnderline === value) {
                    return;
                  }

                  this._isUnderline = value;
                  this.updateRenderData();
                }
              }, {
                key: "underlineHeight",
                get: function get() {
                  return this._underlineHeight;
                },
                set: function set(value) {
                  if (this._underlineHeight === value) return;
                  this._underlineHeight = value;
                  this.updateRenderData();
                }
              }, {
                key: "assemblerData",
                get: function get() {
                  return this._assemblerData;
                }
              }, {
                key: "fontAtlas",
                get: function get() {
                  return this._fontAtlas;
                },
                set: function set(value) {
                  this._fontAtlas = value;
                }
              }, {
                key: "spacingX",
                get: function get() {
                  return this._spacingX;
                },
                set: function set(value) {
                  if (this._spacingX === value) {
                    return;
                  }

                  this._spacingX = value;
                  this.updateRenderData();
                }
              }, {
                key: "_bmFontOriginalSize",
                get: function get() {
                  if (this._font instanceof BitmapFont) {
                    return this._font.fontSize;
                  } else {
                    return -1;
                  }
                }
              }]);

              function Label() {
                var _this;

                _this = _Renderable2D.call(this) || this;

                _initializerDefineProperty(_this, "_string", _descriptor$f, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_horizontalAlign", _descriptor2$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_verticalAlign", _descriptor3$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_actualFontSize", _descriptor4$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fontSize", _descriptor5$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fontFamily", _descriptor6$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lineHeight", _descriptor7$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_overflow", _descriptor8$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_enableWrapText", _descriptor9$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_font", _descriptor10$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor11$1, _assertThisInitialized(_this));

                _this._spacingX = 0;

                _initializerDefineProperty(_this, "_isItalic", _descriptor12, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isBold", _descriptor13, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isUnderline", _descriptor14, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_underlineHeight", _descriptor15, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_cacheMode", _descriptor16, _assertThisInitialized(_this));

                _this._N$file = null;
                _this._texture = null;
                _this._ttfSpriteFrame = null;
                _this._userDefinedFont = null;
                _this._assemblerData = null;
                _this._fontAtlas = null;
                _this._letterTexture = null;

                _this._ttfSpriteFrame = null;
                return _this;
              }

              var _proto = Label.prototype;

              _proto.onEnable = function onEnable() {
                _Renderable2D.prototype.onEnable.call(this);

                if (!this._font && !this._isSystemFontUsed) {
                  this.useSystemFont = true;
                }

                if (this._isSystemFontUsed && !this._fontFamily) {
                  this.fontFamily = 'Arial';
                }

                this.updateRenderData(true);
              };

              _proto.onDisable = function onDisable() {
                _Renderable2D.prototype.onDisable.call(this);
              };

              _proto.onDestroy = function onDestroy() {
                if (this._assembler && this._assembler.resetAssemblerData) {
                  this._assembler.resetAssemblerData(this._assemblerData);
                }

                this._assemblerData = null;

                if (this._ttfSpriteFrame) {
                  var tex = this._ttfSpriteFrame.texture;

                  if (tex && this._ttfSpriteFrame.original === null) {
                    var tex2d = tex;

                    if (tex2d.image) {
                      tex2d.image.destroy();
                    }

                    tex.destroy();
                  }

                  this._ttfSpriteFrame = null;
                }

                this._letterTexture = null;

                _Renderable2D.prototype.onDestroy.call(this);
              };

              _proto.updateRenderData = function updateRenderData(force) {
                if (force === void 0) {
                  force = false;
                }

                this.markForUpdateRenderData();

                if (force) {
                  this._flushAssembler();

                  this._applyFontTexture();
                }
              };

              _proto._render = function _render(render) {
                render.commitComp(this, this._texture, this._assembler, null);
              };

              _proto._updateColor = function _updateColor() {
                if (this._font instanceof BitmapFont) {
                  _Renderable2D.prototype._updateColor.call(this);
                } else {
                  this.updateRenderData(false);
                }
              };

              _proto._canRender = function _canRender() {
                if (!_Renderable2D.prototype._canRender.call(this) || !this._string) {
                  return false;
                }

                var font = this._font;

                if (font && font instanceof BitmapFont) {
                  var spriteFrame = font.spriteFrame;

                  if (!spriteFrame || !spriteFrame.textureLoaded()) {
                    return false;
                  }
                }

                return true;
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Label.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this._renderData.material = this.material;
                  }
                }
              };

              _proto._applyFontTexture = function _applyFontTexture() {
                var _this2 = this;

                var font = this._font;

                if (font instanceof BitmapFont) {
                  var spriteFrame = font.spriteFrame;

                  var onBMFontTextureLoaded = function onBMFontTextureLoaded() {
                    _this2._texture = spriteFrame;

                    if (_this2._assembler) {
                      _this2._assembler.updateRenderData(_this2);
                    }
                  };

                  if (spriteFrame) {
                    if (spriteFrame.loaded || spriteFrame.textureLoaded) {
                      onBMFontTextureLoaded();
                    } else {
                      spriteFrame.once('load', onBMFontTextureLoaded, this);
                    }
                  }
                } else {
                  if (this.cacheMode === CacheMode.CHAR) {
                    this._letterTexture = this._assembler.getAssemblerData();
                    this._texture = this._letterTexture;
                  } else if (!this._ttfSpriteFrame) {
                    this._ttfSpriteFrame = new SpriteFrame();
                    this._assemblerData = this._assembler.getAssemblerData();
                    var image = new ImageAsset(this._assemblerData.canvas);
                    var tex = image._texture;
                    this._ttfSpriteFrame.texture = tex;
                  }

                  if (this.cacheMode !== CacheMode.CHAR) {
                    this._texture = this._ttfSpriteFrame;
                  }
                }
              };

              return Label;
            }(Renderable2D), _class3$2.HorizontalAlign = HorizontalTextAlignment, _class3$2.VerticalAlign = VerticalTextAlignment, _class3$2.Overflow = Overflow, _class3$2.CacheMode = CacheMode, _class3$2._canvasPool = CanvasPool.getInstance(), _temp$g), (_applyDecoratedDescriptor(_class2$f.prototype, "string", [_dec5$a, _dec6$9, multiline], Object.getOwnPropertyDescriptor(_class2$f.prototype, "string"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "horizontalAlign", [_dec7$9, _dec8$8, _dec9$8], Object.getOwnPropertyDescriptor(_class2$f.prototype, "horizontalAlign"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "verticalAlign", [_dec10$6, _dec11$5, _dec12$4], Object.getOwnPropertyDescriptor(_class2$f.prototype, "verticalAlign"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "fontSize", [_dec13$4, _dec14$2], Object.getOwnPropertyDescriptor(_class2$f.prototype, "fontSize"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "fontFamily", [_dec15$2, _dec16$2, _dec17$1], Object.getOwnPropertyDescriptor(_class2$f.prototype, "fontFamily"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "lineHeight", [_dec18, _dec19], Object.getOwnPropertyDescriptor(_class2$f.prototype, "lineHeight"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "overflow", [_dec20, _dec21, _dec22], Object.getOwnPropertyDescriptor(_class2$f.prototype, "overflow"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "enableWrapText", [_dec23, _dec24], Object.getOwnPropertyDescriptor(_class2$f.prototype, "enableWrapText"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "font", [_dec25, _dec26, _dec27, _dec28], Object.getOwnPropertyDescriptor(_class2$f.prototype, "font"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "useSystemFont", [_dec29, _dec30], Object.getOwnPropertyDescriptor(_class2$f.prototype, "useSystemFont"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "cacheMode", [_dec31, _dec32, _dec33], Object.getOwnPropertyDescriptor(_class2$f.prototype, "cacheMode"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "isBold", [_dec34, _dec35], Object.getOwnPropertyDescriptor(_class2$f.prototype, "isBold"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "isItalic", [_dec36, _dec37], Object.getOwnPropertyDescriptor(_class2$f.prototype, "isItalic"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "isUnderline", [_dec38, _dec39], Object.getOwnPropertyDescriptor(_class2$f.prototype, "isUnderline"), _class2$f.prototype), _applyDecoratedDescriptor(_class2$f.prototype, "underlineHeight", [_dec40, editable], Object.getOwnPropertyDescriptor(_class2$f.prototype, "underlineHeight"), _class2$f.prototype), _descriptor$f = _applyDecoratedDescriptor(_class2$f.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 'label';
              }
            }), _descriptor2$c = _applyDecoratedDescriptor(_class2$f.prototype, "_horizontalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return HorizontalTextAlignment.CENTER;
              }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$f.prototype, "_verticalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return VerticalTextAlignment.CENTER;
              }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$f.prototype, "_actualFontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$f.prototype, "_fontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 40;
              }
            }), _descriptor6$3 = _applyDecoratedDescriptor(_class2$f.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 'Arial';
              }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class2$f.prototype, "_lineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 40;
              }
            }), _descriptor8$3 = _applyDecoratedDescriptor(_class2$f.prototype, "_overflow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Overflow.NONE;
              }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class2$f.prototype, "_enableWrapText", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class2$f.prototype, "_font", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor11$1 = _applyDecoratedDescriptor(_class2$f.prototype, "_isSystemFontUsed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor12 = _applyDecoratedDescriptor(_class2$f.prototype, "_isItalic", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor13 = _applyDecoratedDescriptor(_class2$f.prototype, "_isBold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor14 = _applyDecoratedDescriptor(_class2$f.prototype, "_isUnderline", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor15 = _applyDecoratedDescriptor(_class2$f.prototype, "_underlineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 2;
              }
            }), _descriptor16 = _applyDecoratedDescriptor(_class2$f.prototype, "_cacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return CacheMode.NONE;
              }
            })), _class2$f)) || _class$i) || _class$i) || _class$i) || _class$i));

            var LineCap;

            (function (LineCap) {
              LineCap[LineCap["BUTT"] = 0] = "BUTT";
              LineCap[LineCap["ROUND"] = 1] = "ROUND";
              LineCap[LineCap["SQUARE"] = 2] = "SQUARE";
            })(LineCap || (LineCap = {}));

            ccenum(LineCap);
            var LineJoin;

            (function (LineJoin) {
              LineJoin[LineJoin["BEVEL"] = 0] = "BEVEL";
              LineJoin[LineJoin["ROUND"] = 1] = "ROUND";
              LineJoin[LineJoin["MITER"] = 2] = "MITER";
            })(LineJoin || (LineJoin = {}));

            ccenum(LineJoin);
            var PointFlags;

            (function (PointFlags) {
              PointFlags[PointFlags["PT_CORNER"] = 1] = "PT_CORNER";
              PointFlags[PointFlags["PT_LEFT"] = 2] = "PT_LEFT";
              PointFlags[PointFlags["PT_BEVEL"] = 4] = "PT_BEVEL";
              PointFlags[PointFlags["PT_INNERBEVEL"] = 8] = "PT_INNERBEVEL";
            })(PointFlags || (PointFlags = {}));

            ccenum(PointFlags);

            var PI = Math.PI;
            var min = Math.min;
            var max = Math.max;
            var cos = Math.cos;
            var sin = Math.sin;
            var abs = Math.abs;
            var sign = Math.sign;
            var KAPPA90 = 0.5522847493;
            function arc(ctx, cx, cy, r, startAngle, endAngle, counterclockwise) {
              counterclockwise = counterclockwise || false;
              var a = 0;
              var da = 0;
              var hda = 0;
              var kappa = 0;
              var dx = 0;
              var dy = 0;
              var x = 0;
              var y = 0;
              var tanx = 0;
              var tany = 0;
              var px = 0;
              var py = 0;
              var ptanx = 0;
              var ptany = 0;
              var i = 0;
              var ndivs = 0;
              da = endAngle - startAngle;

              if (counterclockwise) {
                if (abs(da) >= PI * 2) {
                  da = PI * 2;
                } else {
                  while (da < 0) {
                    da += PI * 2;
                  }
                }
              } else if (abs(da) >= PI * 2) {
                da = -PI * 2;
              } else {
                while (da > 0) {
                  da -= PI * 2;
                }
              }

              ndivs = max(1, min(abs(da) / (PI * 0.5) + 0.5, 5)) | 0;
              hda = da / ndivs / 2.0;
              kappa = abs(4.0 / 3.0 * (1 - cos(hda)) / sin(hda));

              if (!counterclockwise) {
                kappa = -kappa;
              }

              for (i = 0; i <= ndivs; i++) {
                a = startAngle + da * (i / ndivs);
                dx = cos(a);
                dy = sin(a);
                x = cx + dx * r;
                y = cy + dy * r;
                tanx = -dy * r * kappa;
                tany = dx * r * kappa;

                if (i === 0) {
                  ctx.moveTo(x, y);
                } else {
                  ctx.bezierCurveTo(px + ptanx, py + ptany, x - tanx, y - tany, x, y);
                }

                px = x;
                py = y;
                ptanx = tanx;
                ptany = tany;
              }
            }
            function ellipse(ctx, cx, cy, rx, ry) {
              ctx.moveTo(cx - rx, cy);
              ctx.bezierCurveTo(cx - rx, cy + ry * KAPPA90, cx - rx * KAPPA90, cy + ry, cx, cy + ry);
              ctx.bezierCurveTo(cx + rx * KAPPA90, cy + ry, cx + rx, cy + ry * KAPPA90, cx + rx, cy);
              ctx.bezierCurveTo(cx + rx, cy - ry * KAPPA90, cx + rx * KAPPA90, cy - ry, cx, cy - ry);
              ctx.bezierCurveTo(cx - rx * KAPPA90, cy - ry, cx - rx, cy - ry * KAPPA90, cx - rx, cy);
              ctx.close();
            }
            function roundRect(ctx, x, y, w, h, r) {
              if (r < 0.1) {
                ctx.rect(x, y, w, h);
              } else {
                var rx = min(r, abs(w) * 0.5) * sign(w);
                var ry = min(r, abs(h) * 0.5) * sign(h);
                ctx.moveTo(x, y + ry);
                ctx.lineTo(x, y + h - ry);
                ctx.bezierCurveTo(x, y + h - ry * (1 - KAPPA90), x + rx * (1 - KAPPA90), y + h, x + rx, y + h);
                ctx.lineTo(x + w - rx, y + h);
                ctx.bezierCurveTo(x + w - rx * (1 - KAPPA90), y + h, x + w, y + h - ry * (1 - KAPPA90), x + w, y + h - ry);
                ctx.lineTo(x + w, y + ry);
                ctx.bezierCurveTo(x + w, y + ry * (1 - KAPPA90), x + w - rx * (1 - KAPPA90), y, x + w - rx, y);
                ctx.lineTo(x + rx, y);
                ctx.bezierCurveTo(x + rx * (1 - KAPPA90), y, x, y + ry * (1 - KAPPA90), x, y + ry);
                ctx.close();
              }
            }
            function tesselateBezier(ctx, x1, y1, x2, y2, x3, y3, x4, y4, level, type) {
              var x12 = 0;
              var y12 = 0;
              var x23 = 0;
              var y23 = 0;
              var x34 = 0;
              var y34 = 0;
              var x123 = 0;
              var y123 = 0;
              var x234 = 0;
              var y234 = 0;
              var x1234 = 0;
              var y1234 = 0;
              var dx = 0;
              var dy = 0;
              var d2 = 0;
              var d3 = 0;

              if (level > 10) {
                return;
              }

              x12 = (x1 + x2) * 0.5;
              y12 = (y1 + y2) * 0.5;
              x23 = (x2 + x3) * 0.5;
              y23 = (y2 + y3) * 0.5;
              x34 = (x3 + x4) * 0.5;
              y34 = (y3 + y4) * 0.5;
              x123 = (x12 + x23) * 0.5;
              y123 = (y12 + y23) * 0.5;
              dx = x4 - x1;
              dy = y4 - y1;
              d2 = abs((x2 - x4) * dy - (y2 - y4) * dx);
              d3 = abs((x3 - x4) * dy - (y3 - y4) * dx);

              if ((d2 + d3) * (d2 + d3) < ctx.tessTol * (dx * dx + dy * dy)) {
                ctx.addPoint(x4, y4, type === 0 ? type | PointFlags.PT_BEVEL : type);
                return;
              }

              x234 = (x23 + x34) * 0.5;
              y234 = (y23 + y34) * 0.5;
              x1234 = (x123 + x234) * 0.5;
              y1234 = (y123 + y234) * 0.5;
              tesselateBezier(ctx, x1, y1, x12, y12, x123, y123, x1234, y1234, level + 1, 0);
              tesselateBezier(ctx, x1234, y1234, x234, y234, x34, y34, x4, y4, level + 1, type);
            }

            var Point = function (_Vec) {
              _inheritsLoose(Point, _Vec);

              function Point(x, y) {
                var _this;

                _this = _Vec.call(this, x, y) || this;
                _this.dx = 0;
                _this.dy = 0;
                _this.dmx = 0;
                _this.dmy = 0;
                _this.flags = 0;
                _this.len = 0;

                _this.reset();

                return _this;
              }

              var _proto = Point.prototype;

              _proto.reset = function reset() {
                this.dx = 0;
                this.dy = 0;
                this.dmx = 0;
                this.dmy = 0;
                this.flags = 0;
                this.len = 0;
              };

              return Point;
            }(Vec2);
            var Path = function () {
              function Path() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;
                this.points = [];
                this.reset();
              }

              var _proto2 = Path.prototype;

              _proto2.reset = function reset() {
                this.closed = false;
                this.bevel = 0;
                this.complex = true;

                if (this.points) {
                  this.points.length = 0;
                } else {
                  this.points = [];
                }
              };

              return Path;
            }();
            var Impl = function () {
              function Impl() {
                this.dataOffset = 0;
                this.updatePathOffset = false;
                this.pathLength = 0;
                this.pathOffset = 0;
                this.paths = [];
                this.tessTol = 0.25;
                this.distTol = 0.01;
                this.fillColor = Color.WHITE.clone();
                this.lineCap = LineCap.BUTT;
                this.strokeColor = Color.BLACK.clone();
                this.lineJoin = LineJoin.MITER;
                this.lineWidth = 0;
                this.pointsOffset = 0;
                this._commandX = 0;
                this._commandY = 0;
                this._points = [];
                this._renderDataList = [];
                this._curPath = null;
              }

              var _proto3 = Impl.prototype;

              _proto3.moveTo = function moveTo(x, y) {
                if (this.updatePathOffset) {
                  this.pathOffset = this.pathLength;
                  this.updatePathOffset = false;
                }

                this._addPath();

                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.lineTo = function lineTo(x, y) {
                this.addPoint(x, y, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                var path = this._curPath;
                var last = path.points[path.points.length - 1];

                if (!last) {
                  return;
                }

                if (last.x === c1x && last.y === c1y && c2x === x && c2y === y) {
                  this.lineTo(x, y);
                  return;
                }

                tesselateBezier(this, last.x, last.y, c1x, c1y, c2x, c2y, x, y, 0, PointFlags.PT_CORNER);
                this._commandX = x;
                this._commandY = y;
              };

              _proto3.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
                var x0 = this._commandX;
                var y0 = this._commandY;
                this.bezierCurveTo(x0 + 2.0 / 3.0 * (cx - x0), y0 + 2.0 / 3.0 * (cy - y0), x + 2.0 / 3.0 * (cx - x), y + 2.0 / 3.0 * (cy - y), x, y);
              };

              _proto3.arc = function arc$1(cx, cy, r, startAngle, endAngle, counterclockwise) {
                arc(this, cx, cy, r, startAngle, endAngle, counterclockwise);
              };

              _proto3.ellipse = function ellipse$1(cx, cy, rx, ry) {
                ellipse(this, cx, cy, rx, ry);

                this._curPath.complex = false;
              };

              _proto3.circle = function circle(cx, cy, r) {
                ellipse(this, cx, cy, r, r);

                this._curPath.complex = false;
              };

              _proto3.rect = function rect(x, y, w, h) {
                this.moveTo(x, y);
                this.lineTo(x + w, y);
                this.lineTo(x + w, y + h);
                this.lineTo(x, y + h);
                this.close();
                this._curPath.complex = false;
              };

              _proto3.roundRect = function roundRect$1(x, y, w, h, r) {
                roundRect(this, x, y, w, h, r);

                this._curPath.complex = false;
              };

              _proto3.clear = function clear() {
                this.pathLength = 0;
                this.pathOffset = 0;
                this.pointsOffset = 0;
                this.dataOffset = 0;
                this._curPath = null;
                this.paths.length = 0;
                this._points.length = 0;
                var dataList = this._renderDataList;

                for (var i = 0, l = dataList.length; i < l; i++) {
                  var data = dataList[i];

                  if (!data) {
                    continue;
                  }

                  MeshRenderData.remove(data);
                }

                this._renderDataList.length = 0;
              };

              _proto3.close = function close() {
                this._curPath.closed = true;
              };

              _proto3.requestRenderData = function requestRenderData() {
                var renderData = MeshRenderData.add();

                this._renderDataList.push(renderData);

                return renderData;
              };

              _proto3.getRenderDataList = function getRenderDataList() {
                if (this._renderDataList.length === 0) {
                  this.requestRenderData();
                }

                return this._renderDataList;
              };

              _proto3.addPoint = function addPoint(x, y, flags) {
                var path = this._curPath;

                if (!path) {
                  return;
                }

                var points = this._points;
                var pathPoints = path.points;
                var offset = this.pointsOffset++;
                var pt = points[offset];

                if (!pt) {
                  pt = new Point(x, y);
                  points.push(pt);
                } else {
                  pt.x = x;
                  pt.y = y;
                }

                pt.flags = flags;
                pathPoints.push(pt);
              };

              _proto3._addPath = function _addPath() {
                var offset = this.pathLength;
                var path = this.paths[offset];

                if (!path) {
                  path = new Path();
                  this.paths.push(path);
                } else {
                  path.reset();
                }

                this.pathLength++;
                this._curPath = path;
                return path;
              };

              return Impl;
            }();

            var vfmt = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F)];
            var vfmtPosColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var vfmtPosUvColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F)];
            var vfmtPosUvTwoColor = [new Attribute(AttributeName.ATTR_POSITION, Format.RGB32F), new Attribute(AttributeName.ATTR_TEX_COORD, Format.RG32F), new Attribute(AttributeName.ATTR_COLOR, Format.RGBA32F), new Attribute(AttributeName.ATTR_COLOR2, Format.RGBA32F)];
            function getComponentPerVertex(attrs) {
              var count = 0;

              for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var info = FormatInfos[attr.format];
                count += info.count;
              }

              return count;
            }
            function getAttributeStride(attrs) {
              var count = 0;

              for (var i = 0; i < attrs.length; i++) {
                var attr = attrs[i];
                var info = FormatInfos[attr.format];
                count += info.size;
              }

              return count;
            }
            legacyCC.internal.vfmtPosUvColor = vfmtPosUvColor;
            legacyCC.internal.vfmtPosUvTwoColor = vfmtPosUvTwoColor;

            var vertexFormat = /*#__PURE__*/Object.freeze({
                __proto__: null,
                vfmt: vfmt,
                vfmtPosColor: vfmtPosColor,
                vfmtPosUvColor: vfmtPosUvColor,
                vfmtPosUvTwoColor: vfmtPosUvTwoColor,
                getComponentPerVertex: getComponentPerVertex,
                getAttributeStride: getAttributeStride
            });
            exports('UIVertexFormat', vertexFormat);

            var _dec$j, _dec2$d, _dec3$c, _dec4$b, _dec5$b, _dec6$a, _dec7$a, _dec8$9, _dec9$9, _dec10$7, _dec11$6, _dec12$5, _dec13$5, _dec14$3, _class$j, _class2$g, _descriptor$g, _descriptor2$d, _descriptor3$c, _descriptor4$9, _descriptor5$6, _descriptor6$4, _class3$3, _temp$h;
            var attributes = vfmtPosColor.concat([new Attribute('a_dist', Format.R32F)]);
            var componentPerVertex = getComponentPerVertex(attributes);
            var stride = getAttributeStride(attributes);
            var Graphics = function (v) { return exports({ Graphics: v, GraphicsComponent: v }), v; }((_dec$j = ccclass('cc.Graphics'), _dec2$d = help(), _dec3$c = executionOrder(110), _dec4$b = menu(), _dec5$b = type(LineJoin), _dec6$a = tooltip(), _dec7$a = type(LineCap), _dec8$9 = tooltip(), _dec9$9 = tooltip(), _dec10$7 = tooltip(), _dec11$6 = tooltip(), _dec12$5 = visible(), _dec13$5 = visible(), _dec14$3 = visible(), _dec$j(_class$j = _dec2$d(_class$j = _dec3$c(_class$j = _dec4$b(_class$j = (_class2$g = (_temp$h = _class3$3 = function (_Renderable2D) {
              _inheritsLoose(Graphics, _Renderable2D);

              _createClass(Graphics, [{
                key: "lineWidth",
                get: function get() {
                  return this._lineWidth;
                },
                set: function set(value) {
                  this._lineWidth = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineWidth = value;
                }
              }, {
                key: "lineJoin",
                get: function get() {
                  return this._lineJoin;
                },
                set: function set(value) {
                  this._lineJoin = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineJoin = value;
                }
              }, {
                key: "lineCap",
                get: function get() {
                  return this._lineCap;
                },
                set: function set(value) {
                  this._lineCap = value;

                  if (!this.impl) {
                    return;
                  }

                  this.impl.lineCap = value;
                }
              }, {
                key: "strokeColor",
                get: function get() {
                  return this._strokeColor;
                },
                set: function set(value) {
                  if (!this.impl) {
                    return;
                  }

                  this._strokeColor.set(value);

                  this.impl.strokeColor = this._strokeColor;
                }
              }, {
                key: "fillColor",
                get: function get() {
                  return this._fillColor;
                },
                set: function set(value) {
                  if (!this.impl) {
                    return;
                  }

                  this._fillColor.set(value);

                  this.impl.fillColor = this._fillColor;
                }
              }, {
                key: "miterLimit",
                get: function get() {
                  return this._miterLimit;
                },
                set: function set(value) {
                  this._miterLimit = value;
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateColor();

                  this.markForUpdateRenderData();
                }
              }, {
                key: "srcBlendFactor",
                get: function get() {
                  return this._srcBlendFactor;
                },
                set: function set(value) {}
              }, {
                key: "dstBlendFactor",
                get: function get() {
                  return this._dstBlendFactor;
                },
                set: function set(value) {}
              }]);

              function Graphics() {
                var _this;

                _this = _Renderable2D.call(this) || this;
                _this.impl = null;
                _this.model = null;

                _initializerDefineProperty(_this, "_lineWidth", _descriptor$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_strokeColor", _descriptor2$d, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lineJoin", _descriptor3$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lineCap", _descriptor4$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fillColor", _descriptor5$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_miterLimit", _descriptor6$4, _assertThisInitialized(_this));

                _this._isDrawing = false;
                _this._isNeedUploadData = true;
                _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
                _this.impl = new Impl();
                return _this;
              }

              var _proto = Graphics.prototype;

              _proto.onRestore = function onRestore() {
                if (!this.impl) {
                  this._flushAssembler();
                }
              };

              _proto.onLoad = function onLoad() {
                this.model = director.root.createModel(Model);
                this.model.node = this.model.transform = this.node;

                this._flushAssembler();
              };

              _proto.onEnable = function onEnable() {
                _Renderable2D.prototype.onEnable.call(this);

                this._updateMtlForGraphics();
              };

              _proto.onDisable = function onDisable() {
                _Renderable2D.prototype.onDisable.call(this);
              };

              _proto.onDestroy = function onDestroy() {
                _Renderable2D.prototype.onDestroy.call(this);

                this._sceneGetter = null;

                if (this.model) {
                  director.root.destroyModel(this.model);
                  this.model = null;
                }

                if (!this.impl) {
                  return;
                }

                this._isDrawing = false;
                this.impl.clear();
                this.impl = null;
              };

              _proto.moveTo = function moveTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.moveTo(x, y);
              };

              _proto.lineTo = function lineTo(x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.lineTo(x, y);
              };

              _proto.bezierCurveTo = function bezierCurveTo(c1x, c1y, c2x, c2y, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.bezierCurveTo(c1x, c1y, c2x, c2y, x, y);
              };

              _proto.quadraticCurveTo = function quadraticCurveTo(cx, cy, x, y) {
                if (!this.impl) {
                  return;
                }

                this.impl.quadraticCurveTo(cx, cy, x, y);
              };

              _proto.arc = function arc(cx, cy, r, startAngle, endAngle, counterclockwise) {
                if (!this.impl) {
                  return;
                }

                this.impl.arc(cx, cy, r, startAngle, endAngle, counterclockwise);
              };

              _proto.ellipse = function ellipse(cx, cy, rx, ry) {
                if (!this.impl) {
                  return;
                }

                this.impl.ellipse(cx, cy, rx, ry);
              };

              _proto.circle = function circle(cx, cy, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.circle(cx, cy, r);
              };

              _proto.rect = function rect(x, y, w, h) {
                if (!this.impl) {
                  return;
                }

                this.impl.rect(x, y, w, h);
              };

              _proto.roundRect = function roundRect(x, y, w, h, r) {
                if (!this.impl) {
                  return;
                }

                this.impl.roundRect(x, y, w, h, r);
              };

              _proto.fillRect = function fillRect(x, y, w, h) {
                this.rect(x, y, w, h);
                this.fill();
              };

              _proto.clear = function clear() {
                if (!this.impl) {
                  return;
                }

                this.impl.clear();
                this._isDrawing = false;

                if (this.model) {
                  for (var i = 0; i < this.model.subModels.length; i++) {
                    var subModel = this.model.subModels[i];
                    subModel.inputAssembler.indexCount = 0;
                  }
                }

                this.markForUpdateRenderData();
              };

              _proto.close = function close() {
                if (!this.impl) {
                  return;
                }

                this.impl.close();
              };

              _proto.stroke = function stroke() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.stroke(this);
              };

              _proto.fill = function fill() {
                if (!this._assembler) {
                  this._flushAssembler();
                }

                this._isDrawing = true;
                this._isNeedUploadData = true;

                this._assembler.fill(this);
              };

              _proto._updateMtlForGraphics = function _updateMtlForGraphics() {
                var mat;

                if (this._customMaterial) {
                  mat = this.getMaterialInstance(0);
                } else {
                  mat = builtinResMgr.get('ui-graphics-material');
                  this.setMaterial(mat, 0);
                  mat = this.getMaterialInstance(0);
                  mat.recompileShaders({
                    USE_LOCAL: true
                  });
                }
              };

              _proto.activeSubModel = function activeSubModel(idx) {
                if (!this.model) {
                  warnID(4500, this.node.name);
                  return;
                }

                if (this.model.subModels.length <= idx) {
                  var gfxDevice = legacyCC.director.root.device;
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * stride, stride));
                  var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 65535 * Uint16Array.BYTES_PER_ELEMENT * 2, Uint16Array.BYTES_PER_ELEMENT));
                  var renderMesh = new RenderingSubMesh([vertexBuffer], attributes, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  renderMesh.subMeshIdx = 0;
                  this.model.initSubModel(idx, renderMesh, this.getMaterialInstance(0));
                }
              };

              _proto._uploadData = function _uploadData(render) {
                var impl = this.impl;

                if (!impl) {
                  return;
                }

                var renderDataList = impl && impl.getRenderDataList();

                if (renderDataList.length <= 0 || !this.model) {
                  return;
                }

                var subModelList = this.model.subModels;

                for (var i = 0; i < renderDataList.length; i++) {
                  var renderData = renderDataList[i];
                  var ia = subModelList[i].inputAssembler;

                  if (renderData.lastFilledVertex === renderData.vertexStart) {
                    continue;
                  }

                  var vb = new Float32Array(renderData.vData.buffer, 0, renderData.vertexStart * componentPerVertex);
                  ia.vertexBuffers[0].update(vb);
                  ia.vertexCount = renderData.vertexStart;
                  var ib = new Uint16Array(renderData.iData.buffer, 0, renderData.indicesStart);
                  ia.indexBuffer.update(ib);
                  ia.indexCount = renderData.indicesStart;
                  renderData.lastFilledVertex = renderData.vertexStart;
                  renderData.lastFilledIndices = renderData.indicesStart;
                }

                render.removeUploadBuffersFunc(this);
                this._isNeedUploadData = false;
              };

              _proto._render = function _render(render) {
                if (this._isNeedUploadData) {
                  if (this.impl) {
                    var renderDataList = this.impl.getRenderDataList();
                    var len = this.model.subModels.length;

                    if (renderDataList.length > len) {
                      for (var i = len; i < renderDataList.length; i++) {
                        this.activeSubModel(i);
                      }
                    }
                  }

                  render.addUploadBuffersFunc(this, this._uploadData);
                }

                render.commitModel(this, this.model, this.getMaterialInstance(0));
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Graphics.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this._assembler = assembler;
                }
              };

              _proto._canRender = function _canRender() {
                if (!_Renderable2D.prototype._canRender.call(this)) {
                  return false;
                }

                return !!this.model && this._isDrawing;
              };

              return Graphics;
            }(Renderable2D), _class3$3.LineJoin = LineJoin, _class3$3.LineCap = LineCap, _temp$h), (_applyDecoratedDescriptor(_class2$g.prototype, "lineWidth", [editable], Object.getOwnPropertyDescriptor(_class2$g.prototype, "lineWidth"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "lineJoin", [_dec5$b, _dec6$a], Object.getOwnPropertyDescriptor(_class2$g.prototype, "lineJoin"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "lineCap", [_dec7$a, _dec8$9], Object.getOwnPropertyDescriptor(_class2$g.prototype, "lineCap"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "strokeColor", [_dec9$9], Object.getOwnPropertyDescriptor(_class2$g.prototype, "strokeColor"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "fillColor", [_dec10$7], Object.getOwnPropertyDescriptor(_class2$g.prototype, "fillColor"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "miterLimit", [_dec11$6], Object.getOwnPropertyDescriptor(_class2$g.prototype, "miterLimit"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "color", [override, _dec12$5], Object.getOwnPropertyDescriptor(_class2$g.prototype, "color"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "srcBlendFactor", [override, _dec13$5], Object.getOwnPropertyDescriptor(_class2$g.prototype, "srcBlendFactor"), _class2$g.prototype), _applyDecoratedDescriptor(_class2$g.prototype, "dstBlendFactor", [override, _dec14$3], Object.getOwnPropertyDescriptor(_class2$g.prototype, "dstBlendFactor"), _class2$g.prototype), _descriptor$g = _applyDecoratedDescriptor(_class2$g.prototype, "_lineWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$g.prototype, "_strokeColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.BLACK.clone();
              }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$g.prototype, "_lineJoin", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return LineJoin.MITER;
              }
            }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$g.prototype, "_lineCap", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return LineCap.BUTT;
              }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$g.prototype, "_fillColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.WHITE.clone();
              }
            }), _descriptor6$4 = _applyDecoratedDescriptor(_class2$g.prototype, "_miterLimit", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 10;
              }
            })), _class2$g)) || _class$j) || _class$j) || _class$j) || _class$j));

            var _dec$k, _dec2$e, _dec3$d, _dec4$c, _dec5$c, _dec6$b, _dec7$b, _dec8$a, _dec9$a, _dec10$8, _dec11$7, _dec12$6, _dec13$6, _dec14$4, _dec15$3, _dec16$3, _dec17$2, _dec18$1, _class$k, _class2$h, _descriptor$h, _descriptor2$e, _descriptor3$d, _descriptor4$a, _descriptor5$7, _class3$4, _temp$i;

            var _worldMatrix$2 = new Mat4();

            var _vec2_temp = new Vec2();

            var _mat4_temp$1 = new Mat4();

            var _circlePoints = [];

            function _calculateCircle(center, radius, segments) {
              _circlePoints.length = 0;
              var anglePerStep = Math.PI * 2 / segments;

              for (var step = 0; step < segments; ++step) {
                _circlePoints.push(new Vec3(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y, 0));
              }

              return _circlePoints;
            }

            var MaskType;

            (function (MaskType) {
              MaskType[MaskType["RECT"] = 0] = "RECT";
              MaskType[MaskType["ELLIPSE"] = 1] = "ELLIPSE";
              MaskType[MaskType["GRAPHICS_STENCIL"] = 2] = "GRAPHICS_STENCIL";
              MaskType[MaskType["IMAGE_STENCIL"] = 3] = "IMAGE_STENCIL";
            })(MaskType || (MaskType = {}));

            ccenum(MaskType);
            var SEGMENTS_MIN = 3;
            var SEGMENTS_MAX = 10000;
            var Mask = function (v) { return exports({ Mask: v, MaskComponent: v }), v; }((_dec$k = ccclass('cc.Mask'), _dec2$e = help(), _dec3$d = executionOrder(110), _dec4$c = menu(), _dec5$c = type(MaskType), _dec6$b = displayOrder(), _dec7$b = tooltip(), _dec8$a = displayOrder(), _dec9$a = tooltip(), _dec10$8 = visible(), _dec11$7 = type(SpriteFrame), _dec12$6 = visible(), _dec13$6 = visible(), _dec14$4 = range(), _dec15$3 = visible(), _dec16$3 = visible(), _dec17$2 = visible(), _dec18$1 = visible(), _dec$k(_class$k = _dec2$e(_class$k = _dec3$d(_class$k = _dec4$c(_class$k = (_class2$h = (_temp$i = _class3$4 = function (_Renderable2D) {
              _inheritsLoose(Mask, _Renderable2D);

              _createClass(Mask, [{
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(value) {
                  if (this._type === value) {
                    return;
                  }

                  this._type = value;
                  this.markForUpdateRenderData(false);

                  this._updateMaterial();

                  if (this._type !== MaskType.IMAGE_STENCIL) {
                    this._spriteFrame = null;

                    this._updateGraphics();

                    if (this._renderData) {
                      this.destroyRenderData();
                      this._renderData = null;
                    }
                  } else {
                    this._useRenderData();

                    if (this._graphics) {
                      this._graphics.clear();
                    }
                  }
                }
              }, {
                key: "inverted",
                get: function get() {
                  return this._inverted;
                },
                set: function set(value) {
                  if (legacyCC.game.renderType === Game.RENDER_TYPE_CANVAS) {
                    warnID(4202);
                    return;
                  }

                  this._inverted = value;
                  this.stencilStage = Stage.DISABLED;

                  if (this._graphics) {
                    this._graphics.stencilStage = Stage.DISABLED;
                  }
                }
              }, {
                key: "segments",
                get: function get() {
                  return this._segments;
                },
                set: function set(value) {
                  if (this._segments === value) {
                    return;
                  }

                  this._segments = clamp$1(value, SEGMENTS_MIN, SEGMENTS_MAX);

                  this._updateGraphics();
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  var lastSp = this._spriteFrame;
                  this._spriteFrame = value;

                  if (this._type === MaskType.IMAGE_STENCIL) {
                    if (!lastSp && value) {
                      this.markForUpdateRenderData();
                    }
                  }
                }
              }, {
                key: "alphaThreshold",
                get: function get() {
                  return this._alphaThreshold;
                },
                set: function set(value) {
                  if (this._alphaThreshold === value) {
                    return;
                  }

                  this._alphaThreshold = value;

                  if (this.type === MaskType.IMAGE_STENCIL && this._graphics) {
                    var mat = this._graphics.getMaterialInstance(0);

                    mat.setProperty('alphaThreshold', this._alphaThreshold);
                  }
                }
              }, {
                key: "graphics",
                get: function get() {
                  return this._graphics;
                }
              }, {
                key: "dstBlendFactor",
                get: function get() {
                  return this._dstBlendFactor;
                },
                set: function set(value) {
                  if (this._dstBlendFactor === value) {
                    return;
                  }

                  this._dstBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "srcBlendFactor",
                get: function get() {
                  return this._srcBlendFactor;
                },
                set: function set(value) {
                  if (this._srcBlendFactor === value) {
                    return;
                  }

                  this._srcBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this.markForUpdateRenderData();
                }
              }, {
                key: "customMaterial",
                get: function get() {
                  return this._customMaterial;
                },
                set: function set(val) {}
              }]);

              function Mask() {
                var _this;

                _this = _Renderable2D.call(this) || this;
                _this._clearStencilMtl = null;
                _this._clearModel = null;

                _initializerDefineProperty(_this, "_type", _descriptor$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_inverted", _descriptor2$e, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_segments", _descriptor3$d, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spriteFrame", _descriptor4$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_alphaThreshold", _descriptor5$7, _assertThisInitialized(_this));

                _this._graphics = null;
                _this._instanceMaterialType = InstanceMaterialType.ADD_COLOR;
                return _this;
              }

              var _proto = Mask.prototype;

              _proto.onLoad = function onLoad() {
                this._createClearModel();

                this._createGraphics();

                if (this._graphics) {
                  this._graphics.onLoad();
                }
              };

              _proto.onEnable = function onEnable() {
                _Renderable2D.prototype.onEnable.call(this);

                this._updateGraphics();

                this._broadcastToNode(this.node);
              };

              _proto.onRestore = function onRestore() {
                this._createGraphics();

                this._updateGraphics();
              };

              _proto.onDisable = function onDisable() {
                _Renderable2D.prototype.onDisable.call(this);

                this._disableGraphics();
              };

              _proto.onDestroy = function onDestroy() {
                _Renderable2D.prototype.onDestroy.call(this);

                if (this._clearModel) {
                  director.root.destroyModel(this._clearModel);
                }

                if (this._clearStencilMtl) {
                  this._clearStencilMtl.destroy();
                }

                this._removeGraphics();
              };

              _proto.isHit = function isHit(cameraPt) {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var size = uiTrans.contentSize;
                var w = size.width;
                var h = size.height;
                var testPt = _vec2_temp;
                this.node.getWorldMatrix(_worldMatrix$2);
                Mat4.invert(_mat4_temp$1, _worldMatrix$2);
                Vec2.transformMat4(testPt, cameraPt, _mat4_temp$1);
                var ap = uiTrans.anchorPoint;
                testPt.x += ap.x * w;
                testPt.y += ap.y * h;
                var result = false;

                if (this.type === MaskType.RECT || this.type === MaskType.GRAPHICS_STENCIL) {
                  result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h;
                } else if (this.type === MaskType.ELLIPSE) {
                  var rx = w / 2;
                  var ry = h / 2;
                  var px = testPt.x - 0.5 * w;
                  var py = testPt.y - 0.5 * h;
                  result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
                }

                if (this._inverted) {
                  result = !result;
                }

                return result;
              };

              _proto._render = function _render(render) {
                render.commitComp(this, null, this._assembler, null);
              };

              _proto._postRender = function _postRender(render) {
                if (!this._postAssembler) {
                  return;
                }

                render.commitComp(this, null, this._postAssembler, null);
              };

              _proto._nodeStateChange = function _nodeStateChange(type) {
                _Renderable2D.prototype._nodeStateChange.call(this, type);

                this._updateGraphics();
              };

              _proto._canRender = function _canRender() {
                if (!_Renderable2D.prototype._canRender.call(this)) {
                  return false;
                }

                return this._graphics !== null && (this._type !== MaskType.IMAGE_STENCIL || this._spriteFrame !== null);
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Mask.Assembler.getAssembler(this);
                var posAssembler = Mask.PostAssembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (this._postAssembler !== posAssembler) {
                  this._postAssembler = posAssembler;
                }

                this._useRenderData();
              };

              _proto._createGraphics = function _createGraphics() {
                if (!this._graphics) {
                  var graphics = this._graphics = new Graphics();
                  graphics.node = this.node;
                  graphics.node.getWorldMatrix();
                  graphics.lineWidth = 0;
                  var color = Color.WHITE.clone();
                  color.a = 0;
                  graphics.fillColor = color;
                }

                this._updateMaterial();
              };

              _proto._updateGraphics = function _updateGraphics() {
                if (!this._graphics || this._type !== MaskType.RECT && this._type !== MaskType.ELLIPSE) {
                  return;
                }

                var uiTrans = this.node._uiProps.uiTransformComp;
                var graphics = this._graphics;
                graphics.clear();
                var size = uiTrans.contentSize;
                var width = size.width;
                var height = size.height;
                var ap = uiTrans.anchorPoint;
                var x = -width * ap.x;
                var y = -height * ap.y;

                if (this._type === MaskType.RECT) {
                  graphics.rect(x, y, width, height);
                } else if (this._type === MaskType.ELLIPSE) {
                  var center = new Vec3(x + width / 2, y + height / 2, 0);
                  var radius = new Vec3(width / 2, height / 2, 0);

                  var points = _calculateCircle(center, radius, this._segments);

                  for (var i = 0; i < points.length; ++i) {
                    var point = points[i];

                    if (i === 0) {
                      graphics.moveTo(point.x, point.y);
                    } else {
                      graphics.lineTo(point.x, point.y);
                    }
                  }

                  graphics.close();
                }

                graphics.fill();
              };

              _proto._createClearModel = function _createClearModel() {
                if (!this._clearModel) {
                  var mtl = builtinResMgr.get('default-clear-stencil');
                  this._clearStencilMtl = new MaterialInstance({
                    parent: mtl,
                    owner: this,
                    subModelIdx: 0
                  });
                  this._clearModel = director.root.createModel(Model);
                  this._clearModel.node = this._clearModel.transform = this.node;
                  var stride = getAttributeStride(vfmt);
                  var gfxDevice = legacyCC.director.root.device;
                  var vertexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 4 * stride, stride));
                  var vb = new Float32Array([-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0]);
                  vertexBuffer.update(vb);
                  var indexBuffer = gfxDevice.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.DEVICE, 6 * Uint16Array.BYTES_PER_ELEMENT, Uint16Array.BYTES_PER_ELEMENT));
                  var ib = new Uint16Array([0, 1, 2, 2, 1, 3]);
                  indexBuffer.update(ib);
                  var renderMesh = new RenderingSubMesh([vertexBuffer], vfmt, PrimitiveMode.TRIANGLE_LIST, indexBuffer);
                  renderMesh.subMeshIdx = 0;

                  this._clearModel.initSubModel(0, renderMesh, this._clearStencilMtl);
                }
              };

              _proto._updateMaterial = function _updateMaterial() {
                if (this._graphics) {
                  var target = this._graphics;
                  target.stencilStage = Stage.DISABLED;
                  var mat;

                  if (this._type === MaskType.IMAGE_STENCIL) {
                    mat = builtinResMgr.get('ui-alpha-test-material');
                    target.setMaterial(mat, 0);
                    mat = target.getMaterialInstance(0);
                    mat.setProperty('alphaThreshold', this._alphaThreshold);
                  } else {
                    mat = builtinResMgr.get('ui-graphics-material');
                    target.setMaterial(mat, 0);
                    target.getMaterialInstance(0);
                  }
                }
              };

              _proto._disableGraphics = function _disableGraphics() {
                if (this._graphics) {
                  this._graphics.onDisable();
                }
              };

              _proto._removeGraphics = function _removeGraphics() {
                if (this._graphics) {
                  this._graphics.destroy();

                  this._graphics._destroyImmediate();

                  this._graphics = null;
                }
              };

              _proto._useRenderData = function _useRenderData() {
                if (this._type === MaskType.IMAGE_STENCIL && !this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this.markForUpdateRenderData();
                  }
                }
              };

              _proto._broadcastToNode = function _broadcastToNode(node) {
                var children = node.children;
                node.eventProcessor.registerComponentHitList(Mask);

                for (var i = 0, len = children.length; i < len; i++) {
                  this._broadcastToNode(children[i]);
                }
              };

              return Mask;
            }(Renderable2D), _class3$4.Type = MaskType, _temp$i), (_applyDecoratedDescriptor(_class2$h.prototype, "type", [_dec5$c, _dec6$b, _dec7$b], Object.getOwnPropertyDescriptor(_class2$h.prototype, "type"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "inverted", [_dec8$a, _dec9$a], Object.getOwnPropertyDescriptor(_class2$h.prototype, "inverted"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "segments", [_dec10$8], Object.getOwnPropertyDescriptor(_class2$h.prototype, "segments"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "spriteFrame", [_dec11$7, _dec12$6], Object.getOwnPropertyDescriptor(_class2$h.prototype, "spriteFrame"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "alphaThreshold", [_dec13$6, _dec14$4, slide], Object.getOwnPropertyDescriptor(_class2$h.prototype, "alphaThreshold"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "dstBlendFactor", [override, _dec15$3], Object.getOwnPropertyDescriptor(_class2$h.prototype, "dstBlendFactor"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "srcBlendFactor", [override, _dec16$3], Object.getOwnPropertyDescriptor(_class2$h.prototype, "srcBlendFactor"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "color", [override, _dec17$2], Object.getOwnPropertyDescriptor(_class2$h.prototype, "color"), _class2$h.prototype), _applyDecoratedDescriptor(_class2$h.prototype, "customMaterial", [override, _dec18$1], Object.getOwnPropertyDescriptor(_class2$h.prototype, "customMaterial"), _class2$h.prototype), _descriptor$h = _applyDecoratedDescriptor(_class2$h.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return MaskType.RECT;
              }
            }), _descriptor2$e = _applyDecoratedDescriptor(_class2$h.prototype, "_inverted", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$h.prototype, "_segments", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 64;
              }
            }), _descriptor4$a = _applyDecoratedDescriptor(_class2$h.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class2$h.prototype, "_alphaThreshold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            })), _class2$h)) || _class$k) || _class$k) || _class$k) || _class$k));
            legacyCC.Mask = Mask;

            var eventRegx = /^(click)(\s)*=|(param)(\s)*=/;
            var imageAttrReg = /(\s)*src(\s)*=|(\s)*height(\s)*=|(\s)*width(\s)*=|(\s)*align(\s)*=|(\s)*offset(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
            var HtmlTextParser = exports('HtmlTextParser', function () {
              function HtmlTextParser() {
                this._specialSymbolArray = [];
                this._stack = [];
                this._resultObjectArray = [];

                this._specialSymbolArray.push([/&lt;/g, '<']);

                this._specialSymbolArray.push([/&gt;/g, '>']);

                this._specialSymbolArray.push([/&amp;/g, '&']);

                this._specialSymbolArray.push([/&quot;/g, '"']);

                this._specialSymbolArray.push([/&apos;/g, '\'']);
              }

              var _proto = HtmlTextParser.prototype;

              _proto.parse = function parse(htmlString) {
                this._resultObjectArray.length = 0;
                this._stack.length = 0;
                var startIndex = 0;
                var length = htmlString.length;

                while (startIndex < length) {
                  var tagEndIndex = htmlString.indexOf('>', startIndex);
                  var tagBeginIndex = -1;

                  if (tagEndIndex >= 0) {
                    tagBeginIndex = htmlString.lastIndexOf('<', tagEndIndex);
                    var noTagBegin = tagBeginIndex < startIndex - 1;

                    if (noTagBegin) {
                      tagBeginIndex = htmlString.indexOf('<', tagEndIndex + 1);
                      tagEndIndex = htmlString.indexOf('>', tagBeginIndex + 1);
                    }
                  }

                  if (tagBeginIndex < 0) {
                    this._stack.pop();

                    this._processResult(htmlString.substring(startIndex));

                    startIndex = length;
                  } else {
                    var newStr = htmlString.substring(startIndex, tagBeginIndex);
                    var tagStr = htmlString.substring(tagBeginIndex + 1, tagEndIndex);
                    if (tagStr === '') newStr = htmlString.substring(startIndex, tagEndIndex + 1);

                    this._processResult(newStr);

                    if (tagEndIndex === -1) {
                      tagEndIndex = tagBeginIndex;
                    } else if (htmlString.charAt(tagBeginIndex + 1) === '/') {
                      this._stack.pop();
                    } else {
                      this._addToStack(tagStr);
                    }

                    startIndex = tagEndIndex + 1;
                  }
                }

                return this._resultObjectArray;
              };

              _proto._attributeToObject = function _attributeToObject(attribute) {
                attribute = attribute.trim();
                var obj = {};
                var header = /^(color|size)(\s)*=/.exec(attribute);
                var tagName = '';
                var nextSpace = 0;
                var eventHanlderString = '';

                if (header) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  if (attribute === '') {
                    return obj;
                  }

                  nextSpace = attribute.indexOf(' ');

                  switch (tagName[0]) {
                    case 'c':
                      if (nextSpace > -1) {
                        obj.color = attribute.substring(0, nextSpace).trim();
                      } else {
                        obj.color = attribute;
                      }

                      break;

                    case 's':
                      obj.size = parseInt(attribute);
                      break;
                  }

                  if (nextSpace > -1) {
                    eventHanlderString = attribute.substring(nextSpace + 1).trim();
                    obj.event = this._processEventHandler(eventHanlderString);
                  }

                  return obj;
                }

                header = /^(br(\s)*\/)/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('br') && tagName[tagName.length - 1] === '/') {
                    obj.isNewLine = true;

                    this._resultObjectArray.push({
                      text: '',
                      style: {
                        isNewLine: true
                      }
                    });

                    return obj;
                  }
                }

                header = /^(img(\s)*src(\s)*=[^>]+\/)/.exec(attribute);
                var remainingArgument = '';

                if (header && header[0].length > 0) {
                  tagName = header[0].trim();

                  if (tagName.startsWith('img') && tagName[tagName.length - 1] === '/') {
                    header = imageAttrReg.exec(attribute);
                    var tagValue;
                    var isValidImageTag = false;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      remainingArgument = attribute.substring(tagName.length).trim();
                      nextSpace = remainingArgument.indexOf(' ');
                      tagValue = nextSpace > -1 ? remainingArgument.substr(0, nextSpace) : remainingArgument;
                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      attribute = remainingArgument.substring(nextSpace).trim();
                      if (tagValue.endsWith('/')) tagValue = tagValue.slice(0, -1);

                      if (tagName === 'src') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            isValidImageTag = true;
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.isImage = true;
                        obj.src = tagValue;
                      } else if (tagName === 'height') {
                        obj.imageHeight = parseInt(tagValue);
                      } else if (tagName === 'width') {
                        obj.imageWidth = parseInt(tagValue);
                      } else if (tagName === 'align') {
                        switch (tagValue.charCodeAt(0)) {
                          case 34:
                          case 39:
                            tagValue = tagValue.slice(1, -1);
                            break;
                        }

                        obj.imageAlign = tagValue.toLowerCase();
                      } else if (tagName === 'offset') {
                        obj.imageOffset = tagValue;
                      } else if (tagName === 'click') {
                        obj.event = this._processEventHandler(tagName + "=" + tagValue);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = tagValue.replace(/^"|"$/g, '');
                      }

                      header = imageAttrReg.exec(attribute);
                    }

                    if (isValidImageTag && obj.isImage) {
                      this._resultObjectArray.push({
                        text: '',
                        style: obj
                      });
                    }

                    return {};
                  }
                }

                header = /^(outline(\s)*[^>]*)/.exec(attribute);

                if (header) {
                  attribute = header[0].substring('outline'.length).trim();
                  var defaultOutlineObject = {
                    color: '#ffffff',
                    width: 1
                  };

                  if (attribute) {
                    var outlineAttrReg = /(\s)*color(\s)*=|(\s)*width(\s)*=|(\s)*click(\s)*=|(\s)*param(\s)*=/;
                    header = outlineAttrReg.exec(attribute);

                    var _tagValue;

                    while (header) {
                      attribute = attribute.substring(attribute.indexOf(header[0]));
                      tagName = attribute.substr(0, header[0].length);
                      remainingArgument = attribute.substring(tagName.length).trim();
                      nextSpace = remainingArgument.indexOf(' ');

                      if (nextSpace > -1) {
                        _tagValue = remainingArgument.substr(0, nextSpace);
                      } else {
                        _tagValue = remainingArgument;
                      }

                      tagName = tagName.replace(/[^a-zA-Z]/g, '').trim();
                      tagName = tagName.toLowerCase();
                      attribute = remainingArgument.substring(nextSpace).trim();

                      if (tagName === 'click') {
                        obj.event = this._processEventHandler(tagName + "=" + _tagValue);
                      } else if (tagName === 'color') {
                        defaultOutlineObject.color = _tagValue;
                      } else if (tagName === 'width') {
                        defaultOutlineObject.width = parseInt(_tagValue);
                      }

                      if (obj.event && tagName === 'param') {
                        obj.event[tagName] = _tagValue.replace(/^"|"$/g, '');
                      }

                      header = outlineAttrReg.exec(attribute);
                    }
                  }

                  obj.outline = defaultOutlineObject;
                }

                header = /^(on|u|b|i)(\s)*/.exec(attribute);

                if (header && header[0].length > 0) {
                  tagName = header[0];
                  attribute = attribute.substring(tagName.length).trim();

                  switch (tagName[0]) {
                    case 'u':
                      obj.underline = true;
                      break;

                    case 'i':
                      obj.italic = true;
                      break;

                    case 'b':
                      obj.bold = true;
                      break;
                  }

                  if (attribute === '') {
                    return obj;
                  }

                  obj.event = this._processEventHandler(attribute);
                }

                return obj;
              };

              _proto._processEventHandler = function _processEventHandler(eventString) {
                var obj = {};
                var index = 0;
                var isValidTag = false;
                var eventNames = eventRegx.exec(eventString);

                while (eventNames) {
                  var eventName = eventNames[0];
                  var eventValue = '';
                  isValidTag = false;
                  eventString = eventString.substring(eventName.length).trim();

                  if (eventString.charAt(0) === '"') {
                    index = eventString.indexOf('"', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else if (eventString.charAt(0) === '\'') {
                    index = eventString.indexOf('\'', 1);

                    if (index > -1) {
                      eventValue = eventString.substring(1, index).trim();
                      isValidTag = true;
                    }

                    index++;
                  } else {
                    var match = /(\S)+/.exec(eventString);

                    if (match) {
                      eventValue = match[0];
                    } else {
                      eventValue = '';
                    }

                    index = eventValue.length;
                  }

                  if (isValidTag) {
                    eventName = eventName.substring(0, eventName.length - 1).trim();
                    obj[eventName] = eventValue;
                  }

                  eventString = eventString.substring(index).trim();
                  eventNames = eventRegx.exec(eventString);
                }

                return obj;
              };

              _proto._addToStack = function _addToStack(attribute) {
                var obj = this._attributeToObject(attribute);

                if (this._stack.length === 0) {
                  this._stack.push(obj);
                } else {
                  if (obj.isNewLine || obj.isImage) {
                    return;
                  }

                  var previousTagObj = this._stack[this._stack.length - 1];

                  for (var key in previousTagObj) {
                    if (!obj[key]) {
                      obj[key] = previousTagObj[key];
                    }
                  }

                  this._stack.push(obj);
                }
              };

              _proto._processResult = function _processResult(value) {
                if (value.length === 0) {
                  return;
                }

                value = this._escapeSpecialSymbol(value);

                if (this._stack.length > 0) {
                  this._resultObjectArray.push({
                    text: value,
                    style: this._stack[this._stack.length - 1]
                  });
                } else {
                  this._resultObjectArray.push({
                    text: value
                  });
                }
              };

              _proto._escapeSpecialSymbol = function _escapeSpecialSymbol(str) {
                for (var _iterator = _createForOfIteratorHelperLoose(this._specialSymbolArray), _step; !(_step = _iterator()).done;) {
                  var symbolArr = _step.value;
                  var key = symbolArr[0];
                  var value = symbolArr[1];
                  str = str.replace(key, value);
                }

                return str;
              };

              return HtmlTextParser;
            }());

            var _dec$l, _dec2$f, _dec3$e, _dec4$d, _dec5$d, _dec6$c, _dec7$c, _class$l, _class2$i, _descriptor$i, _descriptor2$f, _temp$j;
            var LabelOutline = function (v) { return exports({ LabelOutline: v, LabelOutlineComponent: v }), v; }((_dec$l = ccclass('cc.LabelOutline'), _dec2$f = help(), _dec3$e = executionOrder(110), _dec4$d = menu(), _dec5$d = requireComponent(Label), _dec6$c = tooltip(), _dec7$c = tooltip(), _dec$l(_class$l = _dec2$f(_class$l = _dec3$e(_class$l = _dec4$d(_class$l = _dec5$d(_class$l = executeInEditMode(_class$l = (_class2$i = (_temp$j = function (_Component) {
              _inheritsLoose(LabelOutline, _Component);

              function LabelOutline() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_color", _descriptor$i, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_width", _descriptor2$f, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = LabelOutline.prototype;

              _proto.onEnable = function onEnable() {
                this._updateRenderData();
              };

              _proto.onDisable = function onDisable() {
                this._updateRenderData();
              };

              _proto._updateRenderData = function _updateRenderData() {
                var label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              };

              _createClass(LabelOutline, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateRenderData();
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                },
                set: function set(value) {
                  if (this._width === value) {
                    return;
                  }

                  this._width = value;

                  this._updateRenderData();
                }
              }]);

              return LabelOutline;
            }(Component), _temp$j), (_descriptor$i = _applyDecoratedDescriptor(_class2$i.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(0, 0, 0, 255);
              }
            }), _descriptor2$f = _applyDecoratedDescriptor(_class2$i.prototype, "_width", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 2;
              }
            }), _applyDecoratedDescriptor(_class2$i.prototype, "color", [_dec6$c], Object.getOwnPropertyDescriptor(_class2$i.prototype, "color"), _class2$i.prototype), _applyDecoratedDescriptor(_class2$i.prototype, "width", [_dec7$c], Object.getOwnPropertyDescriptor(_class2$i.prototype, "width"), _class2$i.prototype)), _class2$i)) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l) || _class$l));

            var _dec$m, _dec2$g, _dec3$f, _dec4$e, _dec5$e, _dec6$d, _dec7$d, _dec8$b, _dec9$b, _dec10$9, _dec11$8, _dec12$7, _dec13$7, _dec14$5, _dec15$4, _dec16$4, _dec17$3, _dec18$2, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _class$m, _class2$j, _descriptor$j, _descriptor2$g, _descriptor3$e, _descriptor4$b, _descriptor5$8, _descriptor6$5, _descriptor7$4, _descriptor8$4, _descriptor9$3, _descriptor10$2, _class3$5, _temp$k;
            var SpriteType;

            (function (SpriteType) {
              SpriteType[SpriteType["SIMPLE"] = 0] = "SIMPLE";
              SpriteType[SpriteType["SLICED"] = 1] = "SLICED";
              SpriteType[SpriteType["TILED"] = 2] = "TILED";
              SpriteType[SpriteType["FILLED"] = 3] = "FILLED";
            })(SpriteType || (SpriteType = {}));

            ccenum(SpriteType);
            var FillType;

            (function (FillType) {
              FillType[FillType["HORIZONTAL"] = 0] = "HORIZONTAL";
              FillType[FillType["VERTICAL"] = 1] = "VERTICAL";
              FillType[FillType["RADIAL"] = 2] = "RADIAL";
            })(FillType || (FillType = {}));

            ccenum(FillType);
            var SizeMode;

            (function (SizeMode) {
              SizeMode[SizeMode["CUSTOM"] = 0] = "CUSTOM";
              SizeMode[SizeMode["TRIMMED"] = 1] = "TRIMMED";
              SizeMode[SizeMode["RAW"] = 2] = "RAW";
            })(SizeMode || (SizeMode = {}));

            ccenum(SizeMode);
            var EventType;

            (function (EventType) {
              EventType["SPRITE_FRAME_CHANGED"] = "spriteframe-changed";
            })(EventType || (EventType = {}));

            var Sprite = function (v) { return exports({ Sprite: v, SpriteComponent: v }), v; }((_dec$m = ccclass('cc.Sprite'), _dec2$g = help(), _dec3$f = executionOrder(110), _dec4$e = menu(), _dec5$e = type(SpriteAtlas), _dec6$d = displayOrder(), _dec7$d = tooltip(), _dec8$b = type(SpriteFrame), _dec9$b = displayOrder(), _dec10$9 = tooltip(), _dec11$8 = type(SpriteType), _dec12$7 = displayOrder(), _dec13$7 = tooltip(), _dec14$5 = type(FillType), _dec15$4 = tooltip(), _dec16$4 = tooltip(), _dec17$3 = range(), _dec18$2 = tooltip(), _dec19$1 = range(), _dec20$1 = tooltip(), _dec21$1 = displayOrder(), _dec22$1 = tooltip(), _dec23$1 = type(SizeMode), _dec24$1 = displayOrder(), _dec25$1 = tooltip(), _dec$m(_class$m = _dec2$g(_class$m = _dec3$f(_class$m = _dec4$e(_class$m = (_class2$j = (_temp$k = _class3$5 = function (_Renderable2D) {
              _inheritsLoose(Sprite, _Renderable2D);

              function Sprite() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Renderable2D.call.apply(_Renderable2D, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_spriteFrame", _descriptor$j, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_type", _descriptor2$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fillType", _descriptor3$e, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_sizeMode", _descriptor4$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fillCenter", _descriptor5$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fillStart", _descriptor6$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fillRange", _descriptor7$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isTrimmedMode", _descriptor8$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_useGrayscale", _descriptor9$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_atlas", _descriptor10$2, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = Sprite.prototype;

              _proto.__preload = function __preload() {
                this.changeMaterialForDefine();

                _Renderable2D.prototype.__preload.call(this);

                if (this._spriteFrame) {
                  this._spriteFrame.on('load', this._markForUpdateUvDirty, this);

                  this._markForUpdateUvDirty();
                }
              };

              _proto.onEnable = function onEnable() {
                _Renderable2D.prototype.onEnable.call(this);

                this._activateMaterial();
              };

              _proto.onDestroy = function onDestroy() {
                this.destroyRenderData();

                if (this._spriteFrame) {
                  this._spriteFrame.off('load');
                }

                _Renderable2D.prototype.onDestroy.call(this);
              };

              _proto.changeSpriteFrameFromAtlas = function changeSpriteFrameFromAtlas(name) {
                if (!this._atlas) {
                  console.warn('SpriteAtlas is null.');
                  return;
                }

                var sprite = this._atlas.getSpriteFrame(name);

                this.spriteFrame = sprite;
              };

              _proto.changeMaterialForDefine = function changeMaterialForDefine() {
                var texture;

                if (this._spriteFrame) {
                  texture = this._spriteFrame.texture;
                }

                var value = false;

                if (texture instanceof TextureBase) {
                  var format = texture.getPixelFormat();
                  value = format === PixelFormat.RGBA_ETC1 || format === PixelFormat.RGB_A_PVRTC_4BPPV1 || format === PixelFormat.RGB_A_PVRTC_2BPPV1;
                }

                if (value && this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED_AND_GRAY;
                } else if (value) {
                  this._instanceMaterialType = InstanceMaterialType.USE_ALPHA_SEPARATED;
                } else if (this.grayscale) {
                  this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
                } else {
                  this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                }

                this.updateMaterial();
              };

              _proto._render = function _render(render) {
                render.commitComp(this, this._spriteFrame, this._assembler, null);
              };

              _proto._canRender = function _canRender() {
                if (!_Renderable2D.prototype._canRender.call(this)) {
                  return false;
                }

                var spriteFrame = this._spriteFrame;

                if (!spriteFrame || !spriteFrame.textureLoaded()) {
                  return false;
                }

                return true;
              };

              _proto._flushAssembler = function _flushAssembler() {
                var assembler = Sprite.Assembler.getAssembler(this);

                if (this._assembler !== assembler) {
                  this.destroyRenderData();
                  this._assembler = assembler;
                }

                if (!this._renderData) {
                  if (this._assembler && this._assembler.createData) {
                    this._renderData = this._assembler.createData(this);
                    this._renderData.material = this.getRenderMaterial(0);
                    this.markForUpdateRenderData();

                    this._updateColor();
                  }
                }
              };

              _proto._applySpriteSize = function _applySpriteSize() {
                if (this._spriteFrame) {
                  if (SizeMode.RAW === this._sizeMode) {
                    var size = this._spriteFrame.originalSize;

                    this.node._uiProps.uiTransformComp.setContentSize(size);
                  } else if (SizeMode.TRIMMED === this._sizeMode) {
                    var rect = this._spriteFrame.getRect();

                    this.node._uiProps.uiTransformComp.setContentSize(rect.width, rect.height);
                  }

                  this._activateMaterial();
                }
              };

              _proto._resized = function _resized() {
                {
                  return;
                }
              };

              _proto._activateMaterial = function _activateMaterial() {
                var spriteFrame = this._spriteFrame;
                var material = this.getRenderMaterial(0);

                if (legacyCC.game.renderType !== legacyCC.game.RENDER_TYPE_CANVAS) {
                  if (spriteFrame) {
                    if (material) {
                      this.markForUpdateRenderData();
                    }
                  }

                  if (this._renderData) {
                    this._renderData.material = material;
                  }
                } else {
                  this.markForUpdateRenderData();
                }
              };

              _proto._onTextureLoaded = function _onTextureLoaded() {
                if (!this.isValid) {
                  return;
                }

                this.changeMaterialForDefine();

                this._applySpriteSize();
              };

              _proto._applySpriteFrame = function _applySpriteFrame(oldFrame) {
                var spriteFrame = this._spriteFrame;

                if (this._renderData) {
                  if (oldFrame) {
                    oldFrame.off('load', this._markForUpdateUvDirty);
                  }

                  if (spriteFrame) {
                    spriteFrame.on('load', this._markForUpdateUvDirty, this);
                  }

                  if (!this._renderData.uvDirty) {
                    if (oldFrame && spriteFrame) {
                      this._renderData.uvDirty = oldFrame.uvHash !== spriteFrame.uvHash;
                    } else {
                      this._renderData.uvDirty = true;
                    }
                  }

                  this._renderDataFlag = this._renderData.uvDirty;
                }

                if (spriteFrame) {
                  if (!oldFrame || spriteFrame !== oldFrame) {
                    if (spriteFrame.loaded) {
                      this._onTextureLoaded();
                    } else {
                      spriteFrame.once('load', this._onTextureLoaded, this);
                    }
                  }
                }
              };

              _proto._markForUpdateUvDirty = function _markForUpdateUvDirty() {
                if (this._renderData) {
                  this._renderData.uvDirty = true;
                  this._renderDataFlag = true;
                }
              };

              _createClass(Sprite, [{
                key: "spriteAtlas",
                get: function get() {
                  return this._atlas;
                },
                set: function set(value) {
                  if (this._atlas === value) {
                    return;
                  }

                  this._atlas = value;
                }
              }, {
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  var lastSprite = this._spriteFrame;
                  this._spriteFrame = value;
                  this.markForUpdateRenderData(false);

                  this._applySpriteFrame(lastSprite);
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(value) {
                  if (this._type !== value) {
                    this._type = value;

                    this._flushAssembler();
                  }
                }
              }, {
                key: "fillType",
                get: function get() {
                  return this._fillType;
                },
                set: function set(value) {
                  if (this._fillType !== value) {
                    if (value === FillType.RADIAL || this._fillType === FillType.RADIAL) {
                      this.destroyRenderData();
                      this._renderData = null;
                    } else if (this._renderData) {
                      this.markForUpdateRenderData(true);
                    }
                  }

                  this._fillType = value;

                  this._flushAssembler();
                }
              }, {
                key: "fillCenter",
                get: function get() {
                  return this._fillCenter;
                },
                set: function set(value) {
                  this._fillCenter.x = value.x;
                  this._fillCenter.y = value.y;

                  if (this._type === SpriteType.FILLED && this._renderData) {
                    this.markForUpdateRenderData();
                  }
                }
              }, {
                key: "fillStart",
                get: function get() {
                  return this._fillStart;
                },
                set: function set(value) {
                  this._fillStart = clamp$1(value, -1, 1);

                  if (this._type === SpriteType.FILLED && this._renderData) {
                    this.markForUpdateRenderData();
                    this._renderData.uvDirty = true;
                  }
                }
              }, {
                key: "fillRange",
                get: function get() {
                  return this._fillRange;
                },
                set: function set(value) {
                  this._fillRange = clamp$1(value, -1, 1);

                  if (this._type === SpriteType.FILLED && this._renderData) {
                    this.markForUpdateRenderData();
                    this._renderData.uvDirty = true;
                  }
                }
              }, {
                key: "trim",
                get: function get() {
                  return this._isTrimmedMode;
                },
                set: function set(value) {
                  if (this._isTrimmedMode === value) {
                    return;
                  }

                  this._isTrimmedMode = value;

                  if (this._type === SpriteType.SIMPLE && this._renderData) {
                    this.markForUpdateRenderData(true);
                  }
                }
              }, {
                key: "grayscale",
                get: function get() {
                  return this._useGrayscale;
                },
                set: function set(value) {
                  if (this._useGrayscale === value) {
                    return;
                  }

                  this._useGrayscale = value;

                  if (value === true) {
                    this._instanceMaterialType = InstanceMaterialType.GRAYSCALE;
                  } else {
                    this._instanceMaterialType = InstanceMaterialType.ADD_COLOR_AND_TEXTURE;
                  }

                  this.updateMaterial();
                }
              }, {
                key: "sizeMode",
                get: function get() {
                  return this._sizeMode;
                },
                set: function set(value) {
                  if (this._sizeMode === value) {
                    return;
                  }

                  this._sizeMode = value;

                  if (value !== SizeMode.CUSTOM) {
                    this._applySpriteSize();
                  }
                }
              }]);

              return Sprite;
            }(Renderable2D), _class3$5.FillType = FillType, _class3$5.Type = SpriteType, _class3$5.SizeMode = SizeMode, _class3$5.EventType = EventType, _temp$k), (_applyDecoratedDescriptor(_class2$j.prototype, "spriteAtlas", [_dec5$e, _dec6$d, _dec7$d], Object.getOwnPropertyDescriptor(_class2$j.prototype, "spriteAtlas"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "spriteFrame", [_dec8$b, _dec9$b, _dec10$9], Object.getOwnPropertyDescriptor(_class2$j.prototype, "spriteFrame"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "type", [_dec11$8, _dec12$7, _dec13$7], Object.getOwnPropertyDescriptor(_class2$j.prototype, "type"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fillType", [_dec14$5, _dec15$4], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fillType"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fillCenter", [_dec16$4], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fillCenter"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fillStart", [_dec17$3, _dec18$2], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fillStart"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "fillRange", [_dec19$1, _dec20$1], Object.getOwnPropertyDescriptor(_class2$j.prototype, "fillRange"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "trim", [_dec21$1, _dec22$1], Object.getOwnPropertyDescriptor(_class2$j.prototype, "trim"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "grayscale", [editable], Object.getOwnPropertyDescriptor(_class2$j.prototype, "grayscale"), _class2$j.prototype), _applyDecoratedDescriptor(_class2$j.prototype, "sizeMode", [_dec23$1, _dec24$1, _dec25$1], Object.getOwnPropertyDescriptor(_class2$j.prototype, "sizeMode"), _class2$j.prototype), _descriptor$j = _applyDecoratedDescriptor(_class2$j.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$j.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return SpriteType.SIMPLE;
              }
            }), _descriptor3$e = _applyDecoratedDescriptor(_class2$j.prototype, "_fillType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return FillType.HORIZONTAL;
              }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$j.prototype, "_sizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return SizeMode.TRIMMED;
              }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$j.prototype, "_fillCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(0, 0);
              }
            }), _descriptor6$5 = _applyDecoratedDescriptor(_class2$j.prototype, "_fillStart", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor7$4 = _applyDecoratedDescriptor(_class2$j.prototype, "_fillRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor8$4 = _applyDecoratedDescriptor(_class2$j.prototype, "_isTrimmedMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor9$3 = _applyDecoratedDescriptor(_class2$j.prototype, "_useGrayscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class2$j.prototype, "_atlas", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$j)) || _class$m) || _class$m) || _class$m) || _class$m));

            var _dec$n, _dec2$h, _dec3$g, _dec4$f, _class$n;
            var RenderRoot2D = exports('RenderRoot2D', (_dec$n = ccclass('cc.RenderRoot2D'), _dec2$h = executionOrder(100), _dec3$g = menu(), _dec4$f = requireComponent(UITransform), _dec$n(_class$n = _dec2$h(_class$n = _dec3$g(_class$n = _dec4$f(_class$n = disallowMultiple(_class$n = executeInEditMode(_class$n = function (_Component) {
              _inheritsLoose(RenderRoot2D, _Component);

              function RenderRoot2D() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = RenderRoot2D.prototype;

              _proto.onEnable = function onEnable() {
                legacyCC.director.root.batcher2D.addScreen(this);
              };

              _proto.onDisable = function onDisable() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              };

              _proto.onDestroy = function onDestroy() {
                legacyCC.director.root.batcher2D.removeScreen(this);
              };

              return RenderRoot2D;
            }(Component)) || _class$n) || _class$n) || _class$n) || _class$n) || _class$n) || _class$n));

            var _dec$o, _dec2$i, _dec3$h, _dec4$g, _dec5$f, _dec6$e, _dec7$e, _dec8$c, _class$o, _class2$k, _descriptor$k, _descriptor2$h, _temp$l;

            var _worldPos = new Vec3();

            var RenderMode = Enum({
              OVERLAY: 0,
              INTERSPERSE: 1
            });
            var Canvas = function (v) { return exports({ Canvas: v, CanvasComponent: v }), v; }((_dec$o = ccclass('cc.Canvas'), _dec2$i = help(), _dec3$h = executionOrder(100), _dec4$g = menu(), _dec5$f = type(Camera), _dec6$e = tooltip(), _dec7$e = tooltip(), _dec8$c = type(Camera), _dec$o(_class$o = _dec2$i(_class$o = _dec3$h(_class$o = _dec4$g(_class$o = executeInEditMode(_class$o = disallowMultiple(_class$o = (_class2$k = (_temp$l = function (_RenderRoot2D) {
              _inheritsLoose(Canvas, _RenderRoot2D);

              _createClass(Canvas, [{
                key: "renderMode",
                get: function get() {
                  return this._renderMode;
                },
                set: function set(val) {
                  this._renderMode = val;

                  if (this._cameraComponent) {
                    this._cameraComponent.priority = this._getViewPriority();
                  }
                }
              }, {
                key: "cameraComponent",
                get: function get() {
                  return this._cameraComponent;
                },
                set: function set(value) {
                  if (this._cameraComponent === value) {
                    return;
                  }

                  this._cameraComponent = value;

                  this._onResizeCamera();
                }
              }, {
                key: "alignCanvasWithScreen",
                get: function get() {
                  return this._alignCanvasWithScreen;
                },
                set: function set(value) {
                  this._alignCanvasWithScreen = value;

                  this._onResizeCamera();
                }
              }]);

              function Canvas() {
                var _this;

                _this = _RenderRoot2D.call(this) || this;

                _initializerDefineProperty(_this, "_cameraComponent", _descriptor$k, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_alignCanvasWithScreen", _descriptor2$h, _assertThisInitialized(_this));

                _this._thisOnCameraResized = void 0;
                _this._fitDesignResolution = void 0;
                _this._pos = new Vec3();
                _this._renderMode = RenderMode.OVERLAY;
                _this._thisOnCameraResized = _this._onResizeCamera.bind(_assertThisInitialized(_this));

                return _this;
              }

              var _proto = Canvas.prototype;

              _proto.__preload = function __preload() {
                var widget = this.getComponent('cc.Widget');

                if (widget) {
                  widget.updateAlignment();
                }

                {
                  if (this._cameraComponent) {
                    this._cameraComponent._createCamera();
                  }
                }

                this._onResizeCamera();

                this.node.on(SystemEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
              };

              _proto.onDestroy = function onDestroy() {
                _RenderRoot2D.prototype.onDestroy.call(this);

                this.node.off(SystemEventType.TRANSFORM_CHANGED, this._thisOnCameraResized);
              };

              _proto._onResizeCamera = function _onResizeCamera() {
                if (this._cameraComponent && this._alignCanvasWithScreen) {
                  if (this._cameraComponent.targetTexture) {
                    var win = this._cameraComponent.targetTexture.window;

                    if (this._cameraComponent.camera) {
                      this._cameraComponent.camera.setFixedSize(win.width, win.height);
                    }

                    this._cameraComponent.orthoHeight = visibleRect.height / 2;
                  } else if (game.canvas) {
                    var size = game.canvas;

                    if (this._cameraComponent.camera) {
                      this._cameraComponent.camera.resize(size.width, size.height);
                    }

                    this._cameraComponent.orthoHeight = game.canvas.height / view.getScaleY() / 2;
                  }

                  this.node.getWorldPosition(_worldPos);

                  this._cameraComponent.node.setWorldPosition(_worldPos.x, _worldPos.y, 1000);
                }
              };

              _proto._getViewPriority = function _getViewPriority() {
                if (this._cameraComponent) {
                  var _this$cameraComponent;

                  var priority = (_this$cameraComponent = this.cameraComponent) === null || _this$cameraComponent === void 0 ? void 0 : _this$cameraComponent.priority;
                  priority = this._renderMode === RenderMode.OVERLAY ? priority | 1 << 30 : priority & ~(1 << 30);
                  return priority;
                }

                return 0;
              };

              return Canvas;
            }(RenderRoot2D), _temp$l), (_applyDecoratedDescriptor(_class2$k.prototype, "cameraComponent", [_dec5$f, _dec6$e], Object.getOwnPropertyDescriptor(_class2$k.prototype, "cameraComponent"), _class2$k.prototype), _applyDecoratedDescriptor(_class2$k.prototype, "alignCanvasWithScreen", [_dec7$e], Object.getOwnPropertyDescriptor(_class2$k.prototype, "alignCanvasWithScreen"), _class2$k.prototype), _descriptor$k = _applyDecoratedDescriptor(_class2$k.prototype, "_cameraComponent", [_dec8$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$k.prototype, "_alignCanvasWithScreen", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            })), _class2$k)) || _class$o) || _class$o) || _class$o) || _class$o) || _class$o) || _class$o));
            legacyCC.Canvas = Canvas;

            var _dec$p, _dec2$j, _dec3$i, _class$p, _temp$m;
            var UIComponent = exports('UIComponent', (_dec$p = ccclass('cc.UIComponent'), _dec2$j = requireComponent(UITransform), _dec3$i = executionOrder(110), _dec$p(_class$p = _dec2$j(_class$p = _dec3$i(_class$p = disallowMultiple(_class$p = executeInEditMode(_class$p = (_temp$m = function (_Component) {
              _inheritsLoose(UIComponent, _Component);

              function UIComponent() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastParent = null;
                _this.stencilStage = Stage.DISABLED;
                return _this;
              }

              var _proto = UIComponent.prototype;

              _proto.__preload = function __preload() {
                this.node._uiProps.uiComp = this;
              };

              _proto.onEnable = function onEnable() {};

              _proto.onDisable = function onDisable() {};

              _proto.onDestroy = function onDestroy() {
                if (this.node._uiProps.uiComp === this) {
                  this.node._uiProps.uiComp = null;
                }
              };

              _proto.updateAssembler = function updateAssembler(render) {};

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {};

              return UIComponent;
            }(Component), _temp$m)) || _class$p) || _class$p) || _class$p) || _class$p) || _class$p));

            removeProperty(UIComponent.prototype, 'UIComponent', [{
              name: '_visibility'
            }, {
              name: 'setVisibility'
            }]);
            replaceProperty(Canvas.prototype, 'Canvas.prototype', [{
              name: 'camera',
              newName: 'cameraComponent.camera',
              customGetter: function customGetter() {
                return this._cameraComponent.camera;
              }
            }, {
              name: 'clearFlag',
              newName: 'cameraComponent.clearFlags',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearFlags : 0;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearFlags = val;
              }
            }, {
              name: 'color',
              newName: 'cameraComponent.clearColor',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.clearColor : Color.BLACK;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.clearColor = val;
              }
            }, {
              name: 'priority',
              newName: 'cameraComponent.priority',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.priority : 0;
              },
              customSetter: function customSetter(val) {
                if (this._cameraComponent) this._cameraComponent.priority = val;
              }
            }, {
              name: 'targetTexture',
              newName: 'cameraComponent.targetTexture',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.targetTexture : null;
              },
              customSetter: function customSetter(value) {
                if (this._cameraComponent) this._cameraComponent.targetTexture = value;
              }
            }, {
              name: 'visibility',
              newName: 'cameraComponent.visibility',
              customGetter: function customGetter() {
                return this._cameraComponent ? this._cameraComponent.visibility : 0;
              }
            }]);
            legacyCC.UITransformComponent = UITransform;
            js.setClassAlias(UITransform, 'cc.UITransformComponent');
            js.setClassAlias(Renderable2D, 'cc.RenderComponent');
            legacyCC.CanvasComponent = Canvas;
            js.setClassAlias(Canvas, 'cc.CanvasComponent');

            var _dec$q, _dec2$k, _dec3$j, _dec4$h, _dec5$g, _dec6$f, _dec7$f, _dec8$d, _dec9$c, _dec10$a, _dec11$9, _dec12$8, _dec13$8, _dec14$6, _dec15$5, _dec16$5, _dec17$4, _dec18$3, _dec19$2, _class$q, _class2$l, _descriptor$l, _descriptor2$i, _descriptor3$f, _descriptor4$c, _descriptor5$9, _descriptor6$6, _descriptor7$5, _descriptor8$5, _descriptor9$4, _descriptor10$3, _descriptor11$2, _descriptor12$1, _class3$6, _temp$n;

            var _htmlTextParser = new HtmlTextParser();

            var RichTextChildName = 'RICHTEXT_CHILD';
            var RichTextChildImageName = 'RICHTEXT_Image_CHILD';
            var labelPool = new Pool$1(function (seg) {

              if (!legacyCC.isValid(seg.node)) {
                return false;
              } else {
                var outline = seg.node.getComponent(LabelOutline);

                if (outline) {
                  outline.width = 0;
                }
              }

              return true;
            }, 20);
            var imagePool = new Pool$1(function (seg) {

              return legacyCC.isValid(seg.node);
            }, 10);

            function createSegment(type) {
              return {
                node: new PrivateNode(type),
                comp: null,
                lineCount: 0,
                styleIndex: 0,
                imageOffset: '',
                clickParam: '',
                clickHandler: '',
                type: type
              };
            }

            function getSegmentByPool(type, content) {
              var seg;

              if (type === RichTextChildName) {
                seg = labelPool._get();
              } else if (type === RichTextChildImageName) {
                seg = imagePool._get();
              }

              seg = seg || createSegment(type);
              var node = seg.node;

              if (!node) {
                node = new PrivateNode(type);
              }

              if (type === RichTextChildImageName) {
                seg.comp = node.getComponent(Sprite) || node.addComponent(Sprite);
                seg.comp.spriteFrame = content;
                seg.comp.type = Sprite.Type.SLICED;
                seg.comp.sizeMode = Sprite.SizeMode.CUSTOM;
              } else {
                seg.comp = node.getComponent(Label) || node.addComponent(Label);
                seg.comp.string = content;
                seg.comp.horizontalAlign = HorizontalTextAlignment.LEFT;
                seg.comp.verticalAlign = VerticalTextAlignment.TOP;
              }

              node.setPosition(0, 0, 0);
              var trans = node._uiProps.uiTransformComp;
              trans.setAnchorPoint(0.5, 0.5);
              seg.node = node;
              seg.lineCount = 0;
              seg.styleIndex = 0;
              seg.imageOffset = '';
              seg.clickParam = '';
              seg.clickHandler = '';
              return seg;
            }

            var RichText = function (v) { return exports({ RichText: v, RichTextComponent: v }), v; }((_dec$q = ccclass('cc.RichText'), _dec2$k = help(), _dec3$j = executionOrder(110), _dec4$h = menu(), _dec5$g = tooltip(), _dec6$f = type(HorizontalTextAlignment), _dec7$f = tooltip(), _dec8$d = tooltip(), _dec9$c = tooltip(), _dec10$a = type(Font), _dec11$9 = tooltip(), _dec12$8 = tooltip(), _dec13$8 = type(CacheMode), _dec14$6 = tooltip(), _dec15$5 = tooltip(), _dec16$5 = tooltip(), _dec17$4 = type(SpriteAtlas), _dec18$3 = tooltip(), _dec19$2 = tooltip(), _dec$q(_class$q = _dec2$k(_class$q = _dec3$j(_class$q = _dec4$h(_class$q = executeInEditMode(_class$q = (_class2$l = (_temp$n = _class3$6 = function (_UIComponent) {
              _inheritsLoose(RichText, _UIComponent);

              _createClass(RichText, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  if (this._string === value) {
                    return;
                  }

                  this._string = value;

                  this._updateRichTextStatus();
                }
              }, {
                key: "horizontalAlign",
                get: function get() {
                  return this._horizontalAlign;
                },
                set: function set(value) {
                  if (this.horizontalAlign === value) {
                    return;
                  }

                  this._horizontalAlign = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "fontSize",
                get: function get() {
                  return this._fontSize;
                },
                set: function set(value) {
                  if (this._fontSize === value) {
                    return;
                  }

                  this._fontSize = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "fontFamily",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  if (this._fontFamily === value) return;
                  this._fontFamily = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "font",
                get: function get() {
                  return this._font;
                },
                set: function set(value) {
                  if (this._font === value) {
                    return;
                  }

                  this._font = value;
                  this._layoutDirty = true;

                  if (this._font) {

                    this.useSystemFont = false;

                    this._onTTFLoaded();
                  } else {
                    this.useSystemFont = true;
                  }

                  this._updateRichTextStatus();
                }
              }, {
                key: "useSystemFont",
                get: function get() {
                  return this._isSystemFontUsed;
                },
                set: function set(value) {
                  if (this._isSystemFontUsed === value) {
                    return;
                  }

                  this._isSystemFontUsed = value;

                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "cacheMode",
                get: function get() {
                  return this._cacheMode;
                },
                set: function set(value) {
                  if (this._cacheMode === value) {
                    return;
                  }

                  this._cacheMode = value;

                  this._updateRichTextStatus();
                }
              }, {
                key: "maxWidth",
                get: function get() {
                  return this._maxWidth;
                },
                set: function set(value) {
                  if (this._maxWidth === value) {
                    return;
                  }

                  this._maxWidth = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "lineHeight",
                get: function get() {
                  return this._lineHeight;
                },
                set: function set(value) {
                  if (this._lineHeight === value) {
                    return;
                  }

                  this._lineHeight = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "imageAtlas",
                get: function get() {
                  return this._imageAtlas;
                },
                set: function set(value) {
                  if (this._imageAtlas === value) {
                    return;
                  }

                  this._imageAtlas = value;
                  this._layoutDirty = true;

                  this._updateRichTextStatus();
                }
              }, {
                key: "handleTouchEvent",
                get: function get() {
                  return this._handleTouchEvent;
                },
                set: function set(value) {
                  if (this._handleTouchEvent === value) {
                    return;
                  }

                  this._handleTouchEvent = value;

                  if (this.enabledInHierarchy) {
                    if (this.handleTouchEvent) {
                      this._addEventListeners();
                    } else {
                      this._removeEventListeners();
                    }
                  }
                }
              }]);

              function RichText() {
                var _this;

                _this = _UIComponent.call(this) || this;

                _initializerDefineProperty(_this, "_lineHeight", _descriptor$l, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_string", _descriptor2$i, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_horizontalAlign", _descriptor3$f, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fontSize", _descriptor4$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_maxWidth", _descriptor5$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_fontFamily", _descriptor6$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_font", _descriptor7$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isSystemFontUsed", _descriptor8$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_userDefinedFont", _descriptor9$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_cacheMode", _descriptor10$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_imageAtlas", _descriptor11$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_handleTouchEvent", _descriptor12$1, _assertThisInitialized(_this));

                _this._textArray = [];
                _this._segments = [];
                _this._labelSegmentsCache = [];
                _this._linesWidth = [];
                _this._lineCount = 1;
                _this._labelWidth = 0;
                _this._labelHeight = 0;
                _this._layoutDirty = true;
                _this._lineOffsetX = 0;
                _this._updateRichTextStatus = void 0;

                _this._updateRichTextStatus = _this._updateRichText;
                return _this;
              }

              var _proto = RichText.prototype;

              _proto.onLoad = function onLoad() {
                this.node.on(SystemEventType.LAYER_CHANGED, this._applyLayer, this);
              };

              _proto.onEnable = function onEnable() {
                if (this.handleTouchEvent) {
                  this._addEventListeners();
                }

                this._updateRichText();

                this._activateChildren(true);
              };

              _proto.onDisable = function onDisable() {
                if (this.handleTouchEvent) {
                  this._removeEventListeners();
                }

                this._activateChildren(false);
              };

              _proto.start = function start() {
                this._onTTFLoaded();

                this.node.on(Node.EventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
              };

              _proto.onRestore = function onRestore() {
                {
                  return;
                }
              };

              _proto.onDestroy = function onDestroy() {
                for (var _iterator = _createForOfIteratorHelperLoose(this._segments), _step; !(_step = _iterator()).done;) {
                  var seg = _step.value;
                  seg.node.removeFromParent();

                  if (seg.type === RichTextChildName) {
                    labelPool.put(seg);
                  } else if (seg.type === RichTextChildImageName) {
                    imagePool.put(seg);
                  }
                }

                this.node.off(Node.EventType.ANCHOR_CHANGED, this._updateRichTextPosition, this);
                this.node.off(SystemEventType.LAYER_CHANGED, this._applyLayer, this);
              };

              _proto._addEventListeners = function _addEventListeners() {
                this.node.on(Node.EventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                this.node.off(Node.EventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._updateLabelSegmentTextAttributes = function _updateLabelSegmentTextAttributes() {
                var _this2 = this;

                this._segments.forEach(function (item) {
                  _this2._applyTextAttribute(item);
                });
              };

              _proto._createFontLabel = function _createFontLabel(str) {
                return getSegmentByPool(RichTextChildName, str);
              };

              _proto._createImage = function _createImage(spriteFrame) {
                return getSegmentByPool(RichTextChildImageName, spriteFrame);
              };

              _proto._onTTFLoaded = function _onTTFLoaded() {
                var _this3 = this;

                if (this._font instanceof TTFFont) {
                  if (this._font._nativeAsset) {
                    this._layoutDirty = true;

                    this._updateRichText();
                  } else {
                    assetManager.postLoadNative(this._font, function (err) {
                      if (!_this3.isValid) {
                        return;
                      }

                      _this3._layoutDirty = true;

                      _this3._updateRichText();
                    });
                  }
                } else {
                  this._layoutDirty = true;

                  this._updateRichText();
                }
              };

              _proto._measureText = function _measureText(styleIndex, string) {
                var _this4 = this;

                var func = function func(s) {
                  var label;

                  if (_this4._labelSegmentsCache.length === 0) {
                    label = _this4._createFontLabel(s);

                    _this4._labelSegmentsCache.push(label);
                  } else {
                    label = _this4._labelSegmentsCache[0];
                    label.node.getComponent(Label).string = s;
                  }

                  label.styleIndex = styleIndex;

                  _this4._applyTextAttribute(label);

                  var labelSize = label.node._uiProps.uiTransformComp.contentSize;
                  return labelSize.width;
                };

                if (string) {
                  return func(string);
                } else {
                  return func;
                }
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                var _this5 = this;

                var components = this.node.getComponents(Component);

                var _loop = function _loop() {
                  var seg = _step2.value;
                  var clickHandler = seg.clickHandler;
                  var clickParam = seg.clickParam;

                  if (clickHandler && _this5._containsTouchLocation(seg, event.touch.getUILocation())) {
                    components.forEach(function (component) {
                      var func = component[clickHandler];

                      if (component.enabledInHierarchy && func) {
                        func.call(component, event, clickParam);
                      }
                    });
                    event.propagationStopped = true;
                  }
                };

                for (var _iterator2 = _createForOfIteratorHelperLoose(this._segments), _step2; !(_step2 = _iterator2()).done;) {
                  _loop();
                }
              };

              _proto._containsTouchLocation = function _containsTouchLocation(label, point) {
                var comp = label.node.getComponent(UITransform);

                if (!comp) {
                  return false;
                }

                var myRect = comp.getBoundingBoxToWorld();
                return myRect.contains(point);
              };

              _proto._resetState = function _resetState() {
                var children = this.node.children;

                for (var i = children.length - 1; i >= 0; i--) {
                  var child = children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    if (child.parent === this.node) {
                      child.parent = null;
                    } else {
                      children.splice(i, 1);
                    }

                    var segment = createSegment(child.name);
                    segment.node = child;

                    if (child.name === RichTextChildName) {
                      segment.comp = child.getComponent(Label);
                      labelPool.put(segment);
                    } else {
                      segment.comp = child.getComponent(Sprite);
                      imagePool.put(segment);
                    }
                  }
                }

                children.length = 0;
                this._segments.length = 0;
                this._labelSegmentsCache.length = 0;
                this._linesWidth.length = 0;
                this._lineOffsetX = 0;
                this._lineCount = 1;
                this._labelWidth = 0;
                this._labelHeight = 0;
                this._layoutDirty = true;
              };

              _proto._activateChildren = function _activateChildren(active) {
                for (var i = this.node.children.length - 1; i >= 0; i--) {
                  var child = this.node.children[i];

                  if (child.name === RichTextChildName || child.name === RichTextChildImageName) {
                    child.active = active;
                  }
                }
              };

              _proto._addLabelSegment = function _addLabelSegment(stringToken, styleIndex) {
                var labelSegment;

                if (this._labelSegmentsCache.length === 0) {
                  labelSegment = this._createFontLabel(stringToken);
                } else {
                  labelSegment = this._labelSegmentsCache.pop();
                  var label = labelSegment.node.getComponent(Label);

                  if (label) {
                    label.string = stringToken;
                  }
                }

                labelSegment.styleIndex = styleIndex;
                labelSegment.lineCount = this._lineCount;

                labelSegment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                labelSegment.node.layer = this.node.layer;

                this._applyTextAttribute(labelSegment);

                this.node.addChild(labelSegment.node);

                this._segments.push(labelSegment);

                return labelSegment;
              };

              _proto._updateRichTextWithMaxWidth = function _updateRichTextWithMaxWidth(labelString, labelWidth, styleIndex) {
                var fragmentWidth = labelWidth;
                var labelSegment;

                if (this._lineOffsetX > 0 && fragmentWidth + this._lineOffsetX > this._maxWidth) {
                  var checkStartIndex = 0;

                  while (this._lineOffsetX <= this._maxWidth) {
                    var checkEndIndex = this._getFirstWordLen(labelString, checkStartIndex, labelString.length);

                    var checkString = labelString.substr(checkStartIndex, checkEndIndex);

                    var checkStringWidth = this._measureText(styleIndex, checkString);

                    if (this._lineOffsetX + checkStringWidth <= this._maxWidth) {
                      this._lineOffsetX += checkStringWidth;
                      checkStartIndex += checkEndIndex;
                    } else {
                      if (checkStartIndex > 0) {
                        var remainingString = labelString.substr(0, checkStartIndex);

                        this._addLabelSegment(remainingString, styleIndex);

                        labelString = labelString.substr(checkStartIndex, labelString.length);
                        fragmentWidth = this._measureText(styleIndex, labelString);
                      }

                      this._updateLineInfo();

                      break;
                    }
                  }
                }

                if (fragmentWidth > this._maxWidth) {
                  var fragments = fragmentText(labelString, fragmentWidth, this._maxWidth, this._measureText(styleIndex));

                  for (var k = 0; k < fragments.length; ++k) {
                    var splitString = fragments[k];
                    labelSegment = this._addLabelSegment(splitString, styleIndex);
                    var labelSize = labelSegment.node._uiProps.uiTransformComp.contentSize;
                    this._lineOffsetX += labelSize.width;

                    if (fragments.length > 1 && k < fragments.length - 1) {
                      this._updateLineInfo();
                    }
                  }
                } else {
                  this._lineOffsetX += fragmentWidth;

                  this._addLabelSegment(labelString, styleIndex);
                }
              };

              _proto._isLastComponentCR = function _isLastComponentCR(stringToken) {
                return stringToken.length - 1 === stringToken.lastIndexOf('\n');
              };

              _proto._updateLineInfo = function _updateLineInfo() {
                this._linesWidth.push(this._lineOffsetX);

                this._lineOffsetX = 0;
                this._lineCount++;
              };

              _proto._needsUpdateTextLayout = function _needsUpdateTextLayout(newTextArray) {
                if (this._layoutDirty || !this._textArray || !newTextArray) {
                  return true;
                }

                if (this._textArray.length !== newTextArray.length) {
                  return true;
                }

                for (var i = 0; i < this._textArray.length; i++) {
                  var oldItem = this._textArray[i];
                  var newItem = newTextArray[i];

                  if (oldItem.text !== newItem.text) {
                    return true;
                  } else {
                    var oldStyle = oldItem.style;
                    var newStyle = newItem.style;

                    if (oldStyle) {
                      if (newStyle) {
                        if (!!newStyle.outline !== !!oldStyle.outline) {
                          return true;
                        }

                        if (oldStyle.size !== newStyle.size || oldStyle.italic !== newStyle.italic || oldStyle.isImage !== newStyle.isImage) {
                          return true;
                        }

                        if (oldStyle.src !== newStyle.src || oldStyle.imageAlign !== newStyle.imageAlign || oldStyle.imageHeight !== newStyle.imageHeight || oldStyle.imageWidth !== newStyle.imageWidth || oldStyle.imageOffset !== newStyle.imageOffset) {
                          return true;
                        }
                      } else if (oldStyle.size || oldStyle.italic || oldStyle.isImage || oldStyle.outline) {
                        return true;
                      }
                    } else if (newStyle) {
                      if (newStyle.size || newStyle.italic || newStyle.isImage || newStyle.outline) {
                        return true;
                      }
                    }
                  }
                }

                return false;
              };

              _proto._addRichTextImageElement = function _addRichTextImageElement(richTextElement) {
                if (!richTextElement.style) {
                  return;
                }

                var style = richTextElement.style;
                var spriteFrameName = style.src;

                var spriteFrame = this._imageAtlas && spriteFrameName && this._imageAtlas.getSpriteFrame(spriteFrameName);

                if (!spriteFrame) {
                  warnID(4400);
                } else {
                  var segment = this._createImage(spriteFrame);

                  var sprite = segment.comp;

                  switch (style.imageAlign) {
                    case 'top':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 1);

                      break;

                    case 'center':
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0.5);

                      break;

                    default:
                      segment.node._uiProps.uiTransformComp.setAnchorPoint(0, 0);

                      break;
                  }

                  segment.node.layer = this.node.layer;
                  this.node.addChild(segment.node);

                  this._segments.push(segment);

                  var spriteRect = spriteFrame.rect.clone();
                  var scaleFactor = 1;
                  var spriteWidth = spriteRect.width;
                  var spriteHeight = spriteRect.height;
                  var expectWidth = style.imageWidth || 0;
                  var expectHeight = style.imageHeight || 0;

                  if (expectHeight > 0) {
                    scaleFactor = expectHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  } else {
                    scaleFactor = this._lineHeight / spriteHeight;
                    spriteWidth *= scaleFactor;
                    spriteHeight *= scaleFactor;
                  }

                  if (expectWidth > 0) {
                    spriteWidth = expectWidth;
                  }

                  if (this._maxWidth > 0) {
                    if (this._lineOffsetX + spriteWidth > this._maxWidth) {
                      this._updateLineInfo();
                    }

                    this._lineOffsetX += spriteWidth;
                  } else {
                    this._lineOffsetX += spriteWidth;

                    if (this._lineOffsetX > this._labelWidth) {
                      this._labelWidth = this._lineOffsetX;
                    }
                  }

                  segment.node._uiProps.uiTransformComp.setContentSize(spriteWidth, spriteHeight);

                  segment.lineCount = this._lineCount;
                  segment.clickHandler = '';
                  segment.clickParam = '';
                  var event = style.event;

                  if (event) {
                    segment.clickHandler = event.click;
                    segment.clickParam = event.param;
                  }
                }
              };

              _proto._updateRichText = function _updateRichText() {
                if (!this.enabledInHierarchy) {
                  return;
                }

                var newTextArray = _htmlTextParser.parse(this._string);

                if (!this._needsUpdateTextLayout(newTextArray)) {
                  this._textArray = newTextArray.slice();

                  this._updateLabelSegmentTextAttributes();

                  return;
                }

                this._textArray = newTextArray.slice();

                this._resetState();

                var lastEmptyLine = false;
                var label;

                for (var i = 0; i < this._textArray.length; ++i) {
                  var richTextElement = this._textArray[i];
                  var text = richTextElement.text;

                  if (text === undefined) {
                    continue;
                  }

                  if (text === '') {
                    if (richTextElement.style && richTextElement.style.isNewLine) {
                      this._updateLineInfo();

                      continue;
                    }

                    if (richTextElement.style && richTextElement.style.isImage && this._imageAtlas) {
                      this._addRichTextImageElement(richTextElement);

                      continue;
                    }
                  }

                  var multilineTexts = text.split('\n');

                  for (var j = 0; j < multilineTexts.length; ++j) {
                    var labelString = multilineTexts[j];

                    if (labelString === '') {
                      if (this._isLastComponentCR(text) && j === multilineTexts.length - 1) {
                        continue;
                      }

                      this._updateLineInfo();

                      lastEmptyLine = true;
                      continue;
                    }

                    lastEmptyLine = false;

                    if (this._maxWidth > 0) {
                      var labelWidth = this._measureText(i, labelString);

                      this._updateRichTextWithMaxWidth(labelString, labelWidth, i);

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    } else {
                      label = this._addLabelSegment(labelString, i);
                      this._lineOffsetX += label.node._uiProps.uiTransformComp.width;

                      if (this._lineOffsetX > this._labelWidth) {
                        this._labelWidth = this._lineOffsetX;
                      }

                      if (multilineTexts.length > 1 && j < multilineTexts.length - 1) {
                        this._updateLineInfo();
                      }
                    }
                  }
                }

                if (!lastEmptyLine) {
                  this._linesWidth.push(this._lineOffsetX);
                }

                if (this._maxWidth > 0) {
                  this._labelWidth = this._maxWidth;
                }

                this._labelHeight = (this._lineCount + BASELINE_RATIO) * this._lineHeight;

                this.node._uiProps.uiTransformComp.setContentSize(this._labelWidth, this._labelHeight);

                this._updateRichTextPosition();

                this._layoutDirty = false;
              };

              _proto._getFirstWordLen = function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || isUnicodeSpace(character)) {
                  return 1;
                }

                var len = 1;

                for (var index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);

                  if (isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              };

              _proto._updateRichTextPosition = function _updateRichTextPosition() {
                var nextTokenX = 0;
                var nextLineIndex = 1;
                var totalLineCount = this._lineCount;
                var trans = this.node._uiProps.uiTransformComp;
                var anchorX = trans.anchorX;
                var anchorY = trans.anchorY;

                for (var i = 0; i < this._segments.length; ++i) {
                  var segment = this._segments[i];
                  var lineCount = segment.lineCount;

                  if (lineCount > nextLineIndex) {
                    nextTokenX = 0;
                    nextLineIndex = lineCount;
                  }

                  var lineOffsetX = this._labelWidth * (this._horizontalAlign * 0.5 - anchorX);

                  switch (this._horizontalAlign) {
                    case HorizontalTextAlignment.LEFT:
                      break;

                    case HorizontalTextAlignment.CENTER:
                      lineOffsetX -= this._linesWidth[lineCount - 1] / 2;
                      break;

                    case HorizontalTextAlignment.RIGHT:
                      lineOffsetX -= this._linesWidth[lineCount - 1];
                      break;
                  }

                  var pos = segment.node.position;
                  segment.node.setPosition(nextTokenX + lineOffsetX, this._lineHeight * (totalLineCount - lineCount) - this._labelHeight * anchorY, pos.z);

                  if (lineCount === nextLineIndex) {
                    nextTokenX += segment.node._uiProps.uiTransformComp.width;
                  }

                  var sprite = segment.node.getComponent(Sprite);

                  if (sprite) {
                    var position = segment.node.position.clone();
                    var lineHeightSet = this._lineHeight;
                    var lineHeightReal = this._lineHeight * (1 + BASELINE_RATIO);

                    switch (segment.node._uiProps.uiTransformComp.anchorY) {
                      case 1:
                        position.y += lineHeightSet + (lineHeightReal - lineHeightSet) / 2;
                        break;

                      case 0.5:
                        position.y += lineHeightReal / 2;
                        break;

                      default:
                        position.y += (lineHeightReal - lineHeightSet) / 2;
                        break;
                    }

                    if (segment.imageOffset) {
                      var offsets = segment.imageOffset.split(',');

                      if (offsets.length === 1 && offsets[0]) {
                        var offsetY = parseFloat(offsets[0]);
                        if (Number.isInteger(offsetY)) position.y += offsetY;
                      } else if (offsets.length === 2) {
                        var offsetX = parseFloat(offsets[0]);

                        var _offsetY = parseFloat(offsets[1]);

                        if (Number.isInteger(offsetX)) position.x += offsetX;
                        if (Number.isInteger(_offsetY)) position.y += _offsetY;
                      }
                    }

                    segment.node.position = position;
                  }

                  var outline = segment.node.getComponent(LabelOutline);

                  if (outline) {
                    var _position = segment.node.position.clone();

                    _position.y -= outline.width;
                    segment.node.position = _position;
                  }
                }
              };

              _proto._convertLiteralColorValue = function _convertLiteralColorValue(color) {
                var colorValue = color.toUpperCase();

                if (Color[colorValue]) {
                  var colorUse = Color[colorValue];
                  return colorUse;
                } else {
                  var out = new Color();
                  return out.fromHEX(color);
                }
              };

              _proto._applyTextAttribute = function _applyTextAttribute(labelSeg) {
                var label = labelSeg.node.getComponent(Label);

                if (!label) {
                  return;
                }

                var index = labelSeg.styleIndex;
                var textStyle;

                if (this._textArray[index]) {
                  textStyle = this._textArray[index].style;
                }

                if (textStyle) {
                  label.color = this._convertLiteralColorValue(textStyle.color || 'white');
                  label.isBold = !!textStyle.bold;
                  label.isItalic = !!textStyle.italic;
                  label.isUnderline = !!textStyle.underline;

                  if (textStyle.outline) {
                    var labelOutline = labelSeg.node.getComponent(LabelOutline);

                    if (!labelOutline) {
                      labelOutline = labelSeg.node.addComponent(LabelOutline);
                    }

                    labelOutline.color = this._convertLiteralColorValue(textStyle.outline.color);
                    labelOutline.width = textStyle.outline.width;
                  }

                  label.fontSize = textStyle.size || this._fontSize;
                  labelSeg.clickHandler = '';
                  labelSeg.clickParam = '';
                  var event = textStyle.event;

                  if (event) {
                    labelSeg.clickHandler = event.click || '';
                    labelSeg.clickParam = event.param || '';
                  }
                } else {
                  label.fontSize = this._fontSize;
                }

                label.cacheMode = this._cacheMode;
                var isAsset = this._font instanceof Font;

                if (isAsset && !this._isSystemFontUsed) {
                  label.font = this._font;
                } else {
                  label.fontFamily = this._fontFamily;
                }

                label.useSystemFont = this._isSystemFontUsed;
                label.lineHeight = this._lineHeight;
                label.updateRenderData(true);
                var assembler = label._assembler;

                if (assembler) {
                  assembler.updateRenderData(label);
                }
              };

              _proto._applyLayer = function _applyLayer() {
                for (var _iterator3 = _createForOfIteratorHelperLoose(this._segments), _step3; !(_step3 = _iterator3()).done;) {
                  var seg = _step3.value;
                  seg.node.layer = this.node.layer;
                }
              };

              return RichText;
            }(UIComponent), _class3$6.HorizontalAlign = HorizontalTextAlignment, _class3$6.VerticalAlign = VerticalTextAlignment, _temp$n), (_applyDecoratedDescriptor(_class2$l.prototype, "string", [multiline, _dec5$g], Object.getOwnPropertyDescriptor(_class2$l.prototype, "string"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "horizontalAlign", [_dec6$f, _dec7$f], Object.getOwnPropertyDescriptor(_class2$l.prototype, "horizontalAlign"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "fontSize", [_dec8$d], Object.getOwnPropertyDescriptor(_class2$l.prototype, "fontSize"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "fontFamily", [_dec9$c], Object.getOwnPropertyDescriptor(_class2$l.prototype, "fontFamily"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "font", [_dec10$a, _dec11$9], Object.getOwnPropertyDescriptor(_class2$l.prototype, "font"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "useSystemFont", [_dec12$8], Object.getOwnPropertyDescriptor(_class2$l.prototype, "useSystemFont"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "cacheMode", [_dec13$8, _dec14$6], Object.getOwnPropertyDescriptor(_class2$l.prototype, "cacheMode"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "maxWidth", [_dec15$5], Object.getOwnPropertyDescriptor(_class2$l.prototype, "maxWidth"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "lineHeight", [_dec16$5], Object.getOwnPropertyDescriptor(_class2$l.prototype, "lineHeight"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "imageAtlas", [_dec17$4, _dec18$3], Object.getOwnPropertyDescriptor(_class2$l.prototype, "imageAtlas"), _class2$l.prototype), _applyDecoratedDescriptor(_class2$l.prototype, "handleTouchEvent", [_dec19$2], Object.getOwnPropertyDescriptor(_class2$l.prototype, "handleTouchEvent"), _class2$l.prototype), _descriptor$l = _applyDecoratedDescriptor(_class2$l.prototype, "_lineHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 40;
              }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$l.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '<color=#00ff00>Rich</color><color=#0fffff>Text</color>';
              }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class2$l.prototype, "_horizontalAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return HorizontalTextAlignment.LEFT;
              }
            }), _descriptor4$c = _applyDecoratedDescriptor(_class2$l.prototype, "_fontSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 40;
              }
            }), _descriptor5$9 = _applyDecoratedDescriptor(_class2$l.prototype, "_maxWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor6$6 = _applyDecoratedDescriptor(_class2$l.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 'Arial';
              }
            }), _descriptor7$5 = _applyDecoratedDescriptor(_class2$l.prototype, "_font", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor8$5 = _applyDecoratedDescriptor(_class2$l.prototype, "_isSystemFontUsed", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor9$4 = _applyDecoratedDescriptor(_class2$l.prototype, "_userDefinedFont", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor10$3 = _applyDecoratedDescriptor(_class2$l.prototype, "_cacheMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return CacheMode.NONE;
              }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class2$l.prototype, "_imageAtlas", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class2$l.prototype, "_handleTouchEvent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            })), _class2$l)) || _class$q) || _class$q) || _class$q) || _class$q) || _class$q));

            var _dec$r, _dec2$l, _dec3$k, _dec4$i, _class$r, _temp$o;
            var UIMeshRenderer = function (v) { return exports({ UIMeshRenderer: v, UIModelComponent: v }), v; }((_dec$r = ccclass('cc.UIMeshRenderer'), _dec2$l = help(), _dec3$k = executionOrder(110), _dec4$i = menu(), _dec$r(_class$r = _dec2$l(_class$r = _dec3$k(_class$r = _dec4$i(_class$r = (_temp$o = function (_UIComponent) {
              _inheritsLoose(UIMeshRenderer, _UIComponent);

              function UIMeshRenderer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _UIComponent.call.apply(_UIComponent, [this].concat(args)) || this;
                _this._models = null;
                _this._modelComponent = null;
                return _this;
              }

              var _proto = UIMeshRenderer.prototype;

              _proto.onLoad = function onLoad() {
                if (!this.node._uiProps.uiTransformComp) {
                  this.node.addComponent('cc.UITransform');
                }

                this._modelComponent = this.getComponent('cc.RenderableComponent');

                if (!this._modelComponent) {
                  console.warn("node '" + (this.node && this.node.name) + "' doesn't have any renderable component");
                  return;
                }

                this._models = this._modelComponent._collectModels();
              };

              _proto.onEnable = function onEnable() {
                _UIComponent.prototype.onEnable.call(this);
              };

              _proto.onDisable = function onDisable() {
                _UIComponent.prototype.onDisable.call(this);
              };

              _proto.onDestroy = function onDestroy() {
                _UIComponent.prototype.onDestroy.call(this);

                this._modelComponent = this.getComponent('cc.RenderableComponent');

                if (!this._modelComponent) {
                  return;
                }

                this._modelComponent._sceneGetter = null;
                this._models = null;
              };

              _proto.updateAssembler = function updateAssembler(render) {
                if (this._models) {
                  this._modelComponent._detachFromScene();

                  for (var _iterator = _createForOfIteratorHelperLoose(this._models), _step; !(_step = _iterator()).done;) {
                    var m = _step.value;
                    render.commitModel.call(render, this, m, this._modelComponent.material);
                  }

                  return true;
                }

                return false;
              };

              _proto.update = function update() {
                this._fitUIRenderQueue();
              };

              _proto._fitUIRenderQueue = function _fitUIRenderQueue() {
                if (!this._modelComponent) {
                  return;
                }

                var matNum = this._modelComponent.sharedMaterials.length;

                for (var i = 0; i < matNum; i++) {
                  var material = this._modelComponent.getMaterialInstance(i);

                  if (material == null) {
                    continue;
                  }

                  var passes = material.passes;
                  var passNum = passes.length;

                  for (var j = 0; j < passNum; j++) {
                    var pass = passes[j];
                    pass._priority = RenderPriority.MAX - 11;

                    if (!pass.blendState.targets[0].blend) {
                      material.overridePipelineStates({
                        blendState: {
                          targets: [{
                            blend: true
                          }]
                        }
                      }, j);
                    }
                  }
                }
              };

              _createClass(UIMeshRenderer, [{
                key: "modelComponent",
                get: function get() {
                  return this._modelComponent;
                }
              }]);

              return UIMeshRenderer;
            }(UIComponent), _temp$o)) || _class$r) || _class$r) || _class$r) || _class$r));

            var MeshBuffer = exports('MeshBuffer', function () {
              _createClass(MeshBuffer, [{
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "vertexBuffers",
                get: function get() {
                  return this._vertexBuffers;
                }
              }, {
                key: "indexBuffer",
                get: function get() {
                  return this._indexBuffer;
                }
              }]);

              function MeshBuffer(batcher) {
                this.vData = null;
                this.iData = null;
                this.byteStart = 0;
                this.byteOffset = 0;
                this.indicesStart = 0;
                this.indicesOffset = 0;
                this.vertexStart = 0;
                this.vertexOffset = 0;
                this.lastByteOffset = 1;
                this._attributes = null;
                this._vertexBuffers = [];
                this._indexBuffer = null;
                this._iaInfo = null;
                this._batcher = void 0;
                this._dirty = false;
                this._vertexFormatBytes = 0;
                this._initVDataCount = 0;
                this._initIDataCount = 256 * 6;
                this._outOfCallback = null;
                this._hInputAssemblers = [];
                this._nextFreeIAHandle = 0;
                this._batcher = batcher;
              }

              var _proto = MeshBuffer.prototype;

              _proto.initialize = function initialize(attrs, outOfCallback) {
                this._outOfCallback = outOfCallback;
                var formatBytes = getComponentPerVertex(attrs);
                this._vertexFormatBytes = formatBytes * Float32Array.BYTES_PER_ELEMENT;
                this._initVDataCount = 256 * this._vertexFormatBytes;
                var vbStride = Float32Array.BYTES_PER_ELEMENT * formatBytes;

                if (!this.vertexBuffers.length) {
                  this.vertexBuffers.push(this._batcher.device.createBuffer(new BufferInfo(BufferUsageBit.VERTEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, vbStride, vbStride)));
                }

                var ibStride = Uint16Array.BYTES_PER_ELEMENT;

                if (!this.indexBuffer) {
                  this._indexBuffer = this._batcher.device.createBuffer(new BufferInfo(BufferUsageBit.INDEX | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, ibStride, ibStride));
                }

                this._attributes = attrs;
                this._iaInfo = new InputAssemblerInfo(this.attributes, this.vertexBuffers, this.indexBuffer);

                this._reallocBuffer();
              };

              _proto.request = function request(vertexCount, indicesCount) {
                if (vertexCount === void 0) {
                  vertexCount = 4;
                }

                if (indicesCount === void 0) {
                  indicesCount = 6;
                }

                this.lastByteOffset = this.byteOffset;
                var byteOffset = this.byteOffset + vertexCount * this._vertexFormatBytes;
                var indicesOffset = this.indicesOffset + indicesCount;

                if (vertexCount + this.vertexOffset > 65535) {
                  if (this._outOfCallback) {
                    this._outOfCallback.call(this._batcher, vertexCount, indicesCount);
                  }

                  return false;
                }

                var byteLength = this.vData.byteLength;
                var indicesLength = this.iData.length;

                if (byteOffset > byteLength || indicesOffset > indicesLength) {
                  while (byteLength < byteOffset || indicesLength < indicesOffset) {
                    this._initVDataCount *= 2;
                    this._initIDataCount *= 2;
                    byteLength = this._initVDataCount * 4;
                    indicesLength = this._initIDataCount;
                  }

                  this._reallocBuffer();
                }

                this.vertexOffset += vertexCount;
                this.indicesOffset += indicesCount;
                this.byteOffset = byteOffset;
                this._dirty = true;
                return true;
              };

              _proto.reset = function reset() {
                this.byteStart = 0;
                this.byteOffset = 0;
                this.indicesStart = 0;
                this.indicesOffset = 0;
                this.vertexStart = 0;
                this.vertexOffset = 0;
                this.lastByteOffset = 0;
                this._nextFreeIAHandle = 0;
                this._dirty = false;
              };

              _proto.destroy = function destroy() {
                this._attributes = null;
                this.vertexBuffers[0].destroy();
                this.vertexBuffers.length = 0;
                this.indexBuffer.destroy();
                this._indexBuffer = null;

                for (var i = 0; i < this._hInputAssemblers.length; i++) {
                  IAPool.free(this._hInputAssemblers[i]);
                }

                this._hInputAssemblers.length = 0;
              };

              _proto.recordBatch = function recordBatch() {
                var vCount = this.indicesOffset - this.indicesStart;

                if (!vCount) {
                  return NULL_HANDLE;
                }

                if (this._hInputAssemblers.length <= this._nextFreeIAHandle) {
                  this._hInputAssemblers.push(IAPool.alloc(this._batcher.device, this._iaInfo));
                }

                var hIA = this._hInputAssemblers[this._nextFreeIAHandle++];
                var ia = IAPool.get(hIA);
                ia.firstIndex = this.indicesStart;
                ia.indexCount = vCount;
                return hIA;
              };

              _proto.uploadBuffers = function uploadBuffers() {
                if (this.byteOffset === 0 || !this._dirty) {
                  return;
                }

                var verticesData = new Float32Array(this.vData.buffer, 0, this.byteOffset >> 2);
                var indicesData = new Uint16Array(this.iData.buffer, 0, this.indicesOffset);

                if (this.byteOffset > this.vertexBuffers[0].size) {
                  this.vertexBuffers[0].resize(this.byteOffset);
                }

                this.vertexBuffers[0].update(verticesData);

                if (this.indicesOffset * 2 > this.indexBuffer.size) {
                  this.indexBuffer.resize(this.indicesOffset * 2);
                }

                this.indexBuffer.update(indicesData);
                this._dirty = false;
              };

              _proto._reallocBuffer = function _reallocBuffer() {
                this._reallocVData(true);

                this._reallocIData(true);
              };

              _proto._reallocVData = function _reallocVData(copyOldData) {
                var oldVData;

                if (this.vData) {
                  oldVData = new Uint8Array(this.vData.buffer);
                }

                this.vData = new Float32Array(this._initVDataCount);

                if (oldVData && copyOldData) {
                  var newData = new Uint8Array(this.vData.buffer);

                  for (var i = 0, l = oldVData.length; i < l; i++) {
                    newData[i] = oldVData[i];
                  }
                }
              };

              _proto._reallocIData = function _reallocIData(copyOldData) {
                var oldIData = this.iData;
                this.iData = new Uint16Array(this._initIDataCount);

                if (oldIData && copyOldData) {
                  var iData = this.iData;

                  for (var i = 0, l = oldIData.length; i < l; i++) {
                    iData[i] = oldIData[i];
                  }
                }
              };

              _createClass(MeshBuffer, [{
                key: "vertexFormatBytes",
                get: function get() {
                  return this._vertexFormatBytes;
                }
              }]);

              return MeshBuffer;
            }());
            MeshBuffer.OPACITY_OFFSET = 8;

            var UI_VIS_FLAG = Layers.Enum.NONE | Layers.Enum.UI_3D;
            var DrawBatch2D = exports('UIDrawBatch', function () {
              _createClass(DrawBatch2D, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                }
              }, {
                key: "hInputAssembler",
                get: function get() {
                  return BatchPool2D.get(this._handle, BatchView2D.INPUT_ASSEMBLER);
                },
                set: function set(handle) {
                  BatchPool2D.set(this._handle, BatchView2D.INPUT_ASSEMBLER, handle);
                }
              }, {
                key: "hDescriptorSet",
                get: function get() {
                  return BatchPool2D.get(this._handle, BatchView2D.DESCRIPTOR_SET);
                },
                set: function set(handle) {
                  BatchPool2D.set(this._handle, BatchView2D.DESCRIPTOR_SET, handle);
                }
              }, {
                key: "visFlags",
                get: function get() {
                  return BatchPool2D.get(this._handle, BatchView2D.VIS_FLAGS);
                },
                set: function set(vis) {
                  BatchPool2D.set(this._handle, BatchView2D.VIS_FLAGS, vis);
                }
              }, {
                key: "passes",
                get: function get() {
                  return this._passes;
                }
              }]);

              function DrawBatch2D() {
                this.bufferBatch = null;
                this.camera = null;
                this.renderScene = null;
                this.model = null;
                this.texture = null;
                this.sampler = null;
                this.useLocalData = null;
                this.isStatic = false;
                this.textureHash = 0;
                this.samplerHash = 0;
                this._handle = NULL_HANDLE;
                this._passes = [];
                this._handle = BatchPool2D.alloc();
                BatchPool2D.set(this._handle, BatchView2D.VIS_FLAGS, UI_VIS_FLAG);
                BatchPool2D.set(this._handle, BatchView2D.INPUT_ASSEMBLER, NULL_HANDLE);
                BatchPool2D.set(this._handle, BatchView2D.DESCRIPTOR_SET, NULL_HANDLE);
              }

              var _proto = DrawBatch2D.prototype;

              _proto.destroy = function destroy(ui) {
                if (this._handle) {
                  var length = this.passes.length;

                  for (var i = 0; i < length; i++) {
                    this.passes[i]._destroyHandle();
                  }

                  this._passes = [];
                  BatchPool2D.free(this._handle);
                  this._handle = NULL_HANDLE;
                }
              };

              _proto.clear = function clear() {
                this.bufferBatch = null;
                this.hInputAssembler = NULL_HANDLE;
                this.hDescriptorSet = NULL_HANDLE;
                this.camera = null;
                this.texture = null;
                this.sampler = null;
                this.model = null;
                this.isStatic = false;
                this.useLocalData = null;
                this.visFlags = UI_VIS_FLAG;
              };

              _proto.fillPasses = function fillPasses(mat, dss, dssHash, bs, bsHash, patches) {
                if (mat) {
                  var passes = mat.passes;

                  if (!passes) {
                    return;
                  }

                  BatchPool2D.set(this._handle, BatchView2D.PASS_COUNT, passes.length);
                  var passOffset = BatchView2D.PASS_0;
                  var shaderOffset = BatchView2D.SHADER_0;
                  var hashFactor = 0;

                  for (var i = 0; i < passes.length; i++, passOffset++, shaderOffset++) {
                    if (!this._passes[i]) {
                      this._passes[i] = new Pass(legacyCC.director.root);
                      this._passes[i]._handle = PassPool.alloc();
                    }

                    var mtlPass = passes[i];
                    var passInUse = this._passes[i];

                    if (!dss) {
                      dss = mtlPass.depthStencilState;
                      dssHash = 0;
                    }

                    if (!bs) {
                      bs = mtlPass.blendState;
                      bsHash = 0;
                    }

                    if (bsHash === -1) {
                      bsHash = 0;
                    }

                    hashFactor = dssHash << 16 | bsHash;
                    mtlPass.update();

                    passInUse._initPassFromTarget(mtlPass, dss, bs, hashFactor);

                    BatchPool2D.set(this._handle, passOffset, passInUse.handle);
                    BatchPool2D.set(this._handle, shaderOffset, passInUse.getShaderVariant(patches));
                  }
                }
              };

              return DrawBatch2D;
            }());

            var _dec$s, _dec2$m, _dec3$l, _dec4$j, _dec5$h, _dec6$g, _dec7$g, _class$s, _class2$m, _temp$p;
            var UIStaticBatch = function (v) { return exports({ UIStaticBatch: v, UIStaticBatchComponent: v }), v; }((_dec$s = ccclass('cc.UIStaticBatch'), _dec2$m = help(), _dec3$l = menu(), _dec4$j = executionOrder(110), _dec5$h = visible(), _dec6$g = visible(), _dec7$g = visible(), _dec$s(_class$s = _dec2$m(_class$s = _dec3$l(_class$s = _dec4$j(_class$s = (_class2$m = (_temp$p = function (_Renderable2D) {
              _inheritsLoose(UIStaticBatch, _Renderable2D);

              function UIStaticBatch() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Renderable2D.call.apply(_Renderable2D, [this].concat(args)) || this;
                _this._init = false;
                _this._meshBuffer = null;
                _this._dirty = true;
                _this._lastMeshBuffer = null;
                _this._uiDrawBatchList = [];
                return _this;
              }

              var _proto = UIStaticBatch.prototype;

              _proto.onLoad = function onLoad() {
                var ui = this._getBatcher();

                if (!ui) {
                  return;
                }

                var attr = vfmtPosUvColor;
                var buffer = new MeshBuffer(ui);
                buffer.initialize(attr, this._arrivalMaxBuffer.bind(this));
                this._meshBuffer = buffer;
              };

              _proto.onDestroy = function onDestroy() {
                _Renderable2D.prototype.onDestroy.call(this);

                this._clearData();

                if (this._meshBuffer) {
                  this._meshBuffer.destroy();

                  this._meshBuffer = null;
                }
              };

              _proto.updateAssembler = function updateAssembler(render) {
                if (this._dirty) {
                  render.finishMergeBatches();
                  this._lastMeshBuffer = render.currBufferBatch;
                  render.currBufferBatch = this._meshBuffer;
                  render.currStaticRoot = this;
                }

                if (this._init) {
                  render.finishMergeBatches();
                  render.commitStaticBatch(this);
                }
              };

              _proto.postUpdateAssembler = function postUpdateAssembler(render) {
                if (this._dirty) {
                  render.finishMergeBatches();
                  render.currBufferBatch = this._lastMeshBuffer;
                  render.currStaticRoot = null;
                  this._dirty = false;
                  this._init = true;
                  this.node._static = true;

                  this._meshBuffer.uploadBuffers();
                }
              };

              _proto.markAsDirty = function markAsDirty() {
                if (!this._getBatcher()) {
                  return;
                }

                this.node._static = false;
                this._dirty = true;
                this._init = false;

                this._clearData();
              };

              _proto._requireDrawBatch = function _requireDrawBatch() {
                var batch = new DrawBatch2D();
                batch.isStatic = true;

                this._uiDrawBatchList.push(batch);

                return batch;
              };

              _proto._clearData = function _clearData() {
                if (this._meshBuffer) {
                  this._meshBuffer.reset();

                  var ui = this._getBatcher();

                  for (var i = 0; i < this._uiDrawBatchList.length; i++) {
                    var element = this._uiDrawBatchList[i];
                    element.destroy(ui);
                  }
                }

                this._uiDrawBatchList.length = 0;
                this._init = false;
              };

              _proto._getBatcher = function _getBatcher() {
                if (director.root && director.root.batcher2D) {
                  return director.root.batcher2D;
                }

                warnID(9301);
                return null;
              };

              _proto._arrivalMaxBuffer = function _arrivalMaxBuffer() {
                var ui = this._getBatcher();

                if (ui) {
                  ui.autoMergeBatches();
                }

                warnID(9300);
              };

              _createClass(UIStaticBatch, [{
                key: "dstBlendFactor",
                get: function get() {
                  return this._dstBlendFactor;
                },
                set: function set(value) {
                  if (this._dstBlendFactor === value) {
                    return;
                  }

                  this._dstBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "srcBlendFactor",
                get: function get() {
                  return this._srcBlendFactor;
                },
                set: function set(value) {
                  if (this._srcBlendFactor === value) {
                    return;
                  }

                  this._srcBlendFactor = value;

                  this._updateBlendFunc();
                }
              }, {
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateColor();

                  this.markForUpdateRenderData();
                }
              }, {
                key: "drawBatchList",
                get: function get() {
                  return this._uiDrawBatchList;
                }
              }]);

              return UIStaticBatch;
            }(Renderable2D), _temp$p), (_applyDecoratedDescriptor(_class2$m.prototype, "dstBlendFactor", [override, _dec5$h], Object.getOwnPropertyDescriptor(_class2$m.prototype, "dstBlendFactor"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "srcBlendFactor", [override, _dec6$g], Object.getOwnPropertyDescriptor(_class2$m.prototype, "srcBlendFactor"), _class2$m.prototype), _applyDecoratedDescriptor(_class2$m.prototype, "color", [override, _dec7$g], Object.getOwnPropertyDescriptor(_class2$m.prototype, "color"), _class2$m.prototype)), _class2$m)) || _class$s) || _class$s) || _class$s) || _class$s));

            var _dec$t, _dec2$n, _dec3$m, _dec4$k, _dec5$i, _dec6$h, _dec7$h, _dec8$e, _class$t, _class2$n, _descriptor$m, _descriptor2$j, _descriptor3$g, _temp$q;
            var LabelShadow = exports('LabelShadow', (_dec$t = ccclass('cc.LabelShadow'), _dec2$n = help(), _dec3$m = executionOrder(110), _dec4$k = menu(), _dec5$i = requireComponent(Label), _dec6$h = tooltip(), _dec7$h = tooltip(), _dec8$e = tooltip(), _dec$t(_class$t = _dec2$n(_class$t = _dec3$m(_class$t = _dec4$k(_class$t = _dec5$i(_class$t = executeInEditMode(_class$t = (_class2$n = (_temp$q = function (_Component) {
              _inheritsLoose(LabelShadow, _Component);

              function LabelShadow() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_color", _descriptor$m, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_offset", _descriptor2$j, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_blur", _descriptor3$g, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = LabelShadow.prototype;

              _proto.onEnable = function onEnable() {
                this._updateRenderData();
              };

              _proto.onDisable = function onDisable() {
                this._updateRenderData();
              };

              _proto._updateRenderData = function _updateRenderData() {
                var label = this.node.getComponent(Label);

                if (label) {
                  label.updateRenderData(true);
                }
              };

              _createClass(LabelShadow, [{
                key: "color",
                get: function get() {
                  return this._color;
                },
                set: function set(value) {
                  if (this._color === value) {
                    return;
                  }

                  this._color.set(value);

                  this._updateRenderData();
                }
              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset = value;

                  this._updateRenderData();
                }
              }, {
                key: "blur",
                get: function get() {
                  return this._blur;
                },
                set: function set(value) {
                  this._blur = value;

                  this._updateRenderData();
                }
              }]);

              return LabelShadow;
            }(Component), _temp$q), (_descriptor$m = _applyDecoratedDescriptor(_class2$n.prototype, "_color", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(0, 0, 0, 255);
              }
            }), _descriptor2$j = _applyDecoratedDescriptor(_class2$n.prototype, "_offset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(2, 2);
              }
            }), _descriptor3$g = _applyDecoratedDescriptor(_class2$n.prototype, "_blur", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 2;
              }
            }), _applyDecoratedDescriptor(_class2$n.prototype, "color", [_dec6$h], Object.getOwnPropertyDescriptor(_class2$n.prototype, "color"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "offset", [_dec7$h], Object.getOwnPropertyDescriptor(_class2$n.prototype, "offset"), _class2$n.prototype), _applyDecoratedDescriptor(_class2$n.prototype, "blur", [_dec8$e], Object.getOwnPropertyDescriptor(_class2$n.prototype, "blur"), _class2$n.prototype)), _class2$n)) || _class$t) || _class$t) || _class$t) || _class$t) || _class$t) || _class$t));

            var _dec$u, _dec2$o, _dec3$n, _dec4$l, _class$u, _class2$o, _descriptor$n, _temp$r;
            var UIOpacity = function (v) { return exports({ UIOpacity: v, UIOpacityComponent: v }), v; }((_dec$u = ccclass('cc.UIOpacity'), _dec2$o = help(), _dec3$n = executionOrder(110), _dec4$l = menu(), _dec$u(_class$u = _dec2$o(_class$u = _dec3$n(_class$u = _dec4$l(_class$u = executeInEditMode(_class$u = (_class2$o = (_temp$r = function (_Component) {
              _inheritsLoose(UIOpacity, _Component);

              function UIOpacity() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_opacity", _descriptor$n, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = UIOpacity.prototype;

              _proto.onEnable = function onEnable() {
                this.node._uiProps.opacity = this._opacity / 255;
              };

              _proto.onDisable = function onDisable() {
                this.node._uiProps.opacity = 1;
              };

              _createClass(UIOpacity, [{
                key: "opacity",
                get: function get() {
                  return this._opacity;
                },
                set: function set(value) {
                  if (this._opacity === value) {
                    return;
                  }

                  value = clampf(value, 0, 255);
                  this._opacity = value;
                  this.node._uiProps.opacity = value / 255;
                }
              }]);

              return UIOpacity;
            }(Component), _temp$r), (_applyDecoratedDescriptor(_class2$o.prototype, "opacity", [editable], Object.getOwnPropertyDescriptor(_class2$o.prototype, "opacity"), _class2$o.prototype), _descriptor$n = _applyDecoratedDescriptor(_class2$o.prototype, "_opacity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 255;
              }
            })), _class2$o)) || _class$u) || _class$u) || _class$u) || _class$u) || _class$u));

            legacyCC.MaskComponent = Mask;
            js.setClassAlias(Mask, 'cc.MaskComponent');
            legacyCC.LabelComponent = Label;
            js.setClassAlias(Label, 'cc.LabelComponent');
            legacyCC.LabelOutlineComponent = LabelOutline;
            js.setClassAlias(LabelOutline, 'cc.LabelOutlineComponent');
            legacyCC.RichTextComponent = RichText;
            js.setClassAlias(RichText, 'cc.RichTextComponent');
            legacyCC.SpriteComponent = Sprite;
            js.setClassAlias(Sprite, 'cc.SpriteComponent');
            legacyCC.UIModelComponent = UIMeshRenderer;
            js.setClassAlias(UIMeshRenderer, 'cc.UIModelComponent');
            legacyCC.GraphicsComponent = Graphics;
            js.setClassAlias(Graphics, 'cc.GraphicsComponent');
            js.setClassAlias(UIStaticBatch, 'cc.UIStaticBatchComponent');
            js.setClassAlias(UIOpacity, 'cc.UIOpacityComponent');

            var Aim = function Aim(i, x, y) {
              this.i = void 0;
              this.x = void 0;
              this.y = void 0;
              this.prev = null;
              this.next = null;
              this.z = 0;
              this.prevZ = null;
              this.nextZ = null;
              this.steiner = false;
              this.i = i;
              this.x = x;
              this.y = y;
            };

            function linkedList(datas, start, end, dim, clockwise) {
              var i = 0;
              var last = null;

              if (clockwise === signedArea(datas, start, end, dim) > 0) {
                for (i = start; i < end; i += dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              } else {
                for (i = end - dim; i >= start; i -= dim) {
                  last = insertNode(i, datas[i], datas[i + 1], last);
                }
              }

              if (last && equals(last, last.next)) {
                removeNode(last);
                last = last.next;
              }

              return last;
            }

            function filterPoints(start, end) {
              if (end === void 0) {
                end = null;
              }

              if (!start) {
                return start;
              }

              if (!end) {
                end = start;
              }

              var p = start;
              var again = false;

              do {
                again = false;

                if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
                  removeNode(p);
                  p = end = p.prev;

                  if (p === p.next) {
                    return null;
                  }

                  again = true;
                } else {
                  p = p.next;
                }
              } while (again || p !== end);

              return end;
            }

            function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
              if (pass === void 0) {
                pass = 0;
              }

              if (!ear) {
                return;
              }

              if (!pass && size) {
                indexCurve(ear, minX, minY, size);
              }

              var stop = ear;
              var prev = null;
              var next = null;

              while (ear.prev !== ear.next) {
                prev = ear.prev;
                next = ear.next;

                if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
                  triangles.push(prev.i / dim);
                  triangles.push(ear.i / dim);
                  triangles.push(next.i / dim);
                  removeNode(ear);
                  ear = next.next;
                  stop = next.next;
                  continue;
                }

                ear = next;

                if (ear === stop) {
                  if (!pass) {
                    earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
                  } else if (pass === 1) {
                    ear = cureLocalIntersections(ear, triangles, dim);
                    earcutLinked(ear, triangles, dim, minX, minY, size, 2);
                  } else if (pass === 2) {
                    splitEarcut(ear, triangles, dim, minX, minY, size);
                  }

                  break;
                }
              }
            }

            function isEar(ear) {
              var a = ear.prev;
              var b = ear;
              var c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              var p = ear.next.next;

              while (p !== ear.prev) {
                if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.next;
              }

              return true;
            }

            function isEarHashed(ear, minX, minY, size) {
              var a = ear.prev;
              var b = ear;
              var c = ear.next;

              if (area(a, b, c) >= 0) {
                return false;
              }

              var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
              var minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
              var maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
              var maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
              var minZ = zOrder(minTX, minTY, minX, minY, size);
              var maxZ = zOrder(maxTX, maxTY, minX, minY, size);
              var p = ear.nextZ;

              while (p && p.z <= maxZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.nextZ;
              }

              p = ear.prevZ;

              while (p && p.z >= minZ) {
                if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) {
                  return false;
                }

                p = p.prevZ;
              }

              return true;
            }

            function cureLocalIntersections(start, triangles, dim) {
              var p = start;

              do {
                var a = p.prev;
                var b = p.next.next;

                if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
                  triangles.push(a.i / dim);
                  triangles.push(p.i / dim);
                  triangles.push(b.i / dim);
                  removeNode(p);
                  removeNode(p.next);
                  p = start = b;
                }

                p = p.next;
              } while (p !== start);

              return p;
            }

            function splitEarcut(start, triangles, dim, minX, minY, size) {
              var a = start;

              do {
                var b = a.next.next;

                while (b !== a.prev) {
                  if (a.i !== b.i && isValidDiagonal(a, b)) {
                    var c = splitPolygon(a, b);
                    a = filterPoints(a, a.next);
                    c = filterPoints(c, c.next);
                    earcutLinked(a, triangles, dim, minX, minY, size);
                    earcutLinked(c, triangles, dim, minX, minY, size);
                    return;
                  }

                  b = b.next;
                }

                a = a.next;
              } while (a !== start);
            }

            function eliminateHoles(datas, holeIndices, outerNode, dim) {
              var queue = [];
              var i = 0;
              var len = 0;
              var start = 0;
              var end = 0;
              var list = null;

              for (i = 0, len = holeIndices.length; i < len; i++) {
                start = holeIndices[i] * dim;
                end = i < len - 1 ? holeIndices[i + 1] * dim : datas.length;
                list = linkedList(datas, start, end, dim, false);

                if (!list) {
                  continue;
                }

                if (list === list.next) {
                  list.steiner = true;
                }

                queue.push(getLeftmost(list));
              }

              queue.sort(compareX);

              if (!outerNode) {
                return outerNode;
              }

              for (i = 0; i < queue.length; i++) {
                eliminateHole(queue[i], outerNode);
                outerNode = filterPoints(outerNode, outerNode.next);
              }

              return outerNode;
            }

            function compareX(a, b) {
              return a.x - b.x;
            }

            function eliminateHole(hole, outerNode) {
              outerNode = findHoleBridge(hole, outerNode);

              if (outerNode) {
                var b = splitPolygon(outerNode, hole);
                filterPoints(b, b.next);
              }
            }

            function findHoleBridge(hole, outerNode) {
              var p = outerNode;
              var hx = hole.x;
              var hy = hole.y;
              var qx = -Infinity;
              var m = null;

              do {
                if (hy <= p.y && hy >= p.next.y) {
                  var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

                  if (x <= hx && x > qx) {
                    qx = x;

                    if (x === hx) {
                      if (hy === p.y) {
                        return p;
                      }

                      if (hy === p.next.y) {
                        return p.next;
                      }
                    }

                    m = p.x < p.next.x ? p : p.next;
                  }
                }

                p = p.next;
              } while (p !== outerNode);

              if (!m) {
                return null;
              }

              if (hx === qx) {
                return m.prev;
              }

              var stop = m;
              var mx = m.x;
              var my = m.y;
              var tanMin = Infinity;
              var tan;
              p = m.next;

              while (p !== stop) {
                if (hx >= p.x && p.x >= mx && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                  tan = Math.abs(hy - p.y) / (hx - p.x);

                  if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                  }
                }

                p = p.next;
              }

              return m;
            }

            function indexCurve(start, minX, minY, size) {
              var p = start;

              do {
                if (p.z === null) {
                  p.z = zOrder(p.x, p.y, minX, minY, size);
                }

                p.prevZ = p.prev;
                p.nextZ = p.next;
                p = p.next;
              } while (p !== start);

              p.prevZ.nextZ = null;
              p.prevZ = null;
              sortLinked(p);
            }

            function sortLinked(list) {
              var i = 0;
              var p = null;
              var q = null;
              var e = null;
              var tail = null;
              var numMerges = 0;
              var pSize = 0;
              var qSize = 0;
              var inSize = 1;

              do {
                p = list;
                list = null;
                tail = null;
                numMerges = 0;

                while (p) {
                  numMerges++;
                  q = p;
                  pSize = 0;

                  for (i = 0; i < inSize; i++) {
                    pSize++;
                    q = q.nextZ;

                    if (!q) {
                      break;
                    }
                  }

                  qSize = inSize;

                  while (pSize > 0 || qSize > 0 && q) {
                    if (pSize === 0) {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    } else if (qSize === 0 || !q) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else if (p.z <= q.z) {
                      e = p;
                      p = p.nextZ;
                      pSize--;
                    } else {
                      e = q;
                      q = q.nextZ;
                      qSize--;
                    }

                    if (tail) {
                      tail.nextZ = e;
                    } else {
                      list = e;
                    }

                    e.prevZ = tail;
                    tail = e;
                  }

                  p = q;
                }

                tail.nextZ = null;
                inSize *= 2;
              } while (numMerges > 1);

              return list;
            }

            function zOrder(x, y, minX, minY, size) {
              x = 32767 * (x - minX) / size;
              y = 32767 * (y - minY) / size;
              x = (x | x << 8) & 0x00FF00FF;
              x = (x | x << 4) & 0x0F0F0F0F;
              x = (x | x << 2) & 0x33333333;
              x = (x | x << 1) & 0x55555555;
              y = (y | y << 8) & 0x00FF00FF;
              y = (y | y << 4) & 0x0F0F0F0F;
              y = (y | y << 2) & 0x33333333;
              y = (y | y << 1) & 0x55555555;
              return x | y << 1;
            }

            function getLeftmost(start) {
              var p = start;
              var leftmost = start;

              do {
                if (p.x < leftmost.x) {
                  leftmost = p;
                }

                p = p.next;
              } while (p !== start);

              return leftmost;
            }

            function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
              return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
            }

            function isValidDiagonal(a, b) {
              return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
            }

            function area(p, q, r) {
              return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
            }

            function equals(p1, p2) {
              return p1.x === p2.x && p1.y === p2.y;
            }

            function intersects(p1, q1, p2, q2) {
              if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1)) {
                return true;
              }

              return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
            }

            function intersectsPolygon(a, b) {
              var p = a;

              do {
                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) {
                  return true;
                }

                p = p.next;
              } while (p !== a);

              return false;
            }

            function locallyInside(a, b) {
              return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
            }

            function middleInside(a, b) {
              var p = a;
              var inside = false;
              var px = (a.x + b.x) / 2;
              var py = (a.y + b.y) / 2;

              do {
                if (p.y > py !== p.next.y > py && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) {
                  inside = !inside;
                }

                p = p.next;
              } while (p !== a);

              return inside;
            }

            function splitPolygon(a, b) {
              var a2 = new Aim(a.i, a.x, a.y);
              var b2 = new Aim(b.i, b.x, b.y);
              var an = a.next;
              var bp = b.prev;
              a.next = b;
              b.prev = a;
              a2.next = an;
              an.prev = a2;
              b2.next = a2;
              a2.prev = b2;
              bp.next = b2;
              b2.prev = bp;
              return b2;
            }

            function insertNode(i, x, y, last) {
              var p = new Aim(i, x, y);

              if (!last) {
                p.prev = p;
                p.next = p;
              } else {
                p.next = last.next;
                p.prev = last;
                last.next.prev = p;
                last.next = p;
              }

              return p;
            }

            function removeNode(p) {
              p.next.prev = p.prev;
              p.prev.next = p.next;

              if (p.prevZ) {
                p.prevZ.nextZ = p.nextZ;
              }

              if (p.nextZ) {
                p.nextZ.prevZ = p.prevZ;
              }
            }

            function signedArea(datas, start, end, dim) {
              var sum = 0;

              for (var i = start, j = end - dim; i < end; i += dim) {
                sum += (datas[j] - datas[i]) * (datas[i + 1] + datas[j + 1]);
                j = i;
              }

              return sum;
            }

            function earcut(datas, holeIndices, dim) {
              dim = dim || 3;
              var hasHoles = holeIndices ? holeIndices.length : 0;
              var outerLen = hasHoles ? holeIndices[0] * dim : datas.length;
              var outerNode = linkedList(datas, 0, outerLen, dim, true);
              var triangles = [];

              if (!outerNode) {
                return triangles;
              }

              var minX = 0;
              var minY = 0;
              var maxX = 0;
              var maxY = 0;
              var x = 0;
              var y = 0;
              var size = 0;

              if (hasHoles) {
                outerNode = eliminateHoles(datas, holeIndices, outerNode, dim);
              }

              if (datas.length > 80 * dim) {
                minX = maxX = datas[0];
                minY = maxY = datas[1];

                for (var i = dim; i < outerLen; i += dim) {
                  x = datas[i];
                  y = datas[i + 1];

                  if (x < minX) {
                    minX = x;
                  }

                  if (y < minY) {
                    minY = y;
                  }

                  if (x > maxX) {
                    maxX = x;
                  }

                  if (y > maxY) {
                    maxY = y;
                  }
                }

                size = Math.max(maxX - minX, maxY - minY);
              }

              earcutLinked(outerNode, triangles, dim, minX, minY, size);
              return triangles;
            }

            var MAX_VERTEX = 65535;
            var MAX_INDICES = MAX_VERTEX * 2;
            var PI$1 = Math.PI;
            var min$1 = Math.min;
            var max$1 = Math.max;
            var ceil = Math.ceil;
            var acos = Math.acos;
            var cos$1 = Math.cos;
            var sin$1 = Math.sin;
            var atan2 = Math.atan2;
            var attrBytes = 8;
            var _renderData = null;
            var _impl = null;

            var _curColor = new Color();

            var vec3_temps = [];

            for (var i = 0; i < 4; i++) {
              vec3_temps.push(new Vec3());
            }

            function curveDivs(r, arc, tol) {
              var da = acos(r / (r + tol)) * 2.0;
              return max$1(2, ceil(arc / da));
            }

            function clamp(v, minNum, maxNum) {
              if (v < minNum) {
                return minNum;
              } else if (v > maxNum) {
                return maxNum;
              }

              return v;
            }

            var graphicsAssembler = {
              useModel: true,
              updateRenderData: function updateRenderData(graphics) {},
              fillBuffers: function fillBuffers(graphics, renderer) {},
              renderIA: function renderIA(graphics, renderer) {},
              getRenderData: function getRenderData(graphics, vertexCount) {
                if (!_impl) {
                  return null;
                }

                var renderDataList = _impl.getRenderDataList();

                var renderData = renderDataList[_impl.dataOffset];

                if (!renderData) {
                  return null;
                }

                var meshBuffer = renderData;
                var maxVertexCount = meshBuffer ? meshBuffer.vertexStart + vertexCount : 0;

                if (maxVertexCount > MAX_VERTEX || maxVertexCount * 3 > MAX_INDICES) {
                  ++_impl.dataOffset;

                  if (_impl.dataOffset < renderDataList.length) {
                    renderData = renderDataList[_impl.dataOffset];
                  } else {
                    renderData = _impl.requestRenderData();
                    renderDataList[_impl.dataOffset] = renderData;
                  }

                  meshBuffer = renderData;
                }

                if (meshBuffer && meshBuffer.vertexCount < maxVertexCount) {
                  meshBuffer.request(vertexCount, vertexCount * 3);
                }

                return renderData;
              },
              stroke: function stroke(graphics) {
                Color.copy(_curColor, graphics.strokeColor);

                if (!graphics.impl) {
                  return;
                }

                this._flattenPaths(graphics.impl);

                this._expandStroke(graphics);

                graphics.impl.updatePathOffset = true;
                this.end(graphics);
              },
              fill: function fill(graphics) {
                Color.copy(_curColor, graphics.fillColor);

                this._expandFill(graphics);

                if (graphics.impl) {
                  graphics.impl.updatePathOffset = true;
                }

                this.end(graphics);
              },
              end: function end(graphics) {
                graphics.markForUpdateRenderData();
              },
              _expandStroke: function _expandStroke(graphics) {
                var w = graphics.lineWidth * 0.5;
                var lineCap = graphics.lineCap;
                var lineJoin = graphics.lineJoin;
                var miterLimit = graphics.miterLimit;
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                var nCap = curveDivs(w, PI$1, _impl.tessTol);

                this._calculateJoins(_impl, w, lineJoin, miterLimit);

                var paths = _impl.paths;
                var vertexCount = 0;

                for (var _i = _impl.pathOffset, l = _impl.pathLength; _i < l; _i++) {
                  var path = paths[_i];
                  var pointsLength = path.points.length;

                  if (lineJoin === LineJoin.ROUND) {
                    vertexCount += (pointsLength + path.bevel * (nCap + 2) + 1) * 2;
                  } else {
                    vertexCount += (pointsLength + path.bevel * 5 + 1) * 2;
                  }

                  if (!path.closed) {
                    if (lineCap === LineCap.ROUND) {
                      vertexCount += (nCap * 2 + 2) * 2;
                    } else {
                      vertexCount += (3 + 3) * 2;
                    }
                  }
                }

                var meshBuffer = _renderData = this.getRenderData(graphics, vertexCount);

                if (!meshBuffer) {
                  return;
                }

                var vData = meshBuffer.vData;
                var iData = meshBuffer.iData;

                for (var _i2 = _impl.pathOffset, _l = _impl.pathLength; _i2 < _l; _i2++) {
                  var _path = paths[_i2];
                  var pts = _path.points;
                  var _pointsLength = pts.length;
                  var offset = meshBuffer.vertexStart;
                  var p0 = void 0;
                  var p1 = void 0;
                  var start = 0;
                  var end = 0;
                  var loop = _path.closed;

                  if (loop) {
                    p0 = pts[_pointsLength - 1];
                    p1 = pts[0];
                    start = 0;
                    end = _pointsLength;
                  } else {
                    p0 = pts[0];
                    p1 = pts[1];
                    start = 1;
                    end = _pointsLength - 1;
                  }

                  p1 = p1 || p0;

                  if (!loop) {
                    var dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    dPos.normalize();
                    var dx = dPos.x;
                    var dy = dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapStart(p0, dx, dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapStart(p0, dx, dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapStart(p0, dx, dy, w, nCap);
                    }
                  }

                  for (var j = start; j < end; ++j) {
                    if (lineJoin === LineJoin.ROUND) {
                      this._roundJoin(p0, p1, w, w, nCap);
                    } else if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      this._bevelJoin(p0, p1, w, w);
                    } else {
                      this._vSet(p1.x + p1.dmx * w, p1.y + p1.dmy * w, 1);

                      this._vSet(p1.x - p1.dmx * w, p1.y - p1.dmy * w, -1);
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }

                  if (loop) {
                    var vDataOffset = offset * attrBytes;

                    this._vSet(vData[vDataOffset], vData[vDataOffset + 1], 1);

                    this._vSet(vData[vDataOffset + attrBytes], vData[vDataOffset + attrBytes + 1], -1);
                  } else {
                    var _dPos = new Point(p1.x, p1.y);

                    _dPos.subtract(p0);

                    _dPos.normalize();

                    var _dx = _dPos.x;
                    var _dy = _dPos.y;

                    if (lineCap === LineCap.BUTT) {
                      this._buttCapEnd(p1, _dx, _dy, w, 0);
                    } else if (lineCap === LineCap.SQUARE) {
                      this._buttCapEnd(p1, _dx, _dy, w, w);
                    } else if (lineCap === LineCap.ROUND) {
                      this._roundCapEnd(p1, _dx, _dy, w, nCap);
                    }
                  }

                  var indicesOffset = meshBuffer.indicesStart;

                  for (var begin = offset + 2, over = meshBuffer.vertexStart; begin < over; begin++) {
                    iData[indicesOffset++] = begin - 2;
                    iData[indicesOffset++] = begin - 1;
                    iData[indicesOffset++] = begin;
                  }

                  meshBuffer.indicesStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },
              _expandFill: function _expandFill(graphics) {
                _impl = graphics.impl;

                if (!_impl) {
                  return;
                }

                var paths = _impl.paths;
                var vertexCount = 0;

                for (var _i3 = _impl.pathOffset, l = _impl.pathLength; _i3 < l; _i3++) {
                  var path = paths[_i3];
                  var pointsLength = path.points.length;
                  vertexCount += pointsLength;
                }

                var renderData = _renderData = this.getRenderData(graphics, vertexCount);

                if (!renderData) {
                  return;
                }

                var meshBuffer = renderData;
                var vData = meshBuffer.vData;
                var iData = meshBuffer.iData;

                for (var _i4 = _impl.pathOffset, _l2 = _impl.pathLength; _i4 < _l2; _i4++) {
                  var _path2 = paths[_i4];
                  var pts = _path2.points;
                  var _pointsLength2 = pts.length;

                  if (_pointsLength2 === 0) {
                    continue;
                  }

                  var vertexOffset = renderData.vertexStart;

                  for (var j = 0; j < _pointsLength2; ++j) {
                    this._vSet(pts[j].x, pts[j].y);
                  }

                  var indicesOffset = renderData.indicesStart;

                  if (_path2.complex) {
                    var earcutData = [];

                    for (var _j = vertexOffset, end = renderData.vertexStart; _j < end; _j++) {
                      var vDataOffset = _j * attrBytes;
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                      earcutData.push(vData[vDataOffset++]);
                    }

                    var newIndices = earcut(earcutData, null, 3);

                    if (!newIndices || newIndices.length === 0) {
                      continue;
                    }

                    for (var _j2 = 0, nIndices = newIndices.length; _j2 < nIndices; _j2++) {
                      iData[indicesOffset++] = newIndices[_j2] + vertexOffset;
                    }
                  } else {
                    var first = vertexOffset;

                    for (var start = vertexOffset + 2, _end = meshBuffer.vertexStart; start < _end; start++) {
                      iData[indicesOffset++] = first;
                      iData[indicesOffset++] = start - 1;
                      iData[indicesOffset++] = start;
                    }
                  }

                  meshBuffer.indicesStart = indicesOffset;
                }

                _renderData = null;
                _impl = null;
              },
              _calculateJoins: function _calculateJoins(impl, w, lineJoin, miterLimit) {
                var iw = 0.0;

                if (w > 0.0) {
                  iw = 1 / w;
                }

                var paths = impl.paths;

                for (var _i5 = impl.pathOffset, l = impl.pathLength; _i5 < l; _i5++) {
                  var path = paths[_i5];
                  var pts = path.points;
                  var ptsLength = pts.length;
                  var p0 = pts[ptsLength - 1];
                  var p1 = pts[0];
                  path.bevel = 0;

                  for (var j = 0; j < ptsLength; j++) {
                    var dmr2 = 0;
                    var cross = 0;
                    var limit = 0;
                    var dlx0 = p0.dy;
                    var dly0 = -p0.dx;
                    var dlx1 = p1.dy;
                    var dly1 = -p1.dx;
                    p1.dmx = (dlx0 + dlx1) * 0.5;
                    p1.dmy = (dly0 + dly1) * 0.5;
                    dmr2 = p1.dmx * p1.dmx + p1.dmy * p1.dmy;

                    if (dmr2 > 0.000001) {
                      var scale = 1 / dmr2;

                      if (scale > 600) {
                        scale = 600;
                      }

                      p1.dmx *= scale;
                      p1.dmy *= scale;
                    }

                    cross = p1.dx * p0.dy - p0.dx * p1.dy;

                    if (cross > 0) {
                      p1.flags |= PointFlags.PT_LEFT;
                    }

                    limit = max$1(11, min$1(p0.len, p1.len) * iw);

                    if (dmr2 * limit * limit < 1) {
                      p1.flags |= PointFlags.PT_INNERBEVEL;
                    }

                    if (p1.flags & PointFlags.PT_CORNER) {
                      if (dmr2 * miterLimit * miterLimit < 1 || lineJoin === LineJoin.BEVEL || lineJoin === LineJoin.ROUND) {
                        p1.flags |= PointFlags.PT_BEVEL;
                      }
                    }

                    if ((p1.flags & (PointFlags.PT_BEVEL | PointFlags.PT_INNERBEVEL)) !== 0) {
                      path.bevel++;
                    }

                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },
              _flattenPaths: function _flattenPaths(impl) {
                var paths = impl.paths;

                for (var _i6 = impl.pathOffset, l = impl.pathLength; _i6 < l; _i6++) {
                  var path = paths[_i6];
                  var pts = path.points;
                  var p0 = pts[pts.length - 1];
                  var p1 = pts[0];

                  if (pts.length > 2 && p0.equals(p1)) {
                    path.closed = true;
                    pts.pop();
                    p0 = pts[pts.length - 1];
                  }

                  for (var j = 0, size = pts.length; j < size; j++) {
                    var dPos = new Point(p1.x, p1.y);
                    dPos.subtract(p0);
                    p0.len = dPos.length();

                    if (dPos.x || dPos.y) {
                      dPos.normalize();
                    }

                    p0.dx = dPos.x;
                    p0.dy = dPos.y;
                    p0 = p1;
                    p1 = pts[j + 1];
                  }
                }
              },
              _chooseBevel: function _chooseBevel(bevel, p0, p1, w) {
                var x = p1.x;
                var y = p1.y;
                var x0 = 0;
                var y0 = 0;
                var x1 = 0;
                var y1 = 0;

                if (bevel !== 0) {
                  x0 = x + p0.dy * w;
                  y0 = y - p0.dx * w;
                  x1 = x + p1.dy * w;
                  y1 = y - p1.dx * w;
                } else {
                  x0 = x1 = x + p1.dmx * w;
                  y0 = y1 = y + p1.dmy * w;
                }

                return [x0, y0, x1, y1];
              },
              _buttCapStart: function _buttCapStart(p, dx, dy, w, d) {
                var px = p.x - dx * d;
                var py = p.y - dy * d;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _buttCapEnd: function _buttCapEnd(p, dx, dy, w, d) {
                var px = p.x + dx * d;
                var py = p.y + dy * d;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _roundCapStart: function _roundCapStart(p, dx, dy, w, nCap) {
                var px = p.x;
                var py = p.y;
                var dlx = dy;
                var dly = -dx;

                for (var _i7 = 0; _i7 < nCap; _i7++) {
                  var a = _i7 / (nCap - 1) * PI$1;
                  var ax = cos$1(a) * w;
                  var ay = sin$1(a) * w;

                  this._vSet(px - dlx * ax - dx * ay, py - dly * ax - dy * ay, 1);

                  this._vSet(px, py, 0);
                }

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);
              },
              _roundCapEnd: function _roundCapEnd(p, dx, dy, w, nCap) {
                var px = p.x;
                var py = p.y;
                var dlx = dy;
                var dly = -dx;

                this._vSet(px + dlx * w, py + dly * w, 1);

                this._vSet(px - dlx * w, py - dly * w, -1);

                for (var _i8 = 0; _i8 < nCap; _i8++) {
                  var a = _i8 / (nCap - 1) * PI$1;
                  var ax = cos$1(a) * w;
                  var ay = sin$1(a) * w;

                  this._vSet(px, py, 0);

                  this._vSet(px - dlx * ax + dx * ay, py - dly * ax + dy * ay, 1);
                }
              },
              _roundJoin: function _roundJoin(p0, p1, lw, rw, nCap) {
                var dlx0 = p0.dy;
                var dly0 = -p0.dx;
                var dlx1 = p1.dy;
                var dly1 = -p1.dx;
                var p1x = p1.x;
                var p1y = p1.y;

                if ((p1.flags & PointFlags.PT_LEFT) !== 0) {
                  var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  var lx0 = out[0];
                  var ly0 = out[1];
                  var lx1 = out[2];
                  var ly1 = out[3];
                  var a0 = atan2(-dly0, -dlx0);
                  var a1 = atan2(-dly1, -dlx1);

                  if (a1 > a0) {
                    a1 -= PI$1 * 2;
                  }

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  var n = clamp(ceil((a0 - a1) / PI$1) * nCap, 2, nCap);

                  for (var _i9 = 0; _i9 < n; _i9++) {
                    var u = _i9 / (n - 1);
                    var a = a0 + u * (a1 - a0);
                    var rx = p1x + cos$1(a) * rw;
                    var ry = p1y + sin$1(a) * rw;

                    this._vSet(p1x, p1y, 0);

                    this._vSet(rx, ry, -1);
                  }

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1x - dlx1 * rw, p1y - dly1 * rw, -1);
                } else {
                  var _out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  var rx0 = _out[0];
                  var ry0 = _out[1];
                  var rx1 = _out[2];
                  var ry1 = _out[3];

                  var _a = atan2(dly0, dlx0);

                  var _a2 = atan2(dly1, dlx1);

                  if (_a2 < _a) {
                    _a2 += PI$1 * 2;
                  }

                  this._vSet(p1x + dlx0 * rw, p1y + dly0 * rw, 1);

                  this._vSet(rx0, ry0, -1);

                  var _n = clamp(ceil((_a2 - _a) / PI$1) * nCap, 2, nCap);

                  for (var _i10 = 0; _i10 < _n; _i10++) {
                    var _u = _i10 / (_n - 1);

                    var _a3 = _a + _u * (_a2 - _a);

                    var lx = p1x + cos$1(_a3) * lw;
                    var ly = p1y + sin$1(_a3) * lw;

                    this._vSet(lx, ly, 1);

                    this._vSet(p1x, p1y, 0);
                  }

                  this._vSet(p1x + dlx1 * rw, p1y + dly1 * rw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },
              _bevelJoin: function _bevelJoin(p0, p1, lw, rw) {
                var rx0 = 0;
                var ry0 = 0;
                var rx1 = 0;
                var ry1 = 0;
                var lx0 = 0;
                var ly0 = 0;
                var lx1 = 0;
                var ly1 = 0;
                var dlx0 = p0.dy;
                var dly0 = -p0.dx;
                var dlx1 = p1.dy;
                var dly1 = -p1.dx;

                if (p1.flags & PointFlags.PT_LEFT) {
                  var out = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, lw);

                  lx0 = out[0];
                  ly0 = out[1];
                  lx1 = out[2];
                  ly1 = out[3];

                  this._vSet(lx0, ly0, 1);

                  this._vSet(p1.x - dlx0 * rw, p1.y - dly0 * rw, -1);

                  this._vSet(lx1, ly1, 1);

                  this._vSet(p1.x - dlx1 * rw, p1.y - dly1 * rw, -1);
                } else {
                  var _out2 = this._chooseBevel(p1.flags & PointFlags.PT_INNERBEVEL, p0, p1, -rw);

                  rx0 = _out2[0];
                  ry0 = _out2[1];
                  rx1 = _out2[2];
                  ry1 = _out2[3];

                  this._vSet(p1.x + dlx0 * lw, p1.y + dly0 * lw, 1);

                  this._vSet(rx0, ry0, -1);

                  this._vSet(p1.x + dlx1 * lw, p1.y + dly1 * lw, 1);

                  this._vSet(rx1, ry1, -1);
                }
              },
              _vSet: function _vSet(x, y, distance) {
                if (distance === void 0) {
                  distance = 0;
                }

                if (!_renderData) {
                  return;
                }

                var meshBuffer = _renderData;
                var dataOffset = meshBuffer.vertexStart * attrBytes;
                var vData = meshBuffer.vData;
                vData[dataOffset++] = x;
                vData[dataOffset++] = y;
                vData[dataOffset++] = 0;
                Color.toArray(vData, _curColor, dataOffset);
                dataOffset += 4;
                vData[dataOffset++] = distance;
                meshBuffer.vertexStart++;
              }
            };

            var graphicsAssemblerManager = exports('graphicsAssembler', {
              getAssembler: function getAssembler(sprite) {
                return graphicsAssembler;
              }
            });
            Graphics.Assembler = graphicsAssemblerManager;

            var LetterInfo = function LetterInfo() {
              this["char"] = '';
              this.valid = true;
              this.x = 0;
              this.y = 0;
              this.line = 0;
              this.hash = '';
            };

            var _tmpRect = new Rect$1();

            var _comp = null;
            var _uiTrans = null;
            var _horizontalKerning = [];
            var _lettersInfo = [];
            var _linesWidth = [];
            var _linesOffsetX = [];

            var _labelDimensions = new Size();

            var _contentSize = new Size();

            var letterPosition = new Vec2();
            var _lineSpacing = 0;
            var _fntConfig = null;
            var _numberOfLines = 0;
            var _textDesiredHeight = 0;
            var _letterOffsetY = 0;
            var _tailoredTopY = 0;
            var _tailoredBottomY = 0;
            var _bmfontScale = 1.0;
            var _spriteFrame = null;
            var _string = '';
            var _fontSize = 0;
            var _originFontSize = 0;
            var _hAlign = 0;
            var _vAlign = 0;
            var _spacingX = 0;
            var _lineHeight = 0;
            var _overflow = 0;
            var _isWrapText = false;
            var _labelWidth = 0;
            var _labelHeight = 0;
            var _maxLineWidth = 0;
            var bmfontUtils = {
              updateRenderData: function updateRenderData(comp) {
                if (!comp.renderData || !comp.renderData.vertDirty) {
                  return;
                }

                if (_comp === comp) {
                  return;
                }

                _comp = comp;
                _uiTrans = _comp.node._uiProps.uiTransformComp;

                this._updateFontFamily(comp);

                this._updateProperties(comp);

                this._updateLabelInfo(comp);

                this._updateContent();

                _comp.actualFontSize = _fontSize;

                _uiTrans.setContentSize(_contentSize);

                _comp.renderData.vertDirty = _comp.renderData.uvDirty = false;
                _comp = null;

                this._resetProperties();
              },
              _updateFontScale: function _updateFontScale() {
                _bmfontScale = _fontSize / _originFontSize;
              },
              _updateFontFamily: function _updateFontFamily(comp) {
                var fontAsset = comp.font;
                _spriteFrame = fontAsset.spriteFrame;
                _fntConfig = fontAsset.fntConfig;
                shareLabelInfo.fontAtlas = fontAsset.fontDefDictionary;
                dynamicAtlasManager.packToDynamicAtlas(comp, _spriteFrame);
              },
              _updateLabelInfo: function _updateLabelInfo(comp) {
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },
              _updateProperties: function _updateProperties(comp) {
                _string = comp.string.toString();
                _fontSize = comp.fontSize;
                _originFontSize = _fntConfig ? _fntConfig.fontSize : comp.fontSize;
                _hAlign = comp.horizontalAlign;
                _vAlign = comp.verticalAlign;
                _spacingX = comp.spacingX;
                _overflow = comp.overflow;
                _lineHeight = comp._lineHeight;
                var contentSize = _uiTrans.contentSize;
                _contentSize.width = contentSize.width;
                _contentSize.height = contentSize.height;

                if (_overflow === Overflow.NONE) {
                  _isWrapText = false;
                  _contentSize.width += shareLabelInfo.margin * 2;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else if (_overflow === Overflow.RESIZE_HEIGHT) {
                  _isWrapText = true;
                  _contentSize.height += shareLabelInfo.margin * 2;
                } else {
                  _isWrapText = comp.enableWrapText;
                }

                shareLabelInfo.lineHeight = _lineHeight;
                shareLabelInfo.fontSize = _fontSize;

                this._setupBMFontOverflowMetrics();
              },
              _resetProperties: function _resetProperties() {
                _fntConfig = null;
                _spriteFrame = null;
                shareLabelInfo.hash = '';
                shareLabelInfo.margin = 0;
              },
              _updateContent: function _updateContent() {
                this._updateFontScale();

                this._computeHorizontalKerningForText();

                this._alignText();
              },
              _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {
                var string = _string;
                var stringLen = string.length;
                var kerningDict = _fntConfig.kerningDict;
                var horizontalKerning = _horizontalKerning;
                var prev = -1;

                for (var i = 0; i < stringLen; ++i) {
                  var key = string.charCodeAt(i);
                  var kerningAmount = kerningDict[prev << 16 | key & 0xffff] || 0;

                  if (i < stringLen - 1) {
                    horizontalKerning[i] = kerningAmount;
                  } else {
                    horizontalKerning[i] = 0;
                  }

                  prev = key;
                }
              },
              _multilineTextWrap: function _multilineTextWrap(nextTokenFunc) {
                var textLen = _string.length;
                var lineIndex = 0;
                var nextTokenX = 0;
                var nextTokenY = 0;
                var longestLine = 0;
                var letterRight = 0;
                var highestY = 0;
                var lowestY = 0;
                var letterDef = null;

                for (var index = 0; index < textLen;) {
                  var character = _string.charAt(index);

                  if (character === '\n') {
                    _linesWidth.push(letterRight);

                    letterRight = 0;
                    lineIndex++;
                    nextTokenX = 0;
                    nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;

                    this._recordPlaceholderInfo(index, character);

                    index++;
                    continue;
                  }

                  var tokenLen = nextTokenFunc(_string, index, textLen);
                  var tokenHighestY = highestY;
                  var tokenLowestY = lowestY;
                  var tokenRight = letterRight;
                  var nextLetterX = nextTokenX;
                  var newLine = false;

                  for (var tmp = 0; tmp < tokenLen; ++tmp) {
                    var letterIndex = index + tmp;
                    character = _string.charAt(letterIndex);

                    if (character === '\r') {
                      this._recordPlaceholderInfo(letterIndex, character);

                      continue;
                    }

                    letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                    if (!letterDef) {
                      this._recordPlaceholderInfo(letterIndex, character);

                      console.log("Can't find letter definition in texture atlas " + _fntConfig.atlasName + " for letter:" + character);
                      continue;
                    }

                    var letterX = nextLetterX + letterDef.offsetX * _bmfontScale - shareLabelInfo.margin;

                    if (_isWrapText && _maxLineWidth > 0 && nextTokenX > 0 && letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character)) {
                      _linesWidth.push(letterRight);

                      letterRight = 0;
                      lineIndex++;
                      nextTokenX = 0;
                      nextTokenY -= _lineHeight * this._getFontScale() + _lineSpacing;
                      newLine = true;
                      break;
                    } else {
                      letterPosition.x = letterX;
                    }

                    letterPosition.y = nextTokenY - letterDef.offsetY * _bmfontScale;

                    this._recordLetterInfo(letterPosition, character, letterIndex, lineIndex);

                    if (letterIndex + 1 < _horizontalKerning.length && letterIndex < textLen - 1) {
                      nextLetterX += _horizontalKerning[letterIndex + 1];
                    }

                    nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;
                    tokenRight = letterPosition.x + letterDef.w * _bmfontScale;

                    if (tokenHighestY < letterPosition.y) {
                      tokenHighestY = letterPosition.y;
                    }

                    if (tokenLowestY > letterPosition.y - letterDef.h * _bmfontScale) {
                      tokenLowestY = letterPosition.y - letterDef.h * _bmfontScale;
                    }
                  }

                  if (newLine) {
                    continue;
                  }

                  nextTokenX = nextLetterX;
                  letterRight = tokenRight;

                  if (highestY < tokenHighestY) {
                    highestY = tokenHighestY;
                  }

                  if (lowestY > tokenLowestY) {
                    lowestY = tokenLowestY;
                  }

                  if (longestLine < letterRight) {
                    longestLine = letterRight;
                  }

                  index += tokenLen;
                }

                _linesWidth.push(letterRight);

                _numberOfLines = lineIndex + 1;
                _textDesiredHeight = _numberOfLines * _lineHeight * this._getFontScale();

                if (_numberOfLines > 1) {
                  _textDesiredHeight += (_numberOfLines - 1) * _lineSpacing;
                }

                _contentSize.width = _labelWidth;
                _contentSize.height = _labelHeight;

                if (_labelWidth <= 0) {
                  _contentSize.width = parseFloat(longestLine.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                if (_labelHeight <= 0) {
                  _contentSize.height = parseFloat(_textDesiredHeight.toFixed(2)) + shareLabelInfo.margin * 2;
                }

                _tailoredTopY = _contentSize.height;
                _tailoredBottomY = 0;

                if (highestY > 0) {
                  _tailoredTopY = _contentSize.height + highestY;
                }

                if (lowestY < -_textDesiredHeight) {
                  _tailoredBottomY = _textDesiredHeight + lowestY;
                }

                return true;
              },
              _getFirstCharLen: function _getFirstCharLen() {
                return 1;
              },
              _getFontScale: function _getFontScale() {
                return _overflow === Overflow.SHRINK ? _bmfontScale : 1;
              },
              _getFirstWordLen: function _getFirstWordLen(text, startIndex, textLen) {
                var character = text.charAt(startIndex);

                if (isUnicodeCJK(character) || character === '\n' || isUnicodeSpace(character)) {
                  return 1;
                }

                var len = 1;
                var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                if (!letterDef) {
                  return len;
                }

                var nextLetterX = letterDef.xAdvance * _bmfontScale + _spacingX;
                var letterX = 0;

                for (var index = startIndex + 1; index < textLen; ++index) {
                  character = text.charAt(index);
                  letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(character, shareLabelInfo);

                  if (!letterDef) {
                    break;
                  }

                  letterX = nextLetterX + letterDef.offsetX * _bmfontScale;

                  if (letterX + letterDef.w * _bmfontScale > _maxLineWidth && !isUnicodeSpace(character) && _maxLineWidth > 0) {
                    return len;
                  }

                  nextLetterX += letterDef.xAdvance * _bmfontScale + _spacingX;

                  if (character === '\n' || isUnicodeSpace(character) || isUnicodeCJK(character)) {
                    break;
                  }

                  len++;
                }

                return len;
              },
              _multilineTextWrapByWord: function _multilineTextWrapByWord() {
                return this._multilineTextWrap(this._getFirstWordLen);
              },
              _multilineTextWrapByChar: function _multilineTextWrapByChar() {
                return this._multilineTextWrap(this._getFirstCharLen);
              },
              _recordPlaceholderInfo: function _recordPlaceholderInfo(letterIndex, _char) {
                if (letterIndex >= _lettersInfo.length) {
                  var tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                _lettersInfo[letterIndex]["char"] = _char;
                _lettersInfo[letterIndex].hash = _char.charCodeAt(0) + shareLabelInfo.hash;
                _lettersInfo[letterIndex].valid = false;
              },
              _recordLetterInfo: function _recordLetterInfo(letterPosition, character, letterIndex, lineIndex) {
                if (letterIndex >= _lettersInfo.length) {
                  var tmpInfo = new LetterInfo();

                  _lettersInfo.push(tmpInfo);
                }

                var _char2 = character.charCodeAt(0);

                var key = _char2 + shareLabelInfo.hash;
                _lettersInfo[letterIndex].line = lineIndex;
                _lettersInfo[letterIndex]["char"] = character;
                _lettersInfo[letterIndex].hash = key;
                _lettersInfo[letterIndex].valid = shareLabelInfo.fontAtlas.getLetter(key).valid;
                _lettersInfo[letterIndex].x = letterPosition.x;
                _lettersInfo[letterIndex].y = letterPosition.y;
              },
              _alignText: function _alignText() {
                _textDesiredHeight = 0;
                _linesWidth.length = 0;

                {
                  this._multilineTextWrapByWord();
                }

                this._computeAlignmentOffset();

                if (_overflow === Overflow.SHRINK) {
                  if (_fontSize > 0 && this._isVerticalClamp()) {
                    this._shrinkLabelToContentSize(this._isVerticalClamp);
                  }
                }

                if (!this._updateQuads()) {
                  if (_overflow === Overflow.SHRINK) {
                    this._shrinkLabelToContentSize(this._isHorizontalClamp);
                  }
                }
              },
              _scaleFontSizeDown: function _scaleFontSizeDown(fontSize) {
                var shouldUpdateContent = true;

                if (!fontSize) {
                  fontSize = 0.1;
                  shouldUpdateContent = false;
                }

                _fontSize = fontSize;

                if (shouldUpdateContent) {
                  this._updateContent();
                }
              },
              _shrinkLabelToContentSize: function _shrinkLabelToContentSize(lambda) {
                var fontSize = _fontSize;
                var left = 0;
                var right = fontSize | 0;
                var mid = 0;

                while (left < right) {
                  mid = left + right + 1 >> 1;
                  var newFontSize = mid;

                  if (newFontSize <= 0) {
                    break;
                  }

                  _bmfontScale = newFontSize / _originFontSize;

                  {
                    this._multilineTextWrapByWord();
                  }

                  this._computeAlignmentOffset();

                  if (lambda()) {
                    right = mid - 1;
                  } else {
                    left = mid;
                  }
                }

                if (left >= 0) {
                  this._scaleFontSizeDown(left);
                }
              },
              _isVerticalClamp: function _isVerticalClamp() {
                if (_textDesiredHeight > _contentSize.height) {
                  return true;
                } else {
                  return false;
                }
              },
              _isHorizontalClamp: function _isHorizontalClamp() {
                var letterClamp = false;

                for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  var letterInfo = _lettersInfo[ctr];

                  if (letterInfo.valid) {
                    var letterDef = shareLabelInfo.fontAtlas.getLetterDefinitionForChar(letterInfo["char"], shareLabelInfo);

                    if (!letterDef) {
                      continue;
                    }

                    var px = letterInfo.x + letterDef.w / 2 * _bmfontScale;
                    var lineIndex = letterInfo.line;

                    if (_labelWidth > 0) {
                      if (!_isWrapText) {
                        if (px > _contentSize.width) {
                          letterClamp = true;
                          break;
                        }
                      } else {
                        var wordWidth = _linesWidth[lineIndex];

                        if (wordWidth > _contentSize.width && (px > _contentSize.width || px < 0)) {
                          letterClamp = true;
                          break;
                        }
                      }
                    }
                  }
                }

                return letterClamp;
              },
              _isHorizontalClamped: function _isHorizontalClamped(px, lineIndex) {
                var wordWidth = _linesWidth[lineIndex];
                var letterOverClamp = px > _contentSize.width || px < 0;

                if (!_isWrapText) {
                  return letterOverClamp;
                } else {
                  return wordWidth > _contentSize.width && letterOverClamp;
                }
              },
              _updateQuads: function _updateQuads() {
                if (!_comp) {
                  return false;
                }

                var texture = _spriteFrame ? _spriteFrame.texture : shareLabelInfo.fontAtlas.getTexture();
                var renderData = _comp.renderData;
                renderData.dataLength = renderData.vertexCount = renderData.indicesCount = 0;
                var anchorPoint = _uiTrans.anchorPoint;
                var contentSize = _contentSize;
                var appX = anchorPoint.x * contentSize.width;
                var appY = anchorPoint.y * contentSize.height;
                var ret = true;

                for (var ctr = 0, l = _string.length; ctr < l; ++ctr) {
                  var letterInfo = _lettersInfo[ctr];

                  if (!letterInfo.valid) {
                    continue;
                  }

                  var letterDef = shareLabelInfo.fontAtlas.getLetter(letterInfo.hash);

                  if (!letterDef) {
                    console.warn('Can\'t find letter in this bitmap-font');
                    continue;
                  }

                  _tmpRect.height = letterDef.h;
                  _tmpRect.width = letterDef.w;
                  _tmpRect.x = letterDef.u;
                  _tmpRect.y = letterDef.v;
                  var py = letterInfo.y + _letterOffsetY;

                  if (_labelHeight > 0) {
                    if (py > _tailoredTopY) {
                      var clipTop = py - _tailoredTopY;
                      _tmpRect.y += clipTop;
                      _tmpRect.height -= clipTop;
                      py -= clipTop;
                    }

                    if (py - letterDef.h * _bmfontScale < _tailoredBottomY && _overflow === Overflow.CLAMP) {
                      _tmpRect.height = py < _tailoredBottomY ? 0 : (py - _tailoredBottomY) / _bmfontScale;
                    }
                  }

                  var lineIndex = letterInfo.line;
                  var px = letterInfo.x + letterDef.w / 2 * _bmfontScale + _linesOffsetX[lineIndex];

                  if (_labelWidth > 0) {
                    if (this._isHorizontalClamped(px, lineIndex)) {
                      if (_overflow === Overflow.CLAMP) {
                        _tmpRect.width = 0;
                      } else if (_overflow === Overflow.SHRINK) {
                        if (_contentSize.width > letterDef.w) {
                          ret = false;
                          break;
                        } else {
                          _tmpRect.width = 0;
                        }
                      }
                    }
                  }

                  if (_tmpRect.height > 0 && _tmpRect.width > 0) {
                    var isRotated = this._determineRect();

                    var letterPositionX = letterInfo.x + _linesOffsetX[letterInfo.line];
                    this.appendQuad(_comp, texture, _tmpRect, isRotated, letterPositionX - appX, py - appY, _bmfontScale);
                  }
                }

                return ret;
              },
              appendQuad: function appendQuad(comp, texture, rect, rotated, x, y, scale) {},
              _determineRect: function _determineRect() {
                var isRotated = _spriteFrame.isRotated();

                var originalSize = _spriteFrame.getOriginalSize();

                var rect = _spriteFrame.getRect();

                var offset = _spriteFrame.getOffset();

                var trimmedLeft = offset.x + (originalSize.width - rect.width) / 2;
                var trimmedTop = offset.y - (originalSize.height - rect.height) / 2;

                if (!isRotated) {
                  _tmpRect.x += rect.x - trimmedLeft;
                  _tmpRect.y += rect.y + trimmedTop;
                } else {
                  var originalX = _tmpRect.x;
                  _tmpRect.x = rect.x + rect.height - _tmpRect.y - _tmpRect.height - trimmedTop;
                  _tmpRect.y = originalX + rect.y - trimmedLeft;

                  if (_tmpRect.y < 0) {
                    _tmpRect.height += trimmedTop;
                  }
                }

                return isRotated;
              },
              _computeAlignmentOffset: function _computeAlignmentOffset() {
                _linesOffsetX.length = 0;

                switch (_hAlign) {
                  case HorizontalTextAlignment.LEFT:
                    for (var i = 0; i < _numberOfLines; ++i) {
                      _linesOffsetX.push(0);
                    }

                    break;

                  case HorizontalTextAlignment.CENTER:
                    for (var _i = 0, l = _linesWidth.length; _i < l; _i++) {
                      _linesOffsetX.push((_contentSize.width - _linesWidth[_i]) / 2);
                    }

                    break;

                  case HorizontalTextAlignment.RIGHT:
                    for (var _i2 = 0, _l = _linesWidth.length; _i2 < _l; _i2++) {
                      _linesOffsetX.push(_contentSize.width - _linesWidth[_i2]);
                    }

                    break;
                }

                _letterOffsetY = _contentSize.height;

                if (_vAlign !== VerticalTextAlignment.TOP) {
                  var blank = _contentSize.height - _textDesiredHeight + _lineHeight * this._getFontScale() - _originFontSize * _bmfontScale;

                  if (_vAlign === VerticalTextAlignment.BOTTOM) {
                    _letterOffsetY -= blank;
                  } else {
                    _letterOffsetY -= blank / 2;
                  }
                }
              },
              _setupBMFontOverflowMetrics: function _setupBMFontOverflowMetrics() {
                var newWidth = _contentSize.width;
                var newHeight = _contentSize.height;

                if (_overflow === Overflow.RESIZE_HEIGHT) {
                  newHeight = 0;
                }

                if (_overflow === Overflow.NONE) {
                  newWidth = 0;
                  newHeight = 0;
                }

                _labelWidth = newWidth;
                _labelHeight = newHeight;
                _labelDimensions.width = newWidth;
                _labelDimensions.height = newHeight;
                _maxLineWidth = newWidth;
              }
            };

            var bmfont = {
              createData: function createData(comp) {
                return comp.requestRenderData();
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var node = comp.node;
                fillMeshVertices3D(node, renderer, comp.renderData, comp.color);
              },
              appendQuad: function appendQuad(comp, spriteFrame, rect, rotated, x, y, scale) {
                var renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                var dataOffset = renderData.dataLength;
                renderData.dataLength += 4;
                renderData.vertexCount = renderData.dataLength;
                renderData.indicesCount = renderData.dataLength / 2 * 3;
                var dataList = renderData.data;
                var texW = spriteFrame.width;
                var texH = spriteFrame.height;
                var rectWidth = rect.width;
                var rectHeight = rect.height;
                var l = 0;
                var b = 0;
                var t = 0;
                var r = 0;

                if (!rotated) {
                  l = rect.x / texW;
                  r = (rect.x + rectWidth) / texW;
                  b = (rect.y + rectHeight) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = b;
                  dataList[dataOffset + 1].u = r;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = l;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = t;
                } else {
                  l = rect.x / texW;
                  r = (rect.x + rectHeight) / texW;
                  b = (rect.y + rectWidth) / texH;
                  t = rect.y / texH;
                  dataList[dataOffset].u = l;
                  dataList[dataOffset].v = t;
                  dataList[dataOffset + 1].u = l;
                  dataList[dataOffset + 1].v = b;
                  dataList[dataOffset + 2].u = r;
                  dataList[dataOffset + 2].v = t;
                  dataList[dataOffset + 3].u = r;
                  dataList[dataOffset + 3].v = b;
                }

                dataList[dataOffset].x = x;
                dataList[dataOffset].y = y - rectHeight * scale;
                dataList[dataOffset + 1].x = x + rectWidth * scale;
                dataList[dataOffset + 1].y = y - rectHeight * scale;
                dataList[dataOffset + 2].x = x;
                dataList[dataOffset + 2].y = y;
                dataList[dataOffset + 3].x = x + rectWidth * scale;
                dataList[dataOffset + 3].y = y;
              }
            };
            addon(bmfont, bmfontUtils);

            var _atlasWidth = 1024;
            var _atlasHeight = 1024;
            var _shareAtlas = null;
            var letterFont = mixin(bmfontUtils, {
              getAssemblerData: function getAssemblerData() {
                if (!_shareAtlas) {
                  _shareAtlas = new LetterAtlas(_atlasWidth, _atlasHeight);
                }

                return _shareAtlas.getTexture();
              },
              _updateFontFamily: function _updateFontFamily(comp) {
                shareLabelInfo.fontAtlas = _shareAtlas;
                shareLabelInfo.fontFamily = this._getFontFamily(comp);
                var outline = comp.getComponent(LabelOutline);

                if (outline && outline.enabled) {
                  shareLabelInfo.isOutlined = true;
                  shareLabelInfo.margin = outline.width;
                  shareLabelInfo.out = outline.color.clone();
                  shareLabelInfo.out.a = outline.color.a * comp.color.a / 255.0;
                } else {
                  shareLabelInfo.isOutlined = false;
                  shareLabelInfo.margin = 0;
                }
              },
              _getFontFamily: function _getFontFamily(comp) {
                var fontFamily = 'Arial';

                if (!comp.useSystemFont) {
                  if (comp.font) {
                    if (comp.font._nativeAsset) {
                      fontFamily = comp.font._nativeAsset;
                    } else {
                      assetManager.postLoadNative(comp.font, function (err) {
                        if (!comp.isValid) {
                          return;
                        }

                        fontFamily = comp.font._nativeAsset || 'Arial';
                        comp.updateRenderData(true);
                      });
                    }
                  }
                } else {
                  fontFamily = comp.fontFamily || 'Arial';
                }

                return fontFamily;
              },
              _updateLabelInfo: function _updateLabelInfo(comp) {
                shareLabelInfo.fontDesc = this._getFontDesc();
                shareLabelInfo.color = comp.color;
                shareLabelInfo.hash = computeHash(shareLabelInfo);
              },
              _getFontDesc: function _getFontDesc() {
                var fontDesc = shareLabelInfo.fontSize.toString() + "px ";
                fontDesc += shareLabelInfo.fontFamily;

                return fontDesc;
              },
              _computeHorizontalKerningForText: function _computeHorizontalKerningForText() {},
              _determineRect: function _determineRect(tempRect) {
                return false;
              }
            });

            var WHITE$1 = new Color(255, 255, 255, 255);
            var letter = {
              createData: function createData(comp) {
                return comp.requestRenderData();
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                if (!comp.renderData) {
                  return;
                }

                var node = comp.node;
                WHITE$1.a = comp.color.a;
                fillMeshVertices3D(node, renderer, comp.renderData, WHITE$1);
              },
              appendQuad: bmfont.appendQuad
            };
            addon(letter, letterFont);

            var Overflow$1 = Label.Overflow;
            var MAX_SIZE = 2048;

            var _BASELINE_OFFSET$1 = getBaselineOffset();

            var _context = null;
            var _canvas = null;
            var _texture = null;
            var _fontDesc = '';
            var _string$1 = '';
            var _fontSize$1 = 0;
            var _drawFontsize = 0;
            var _splitStrings = [];

            var _canvasSize = new Size();

            var _lineHeight$1 = 0;
            var _hAlign$1 = 0;
            var _vAlign$1 = 0;

            var _color = new Color();

            var _fontFamily = '';
            var _overflow$1 = Overflow$1.NONE;
            var _isWrapText$1 = false;
            var _outlineComp = null;

            var _outlineColor = Color.BLACK.clone();

            var _shadowComp = null;

            var _shadowColor = Color.BLACK.clone();

            var _canvasPadding = new Rect$1();

            var _contentSizeExtend = Size.ZERO.clone();

            var _nodeContentSize = Size.ZERO.clone();

            var _startPosition = Vec2.ZERO.clone();

            var _drawUnderlinePos = Vec2.ZERO.clone();

            var _drawUnderlineWidth = 0;
            var _underlineThickness = 0;
            var _isBold = false;
            var _isItalic = false;
            var _isUnderline = false;
            var Alignment = ['left', 'center', 'right'];
            var ttfUtils = {
              getAssemblerData: function getAssemblerData() {
                var sharedLabelData = Label._canvasPool.get();

                return sharedLabelData;
              },
              resetAssemblerData: function resetAssemblerData(assemblerData) {
                if (assemblerData) {
                  Label._canvasPool.put(assemblerData);
                }
              },
              updateRenderData: function updateRenderData(comp) {
                if (!comp.renderData || !comp.renderData.vertDirty) {
                  return;
                }

                var trans = comp.node._uiProps.uiTransformComp;

                this._updateFontFamily(comp);

                this._updateProperties(comp, trans);

                this._calculateLabelFont();

                this._updateLabelDimensions();

                this._resetDynamicAtlas(comp);

                this._updateTexture();

                this._calDynamicAtlas(comp);

                comp.actualFontSize = _fontSize$1;
                trans.setContentSize(_canvasSize);
                this.updateVertexData(comp);
                this.updateUvs(comp);
                comp.markForUpdateRenderData(false);
                _context = null;
                _canvas = null;
                _texture = null;
              },
              updateVertexData: function updateVertexData(comp) {},
              updateUvs: function updateUvs(comp) {},
              _updateFontFamily: function _updateFontFamily(comp) {
                if (!comp.useSystemFont) {
                  if (comp.font) {
                    if (comp.font._nativeAsset) {
                      _fontFamily = comp.font._nativeAsset;
                    } else {
                      assetManager.postLoadNative(comp.font, function (err) {
                        if (!comp.isValid) {
                          return;
                        }

                        _fontFamily = comp.font._nativeAsset || 'Arial';
                        comp.updateRenderData(true);
                      });
                      _fontFamily = 'Arial';
                    }
                  } else {
                    _fontFamily = 'Arial';
                  }
                } else {
                  _fontFamily = comp.fontFamily || 'Arial';
                }
              },
              _updateProperties: function _updateProperties(comp, trans) {
                var assemblerData = comp.assemblerData;

                if (!assemblerData) {
                  return;
                }

                _context = assemblerData.context;
                _canvas = assemblerData.canvas;
                _texture = comp.spriteFrame;
                _string$1 = comp.string.toString();
                _fontSize$1 = comp.fontSize;
                _drawFontsize = _fontSize$1;
                _overflow$1 = comp.overflow;
                _nodeContentSize.width = _canvasSize.width = trans.width;
                _nodeContentSize.height = _canvasSize.height = trans.height;
                _underlineThickness = comp.underlineHeight;
                _lineHeight$1 = comp.lineHeight;
                _hAlign$1 = comp.horizontalAlign;
                _vAlign$1 = comp.verticalAlign;
                _color = comp.color;
                _isBold = comp.isBold;
                _isItalic = comp.isItalic;
                _isUnderline = comp.isUnderline;

                if (_overflow$1 === Overflow$1.NONE) {
                  _isWrapText$1 = false;
                } else if (_overflow$1 === Overflow$1.RESIZE_HEIGHT) {
                  _isWrapText$1 = true;
                } else {
                  _isWrapText$1 = comp.enableWrapText;
                }

                _outlineComp = LabelOutline && comp.getComponent(LabelOutline);
                _outlineComp = _outlineComp && _outlineComp.enabled && _outlineComp.width > 0 ? _outlineComp : null;

                if (_outlineComp) {
                  _outlineColor.set(_outlineComp.color);
                }

                _shadowComp = LabelShadow && comp.getComponent(LabelShadow);
                _shadowComp = _shadowComp && _shadowComp.enabled ? _shadowComp : null;

                if (_shadowComp) {
                  _shadowColor.set(_shadowComp.color);
                }

                this._updatePaddingRect();
              },
              _updatePaddingRect: function _updatePaddingRect() {
                var top = 0;
                var bottom = 0;
                var left = 0;
                var right = 0;
                var outlineWidth = 0;
                _contentSizeExtend.width = _contentSizeExtend.height = 0;

                if (_outlineComp) {
                  outlineWidth = _outlineComp.width;
                  top = bottom = left = right = outlineWidth;
                  _contentSizeExtend.width = _contentSizeExtend.height = outlineWidth * 2;
                }

                if (_shadowComp) {
                  var shadowWidth = _shadowComp.blur + outlineWidth;
                  var offsetX = _shadowComp.offset.x;
                  var offsetY = _shadowComp.offset.y;
                  left = Math.max(left, -offsetX + shadowWidth);
                  right = Math.max(right, offsetX + shadowWidth);
                  top = Math.max(top, offsetY + shadowWidth);
                  bottom = Math.max(bottom, -offsetY + shadowWidth);
                }

                if (_isItalic) {
                  var offset = _drawFontsize * Math.tan(12 * 0.0174532925);

                  right += offset;
                  _contentSizeExtend.width += offset;
                }

                _canvasPadding.x = left;
                _canvasPadding.y = top;
                _canvasPadding.width = left + right;
                _canvasPadding.height = top + bottom;
              },
              _calculateFillTextStartPosition: function _calculateFillTextStartPosition() {
                var labelX = 0;

                if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                  labelX = _canvasSize.width - _canvasPadding.width;
                } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                  labelX = (_canvasSize.width - _canvasPadding.width) / 2;
                }

                var lineHeight = this._getLineHeight();

                var drawStartY = lineHeight * (_splitStrings.length - 1);
                var firstLinelabelY = _fontSize$1 * (1 - BASELINE_RATIO / 2);

                if (_vAlign$1 !== VerticalTextAlignment.TOP) {
                  var blank = drawStartY + _canvasPadding.height + _fontSize$1 - _canvasSize.height;

                  if (_vAlign$1 === VerticalTextAlignment.BOTTOM) {
                    blank += BASELINE_RATIO / 2 * _fontSize$1;
                    firstLinelabelY -= blank;
                  } else {
                    firstLinelabelY -= blank / 2;
                  }
                }

                firstLinelabelY += _BASELINE_OFFSET$1 * _fontSize$1;

                _startPosition.set(labelX + _canvasPadding.x, firstLinelabelY + _canvasPadding.y);
              },
              _updateTexture: function _updateTexture() {
                if (!_context || !_canvas) {
                  return;
                }

                _context.clearRect(0, 0, _canvas.width, _canvas.height);

                _context.font = _fontDesc;

                this._calculateFillTextStartPosition();

                var lineHeight = this._getLineHeight();

                _context.lineJoin = 'round';
                _context.fillStyle = "rgba(" + _color.r + ", " + _color.g + ", " + _color.b + ", 1)";
                var drawTextPosX = _startPosition.x;
                var drawTextPosY = 0;

                this._drawTextEffect(_startPosition, lineHeight);

                for (var i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosY = _startPosition.y + i * lineHeight;

                  if (_outlineComp) {
                    _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                }

                if (_shadowComp) {
                  _context.shadowColor = 'transparent';
                }

                if (_texture) {
                  var tex;

                  if (_texture instanceof SpriteFrame) {
                    tex = _texture.texture;
                  } else {
                    tex = _texture;
                  }

                  var uploadAgain = _canvas.width !== 0 && _canvas.height !== 0;

                  if (uploadAgain) {
                    tex.reset({
                      width: _canvas.width,
                      height: _canvas.height,
                      mipmapLevel: 1
                    });
                    tex.uploadData(_canvas);

                    if (_texture instanceof SpriteFrame) {
                      _texture.rect = new Rect$1(0, 0, _canvas.width, _canvas.height);

                      _texture._calculateUV();
                    }

                    if (legacyCC.director.root && legacyCC.director.root.batcher2D) {
                      legacyCC.director.root.batcher2D._releaseDescriptorSetCache(tex.getHash());
                    }
                  }
                }
              },
              _resetDynamicAtlas: function _resetDynamicAtlas(comp) {
                if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
                var frame = comp.ttfSpriteFrame;
                dynamicAtlasManager.deleteAtlasSpriteFrame(frame);

                frame._resetDynamicAtlasFrame();
              },
              _calDynamicAtlas: function _calDynamicAtlas(comp) {
                if (comp.cacheMode !== Label.CacheMode.BITMAP) return;
                var frame = comp.ttfSpriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(comp, frame);
                comp.renderData.uvDirty = true;
              },
              _setupOutline: function _setupOutline() {
                _context.strokeStyle = "rgba(" + _outlineColor.r + ", " + _outlineColor.g + ", " + _outlineColor.b + ", " + _outlineColor.a / 255 + ")";
                _context.lineWidth = _outlineComp.width * 2;
              },
              _setupShadow: function _setupShadow() {
                _context.shadowColor = "rgba(" + _shadowColor.r + ", " + _shadowColor.g + ", " + _shadowColor.b + ", " + _shadowColor.a / 255 + ")";
                _context.shadowBlur = _shadowComp.blur;
                _context.shadowOffsetX = _shadowComp.offset.x;
                _context.shadowOffsetY = -_shadowComp.offset.y;
              },
              _drawTextEffect: function _drawTextEffect(startPosition, lineHeight) {
                if (!_shadowComp && !_outlineComp && !_isUnderline) return;
                var isMultiple = _splitStrings.length > 1 && _shadowComp;

                var measureText = this._measureText(_context, _fontDesc);

                var drawTextPosX = 0;
                var drawTextPosY = 0;

                if (_shadowComp) {
                  this._setupShadow();
                }

                if (_outlineComp) {
                  this._setupOutline();
                }

                for (var i = 0; i < _splitStrings.length; ++i) {
                  drawTextPosX = startPosition.x;
                  drawTextPosY = startPosition.y + i * lineHeight;

                  if (isMultiple) {
                    if (_outlineComp) {
                      _context.strokeText(_splitStrings[i], drawTextPosX, drawTextPosY);
                    }

                    _context.fillText(_splitStrings[i], drawTextPosX, drawTextPosY);
                  }

                  if (_isUnderline) {
                    _drawUnderlineWidth = measureText(_splitStrings[i]);

                    if (_hAlign$1 === HorizontalTextAlignment.RIGHT) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth;
                    } else if (_hAlign$1 === HorizontalTextAlignment.CENTER) {
                      _drawUnderlinePos.x = startPosition.x - _drawUnderlineWidth / 2;
                    } else {
                      _drawUnderlinePos.x = startPosition.x;
                    }

                    _drawUnderlinePos.y = drawTextPosY + _drawFontsize / 8;

                    _context.fillRect(_drawUnderlinePos.x, _drawUnderlinePos.y, _drawUnderlineWidth, _underlineThickness);
                  }
                }

                if (isMultiple) {
                  _context.shadowColor = 'transparent';
                }
              },
              _updateLabelDimensions: function _updateLabelDimensions() {
                _canvasSize.width = Math.min(_canvasSize.width, MAX_SIZE);
                _canvasSize.height = Math.min(_canvasSize.height, MAX_SIZE);
                var recreate = false;

                if (_canvas.width !== _canvasSize.width) {
                  _canvas.width = _canvasSize.width;
                  recreate = true;
                }

                if (_canvas.height !== _canvasSize.height) {
                  _canvas.height = _canvasSize.height;
                  recreate = true;
                }

                if (recreate) _context.font = _fontDesc;
                _context.textAlign = Alignment[_hAlign$1];
                _context.textBaseline = 'alphabetic';
              },
              _getFontDesc: function _getFontDesc() {
                var fontDesc = _fontSize$1.toString() + "px ";
                fontDesc += _fontFamily;

                if (_isBold) {
                  fontDesc = "bold " + fontDesc;
                }

                if (_isItalic) {
                  fontDesc = "italic " + fontDesc;
                }

                return fontDesc;
              },
              _getLineHeight: function _getLineHeight() {
                var nodeSpacingY = _lineHeight$1;

                if (nodeSpacingY === 0) {
                  nodeSpacingY = _fontSize$1;
                } else {
                  nodeSpacingY = nodeSpacingY * _fontSize$1 / _drawFontsize;
                }

                return nodeSpacingY | 0;
              },
              _calculateParagraphLength: function _calculateParagraphLength(paragraphedStrings, ctx) {
                var paragraphLength = [];

                for (var _iterator = _createForOfIteratorHelperLoose(paragraphedStrings), _step; !(_step = _iterator()).done;) {
                  var para = _step.value;
                  var width = safeMeasureText(ctx, para, _fontDesc);
                  paragraphLength.push(width);
                }

                return paragraphLength;
              },
              _measureText: function _measureText(ctx, fontDesc) {
                return function (string) {
                  return safeMeasureText(ctx, string, fontDesc);
                };
              },
              _calculateShrinkFont: function _calculateShrinkFont(paragraphedStrings) {
                if (!_context) return;

                var paragraphLength = this._calculateParagraphLength(paragraphedStrings, _context);

                var i = 0;
                var totalHeight = 0;
                var maxLength = 0;

                if (_isWrapText$1) {
                  var canvasWidthNoMargin = _nodeContentSize.width;
                  var canvasHeightNoMargin = _nodeContentSize.height;

                  if (canvasWidthNoMargin < 0 || canvasHeightNoMargin < 0) {
                    return;
                  }

                  totalHeight = canvasHeightNoMargin + 1;
                  var actualFontSize = _fontSize$1 + 1;
                  var textFragment = [];
                  var left = 0;
                  var right = actualFontSize | 0;
                  var mid = 0;

                  while (left < right) {
                    mid = left + right + 1 >> 1;

                    if (mid <= 0) {
                      logID(4003);
                      break;
                    }

                    _fontSize$1 = mid;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;

                    var lineHeight = this._getLineHeight();

                    totalHeight = 0;

                    for (i = 0; i < paragraphedStrings.length; ++i) {
                      var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                      textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                      totalHeight += textFragment.length * lineHeight;
                    }

                    if (totalHeight > canvasHeightNoMargin) {
                      right = mid - 1;
                    } else {
                      left = mid;
                    }
                  }

                  if (left === 0) {
                    logID(4003);
                  } else {
                    _fontSize$1 = left;
                    _fontDesc = this._getFontDesc();
                    _context.font = _fontDesc;
                  }
                } else {
                  totalHeight = paragraphedStrings.length * this._getLineHeight();

                  for (i = 0; i < paragraphedStrings.length; ++i) {
                    if (maxLength < paragraphLength[i]) {
                      maxLength = paragraphLength[i];
                    }
                  }

                  var scaleX = (_canvasSize.width - _canvasPadding.width) / maxLength;
                  var scaleY = _canvasSize.height / totalHeight;
                  _fontSize$1 = _drawFontsize * Math.min(1, scaleX, scaleY) | 0;
                  _fontDesc = this._getFontDesc();
                  _context.font = _fontDesc;
                }
              },
              _calculateWrapText: function _calculateWrapText(paragraphedStrings) {
                if (!_isWrapText$1 || !_context) return;
                _splitStrings = [];
                var canvasWidthNoMargin = _nodeContentSize.width;

                for (var i = 0; i < paragraphedStrings.length; ++i) {
                  var allWidth = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                  var textFragment = fragmentText(paragraphedStrings[i], allWidth, canvasWidthNoMargin, this._measureText(_context, _fontDesc));
                  _splitStrings = _splitStrings.concat(textFragment);
                }
              },
              _calculateLabelFont: function _calculateLabelFont() {
                if (!_context) {
                  return;
                }

                var paragraphedStrings = _string$1.split('\n');

                _splitStrings = paragraphedStrings;
                _fontDesc = this._getFontDesc();
                _context.font = _fontDesc;

                switch (_overflow$1) {
                  case Overflow$1.NONE:
                    {
                      var canvasSizeX = 0;
                      var canvasSizeY = 0;

                      for (var i = 0; i < paragraphedStrings.length; ++i) {
                        var paraLength = safeMeasureText(_context, paragraphedStrings[i], _fontDesc);
                        canvasSizeX = canvasSizeX > paraLength ? canvasSizeX : paraLength;
                      }

                      canvasSizeY = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();
                      var rawWidth = parseFloat(canvasSizeX.toFixed(2));
                      var rawHeight = parseFloat(canvasSizeY.toFixed(2));
                      _canvasSize.width = rawWidth + _canvasPadding.width;
                      _canvasSize.height = rawHeight + _canvasPadding.height;
                      _nodeContentSize.width = rawWidth + _contentSizeExtend.width;
                      _nodeContentSize.height = rawHeight + _contentSizeExtend.height;
                      break;
                    }

                  case Overflow$1.SHRINK:
                    {
                      this._calculateShrinkFont(paragraphedStrings);

                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.CLAMP:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      break;
                    }

                  case Overflow$1.RESIZE_HEIGHT:
                    {
                      this._calculateWrapText(paragraphedStrings);

                      var _rawHeight = (_splitStrings.length + BASELINE_RATIO) * this._getLineHeight();

                      _canvasSize.height = _rawHeight + _canvasPadding.height;
                      _nodeContentSize.height = _rawHeight + _contentSizeExtend.height;
                      break;
                    }
                }
              }
            };

            var WHITE$2 = Color.WHITE.clone();
            var ttf = {
              createData: function createData(comp) {
                var renderData = comp.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                var vData = renderData.vData = new Float32Array(4 * 9);
                vData[3] = vData[21] = vData[22] = vData[31] = 0;
                vData[4] = vData[12] = vData[13] = vData[30] = 1;
                var offset = 5;

                for (var i = 0; i < 4; i++) {
                  Color.toArray(vData, WHITE$2, offset);
                  offset += 9;
                }

                return renderData;
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var renderData = comp.renderData;
                var dataList = renderData.data;
                var node = comp.node;
                var buffer = renderer.acquireBufferBatch();
                var vertexOffset = buffer.byteOffset >> 2;
                var indicesOffset = buffer.indicesOffset;
                var vertexId = buffer.vertexOffset;
                var isRecreate = buffer.request();

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  indicesOffset = 0;
                  vertexId = 0;
                  vertexOffset = 0;
                }

                var vBuf = buffer.vData;
                var iBuf = buffer.iData;
                var vData = renderData.vData;
                var data0 = dataList[0];
                var data3 = dataList[3];
                node.updateWorldTransform();
                var pos = node._pos;
                var rot = node._rot;
                var scale = node._scale;
                var ax = data0.x * scale.x;
                var bx = data3.x * scale.x;
                var ay = data0.y * scale.y;
                var by = data3.y * scale.y;
                var qx = rot.x;
                var qy = rot.y;
                var qz = rot.z;
                var qw = rot.w;
                var qxy = qx * qy;
                var qzw = qz * qw;
                var qxy2 = qx * qx - qy * qy;
                var qzw2 = qw * qw - qz * qz;
                var cx1 = qzw2 + qxy2;
                var cx2 = (qxy - qzw) * 2;
                var cy1 = qzw2 - qxy2;
                var cy2 = (qxy + qzw) * 2;
                var x = pos.x;
                var y = pos.y;
                vData[0] = cx1 * ax + cx2 * ay + x;
                vData[1] = cy1 * ay + cy2 * ax + y;
                vData[9] = cx1 * bx + cx2 * ay + x;
                vData[10] = cy1 * ay + cy2 * bx + y;
                vData[18] = cx1 * ax + cx2 * by + x;
                vData[19] = cy1 * by + cy2 * ax + y;
                vData[27] = cx1 * bx + cx2 * by + x;
                vData[28] = cy1 * by + cy2 * bx + y;
                vBuf.set(vData, vertexOffset);
                iBuf[indicesOffset++] = vertexId;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 3;
              },
              updateVertexData: function updateVertexData(comp) {
                var renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                var uiTrans = comp.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var data = renderData.data;
                data[0].x = -appX;
                data[0].y = -appY;
                data[3].x = width - appX;
                data[3].y = height - appY;
              },
              updateUvs: function updateUvs(comp) {
                var renderData = comp.renderData;

                if (!renderData) {
                  return;
                }

                var vData = renderData.vData;

                if (!vData || !renderData.uvDirty) {
                  return;
                }

                var uv = comp.ttfSpriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
                renderData.uvDirty = false;
              }
            };
            addon(ttf, ttfUtils);

            var labelAssembler = exports('labelAssembler', {
              getAssembler: function getAssembler(comp) {
                var assembler = ttf;

                if (comp.font instanceof BitmapFont) {
                  assembler = bmfont;
                } else if (comp.cacheMode === Label.CacheMode.CHAR) {
                  assembler = letter;
                }

                return assembler;
              }
            });
            Label.Assembler = labelAssembler;

            var FillType$1 = Sprite.FillType;
            var matrix = new Mat4();
            var barFilled = {
              useModel: false,
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  var uvDirty = renderData.uvDirty;
                  var vertDirty = renderData.vertDirty;

                  if (!uvDirty && !vertDirty) {
                    return;
                  }

                  var fillStart = sprite.fillStart;
                  var fillRange = sprite.fillRange;

                  if (fillRange < 0) {
                    fillStart += fillRange;
                    fillRange = -fillRange;
                  }

                  fillRange = fillStart + fillRange;
                  fillStart = fillStart > 1.0 ? 1.0 : fillStart;
                  fillStart = fillStart < 0.0 ? 0.0 : fillStart;
                  fillRange = fillRange > 1.0 ? 1.0 : fillRange;
                  fillRange = fillRange < 0.0 ? 0.0 : fillRange;
                  fillRange -= fillStart;
                  fillRange = fillRange < 0 ? 0 : fillRange;
                  var fillEnd = fillStart + fillRange;
                  fillEnd = fillEnd > 1 ? 1 : fillEnd;

                  if (uvDirty) {
                    this.updateUVs(sprite, fillStart, fillEnd);
                  }

                  if (vertDirty) {
                    if (this.updateVertexData) {
                      this.updateVertexData(sprite, fillStart, fillEnd);
                    }

                    this.updateWorldVertexData(sprite);
                  }
                }
              },
              updateUVs: function updateUVs(sprite, fillStart, fillEnd) {
                var spriteFrame = sprite.spriteFrame;
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var atlasWidth = spriteFrame.width;
                var atlasHeight = spriteFrame.height;
                var textureRect = spriteFrame.getRect();
                var ul = 0;
                var vb = 0;
                var ur = 0;
                var vt = 0;
                var quadUV0 = 0;
                var quadUV1 = 0;
                var quadUV2 = 0;
                var quadUV3 = 0;
                var quadUV4 = 0;
                var quadUV5 = 0;
                var quadUV6 = 0;
                var quadUV7 = 0;

                if (spriteFrame.isRotated()) {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.width) / atlasHeight;
                  ur = (textureRect.x + textureRect.height) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV2 = ul;
                  quadUV4 = quadUV6 = ur;
                  quadUV3 = quadUV7 = vb;
                  quadUV1 = quadUV5 = vt;
                } else {
                  ul = textureRect.x / atlasWidth;
                  vb = (textureRect.y + textureRect.height) / atlasHeight;
                  ur = (textureRect.x + textureRect.width) / atlasWidth;
                  vt = textureRect.y / atlasHeight;
                  quadUV0 = quadUV4 = ul;
                  quadUV2 = quadUV6 = ur;
                  quadUV1 = quadUV3 = vb;
                  quadUV5 = quadUV7 = vt;
                }

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    dataList[0].u = quadUV0 + (quadUV2 - quadUV0) * fillStart;
                    dataList[0].v = quadUV1 + (quadUV3 - quadUV1) * fillStart;
                    dataList[1].u = quadUV0 + (quadUV2 - quadUV0) * fillEnd;
                    dataList[1].v = quadUV1 + (quadUV3 - quadUV1) * fillEnd;
                    dataList[2].u = quadUV4 + (quadUV6 - quadUV4) * fillStart;
                    dataList[2].v = quadUV5 + (quadUV7 - quadUV5) * fillStart;
                    dataList[3].u = quadUV4 + (quadUV6 - quadUV4) * fillEnd;
                    dataList[3].v = quadUV5 + (quadUV7 - quadUV5) * fillEnd;
                    break;

                  case FillType$1.VERTICAL:
                    dataList[0].u = quadUV0 + (quadUV4 - quadUV0) * fillStart;
                    dataList[0].v = quadUV1 + (quadUV5 - quadUV1) * fillStart;
                    dataList[1].u = quadUV2 + (quadUV6 - quadUV2) * fillStart;
                    dataList[1].v = quadUV3 + (quadUV7 - quadUV3) * fillStart;
                    dataList[2].u = quadUV0 + (quadUV4 - quadUV0) * fillEnd;
                    dataList[2].v = quadUV1 + (quadUV5 - quadUV1) * fillEnd;
                    dataList[3].u = quadUV2 + (quadUV6 - quadUV2) * fillEnd;
                    dataList[3].v = quadUV3 + (quadUV7 - quadUV3) * fillEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }

                renderData.uvDirty = false;
              },
              updateVertexData: function updateVertexData(sprite, fillStart, fillEnd) {
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var l = -appX;
                var b = -appY;
                var r = width - appX;
                var t = height - appY;
                var progressStart = 0;
                var progressEnd = 0;

                switch (sprite.fillType) {
                  case FillType$1.HORIZONTAL:
                    progressStart = l + (r - l) * fillStart;
                    progressEnd = l + (r - l) * fillEnd;
                    l = progressStart;
                    r = progressEnd;
                    break;

                  case FillType$1.VERTICAL:
                    progressStart = b + (t - b) * fillStart;
                    progressEnd = b + (t - b) * fillEnd;
                    b = progressStart;
                    t = progressEnd;
                    break;

                  default:
                    errorID(2626);
                    break;
                }

                dataList[4].x = l;
                dataList[4].y = b;
                dataList[5].x = r;
                dataList[5].y = b;
                dataList[6].x = l;
                dataList[6].y = t;
                dataList[7].x = r;
                dataList[7].y = t;
                renderData.vertDirty = false;
              },
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 8;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                var dataList = renderData.data;

                for (var _iterator = _createForOfIteratorHelperLoose(dataList), _step; !(_step = _iterator()).done;) {
                  var data = _step.value;
                  data.z = 0;
                }

                return renderData;
              },
              updateWorldVertexData: function updateWorldVertexData(sprite) {
                var node = sprite.node;
                var dataList = sprite.renderData.data;
                node.getWorldMatrix(matrix);

                for (var i = 0; i < 4; i++) {
                  var local = dataList[i + 4];
                  var world = dataList[i];
                  Vec3.transformMat4(world, local, matrix);
                }
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                if (sprite.node.hasChangedFlags) {
                  this.updateWorldVertexData(sprite);
                }

                var node = sprite.node;
                fillVerticesWithoutCalc3D(node, renderer, sprite.renderData, sprite.color);
              }
            };

            var PI_2 = Math.PI * 2;
            var EPSILON = 1e-6;
            var _vertPos = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            var _vertices = new Array(4);

            var _uvs = new Array(8);

            var _intersectPoint_1 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];
            var _intersectPoint_2 = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            var _center = new Vec2();

            var _triangles = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];

            function _calcIntersectedPoints(left, right, bottom, top, center, angle, intersectPoints) {
              var sinAngle = Math.sin(angle);
              sinAngle = Math.abs(sinAngle) > EPSILON ? sinAngle : 0;
              var cosAngle = Math.cos(angle);
              cosAngle = Math.abs(cosAngle) > EPSILON ? cosAngle : 0;
              var tanAngle = 0;
              var cotAngle = 0;

              if (cosAngle !== 0) {
                tanAngle = sinAngle / cosAngle;

                if ((left - center.x) * cosAngle > 0) {
                  var yLeft = center.y + tanAngle * (left - center.x);
                  intersectPoints[0].x = left;
                  intersectPoints[0].y = yLeft;
                }

                if ((right - center.x) * cosAngle > 0) {
                  var yRight = center.y + tanAngle * (right - center.x);
                  intersectPoints[2].x = right;
                  intersectPoints[2].y = yRight;
                }
              }

              if (sinAngle !== 0) {
                cotAngle = cosAngle / sinAngle;

                if ((top - center.y) * sinAngle > 0) {
                  var xTop = center.x + cotAngle * (top - center.y);
                  intersectPoints[3].x = xTop;
                  intersectPoints[3].y = top;
                }

                if ((bottom - center.y) * sinAngle > 0) {
                  var xBottom = center.x + cotAngle * (bottom - center.y);
                  intersectPoints[1].x = xBottom;
                  intersectPoints[1].y = bottom;
                }
              }
            }

            function _calculateVertices(sprite) {
              var uiTrans = sprite.node._uiProps.uiTransformComp;
              var width = uiTrans.width;
              var height = uiTrans.height;
              var appX = uiTrans.anchorX * width;
              var appY = uiTrans.anchorY * height;
              var l = -appX;
              var b = -appY;
              var r = width - appX;
              var t = height - appY;
              var vertices = _vertices;
              vertices[0] = l;
              vertices[1] = b;
              vertices[2] = r;
              vertices[3] = t;
              var fillCenter = sprite.fillCenter;
              var cx = _center.x = Math.min(Math.max(0, fillCenter.x), 1) * (r - l) + l;
              var cy = _center.y = Math.min(Math.max(0, fillCenter.y), 1) * (t - b) + b;
              _vertPos[0].x = _vertPos[3].x = l;
              _vertPos[1].x = _vertPos[2].x = r;
              _vertPos[0].y = _vertPos[1].y = b;
              _vertPos[2].y = _vertPos[3].y = t;

              for (var _iterator = _createForOfIteratorHelperLoose(_triangles), _step; !(_step = _iterator()).done;) {
                var num = _step.value;
                Vec2.set(num, 0, 0);
              }

              if (cx !== vertices[0]) {
                Vec2.set(_triangles[0], 3, 0);
              }

              if (cx !== vertices[2]) {
                Vec2.set(_triangles[2], 1, 2);
              }

              if (cy !== vertices[1]) {
                Vec2.set(_triangles[1], 0, 1);
              }

              if (cy !== vertices[3]) {
                Vec2.set(_triangles[3], 2, 3);
              }
            }

            function _calculateUVs(spriteFrame) {
              var atlasWidth = spriteFrame.width;
              var atlasHeight = spriteFrame.height;
              var textureRect = spriteFrame.getRect();
              var u0 = 0;
              var u1 = 0;
              var v0 = 0;
              var v1 = 0;
              var uvs = _uvs;

              if (spriteFrame.isRotated()) {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.height) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.width) / atlasHeight;
                uvs[0] = uvs[2] = u0;
                uvs[4] = uvs[6] = u1;
                uvs[3] = uvs[7] = v1;
                uvs[1] = uvs[5] = v0;
              } else {
                u0 = textureRect.x / atlasWidth;
                u1 = (textureRect.x + textureRect.width) / atlasWidth;
                v0 = textureRect.y / atlasHeight;
                v1 = (textureRect.y + textureRect.height) / atlasHeight;
                uvs[0] = uvs[4] = u0;
                uvs[2] = uvs[6] = u1;
                uvs[1] = uvs[3] = v1;
                uvs[5] = uvs[7] = v0;
              }
            }

            function _getVertAngle(start, end) {
              var placementX = end.x - start.x;
              var placementY = end.y - start.y;

              if (placementX === 0 && placementY === 0) {
                return 0;
              } else if (placementX === 0) {
                if (placementY > 0) {
                  return Math.PI * 0.5;
                } else {
                  return Math.PI * 1.5;
                }
              } else {
                var angle = Math.atan(placementY / placementX);

                if (placementX < 0) {
                  angle += Math.PI;
                }

                return angle;
              }
            }

            function _generateTriangle(dataList, offset, vert0, vert1, vert2) {
              var vertices = _vertices;
              var v0x = vertices[0];
              var v0y = vertices[1];
              var v1x = vertices[2];
              var v1y = vertices[3];
              dataList[offset].x = vert0.x;
              dataList[offset].y = vert0.y;
              dataList[offset + 1].x = vert1.x;
              dataList[offset + 1].y = vert1.y;
              dataList[offset + 2].x = vert2.x;
              dataList[offset + 2].y = vert2.y;
              var progressX = 0;
              var progressY = 0;
              progressX = (vert0.x - v0x) / (v1x - v0x);
              progressY = (vert0.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset);

              progressX = (vert1.x - v0x) / (v1x - v0x);
              progressY = (vert1.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 1);

              progressX = (vert2.x - v0x) / (v1x - v0x);
              progressY = (vert2.y - v0y) / (v1y - v0y);

              _generateUV(progressX, progressY, dataList, offset + 2);
            }

            function _generateUV(progressX, progressY, data, offset) {
              var uvs = _uvs;
              var px1 = uvs[0] + (uvs[2] - uvs[0]) * progressX;
              var px2 = uvs[4] + (uvs[6] - uvs[4]) * progressX;
              var py1 = uvs[1] + (uvs[3] - uvs[1]) * progressX;
              var py2 = uvs[5] + (uvs[7] - uvs[5]) * progressX;
              var uv = data[offset];
              uv.u = px1 + (px2 - px1) * progressY;
              uv.v = py1 + (py2 - py1) * progressY;
            }

            var radialFilled = {
              useModel: false,
              createData: function createData(sprite) {
                return sprite.requestRenderData();
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  if (renderData.vertDirty || renderData.uvDirty) {
                    var dataList = renderData.data;
                    var fillStart = sprite.fillStart;
                    var fillRange = sprite.fillRange;

                    if (fillRange < 0) {
                      fillStart += fillRange;
                      fillRange = -fillRange;
                    }

                    while (fillStart >= 1.0) {
                      fillStart -= 1.0;
                    }

                    while (fillStart < 0.0) {
                      fillStart += 1.0;
                    }

                    fillStart *= PI_2;
                    fillRange *= PI_2;
                    var fillEnd = fillStart + fillRange;

                    _calculateVertices(sprite);

                    _calculateUVs(frame);

                    _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart, _intersectPoint_1);

                    _calcIntersectedPoints(_vertices[0], _vertices[2], _vertices[1], _vertices[3], _center, fillStart + fillRange, _intersectPoint_2);

                    var offset = 0;

                    for (var triangleIndex = 0; triangleIndex < 4; ++triangleIndex) {
                      var triangle = _triangles[triangleIndex];

                      if (!triangle) {
                        continue;
                      }

                      if (fillRange >= PI_2) {
                        renderData.dataLength = offset + 3;

                        _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);

                        offset += 3;
                        continue;
                      }

                      var startAngle = _getVertAngle(_center, _vertPos[triangle.x]);

                      var endAngle = _getVertAngle(_center, _vertPos[triangle.y]);

                      if (endAngle < startAngle) {
                        endAngle += PI_2;
                      }

                      startAngle -= PI_2;
                      endAngle -= PI_2;

                      for (var testIndex = 0; testIndex < 3; ++testIndex) {
                        if (startAngle >= fillEnd) ; else if (startAngle >= fillStart) {
                          renderData.dataLength = offset + 3;

                          if (endAngle >= fillEnd) {
                            _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _intersectPoint_2[triangleIndex]);
                          } else {
                            _generateTriangle(dataList, offset, _center, _vertPos[triangle.x], _vertPos[triangle.y]);
                          }

                          offset += 3;
                        } else if (endAngle > fillStart) {
                          if (endAngle <= fillEnd) {
                            renderData.dataLength = offset + 3;

                            _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _vertPos[triangle.y]);

                            offset += 3;
                          } else {
                            renderData.dataLength = offset + 3;

                            _generateTriangle(dataList, offset, _center, _intersectPoint_1[triangleIndex], _intersectPoint_2[triangleIndex]);

                            offset += 3;
                          }
                        }

                        startAngle += PI_2;
                        endAngle += PI_2;
                      }
                    }

                    renderData.indicesCount = renderData.vertexCount = offset;
                    renderData.vertDirty = renderData.uvDirty = false;
                  }
                }
              },
              fillBuffers: function fillBuffers(comp, renderer) {
                var node = comp.node;
                var renderData = comp.renderData;
                fillVertices3D(node, renderer, renderData, comp.color);
              }
            };

            var vec3_temps$1 = [];

            for (var i$1 = 0; i$1 < 4; i$1++) {
              vec3_temps$1.push(new Vec3());
            }

            var simple = {
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                renderData.vData = new Float32Array(4 * 9);
                return renderData;
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  if (renderData.vertDirty) {
                    this.updateVertexData(sprite);
                  }

                  if (renderData.uvDirty) {
                    this.updateUvs(sprite);
                  }
                }
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                if (sprite === null) {
                  return;
                }

                var dataList = sprite.renderData.data;
                var node = sprite.node;
                var buffer = renderer.acquireBufferBatch();
                var vertexOffset = buffer.byteOffset >> 2;
                var indicesOffset = buffer.indicesOffset;
                var vertexId = buffer.vertexOffset;
                var isRecreate = buffer.request();

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                var vBuf = buffer.vData;
                var iBuf = buffer.iData;
                var vData = sprite.renderData.vData;
                var data0 = dataList[0];
                var data3 = dataList[3];
                var matrix = node.worldMatrix;
                var a = matrix.m00;
                var b = matrix.m01;
                var c = matrix.m04;
                var d = matrix.m05;
                var tx = matrix.m12;
                var ty = matrix.m13;
                var vl = data0.x;
                var vr = data3.x;
                var vb = data0.y;
                var vt = data3.y;
                var al = a * vl;
                var ar = a * vr;
                var bl = b * vl;
                var br = b * vr;
                var cb = c * vb;
                var ct = c * vt;
                var db = d * vb;
                var dt = d * vt;
                vData[0] = al + cb + tx;
                vData[1] = bl + db + ty;
                vData[9] = ar + cb + tx;
                vData[10] = br + db + ty;
                vData[18] = al + ct + tx;
                vData[19] = bl + dt + ty;
                vData[27] = ar + ct + tx;
                vData[28] = br + dt + ty;
                vBuf.set(vData, vertexOffset);
                iBuf[indicesOffset++] = vertexId;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 2;
                iBuf[indicesOffset++] = vertexId + 1;
                iBuf[indicesOffset++] = vertexId + 3;
              },
              updateVertexData: function updateVertexData(sprite) {
                var renderData = sprite.renderData;

                if (!renderData) {
                  return;
                }

                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var dataList = renderData.data;
                var cw = uiTrans.width;
                var ch = uiTrans.height;
                var appX = uiTrans.anchorX * cw;
                var appY = uiTrans.anchorY * ch;
                var l = 0;
                var b = 0;
                var r = 0;
                var t = 0;

                if (sprite.trim) {
                  l = -appX;
                  b = -appY;
                  r = cw - appX;
                  t = ch - appY;
                } else {
                  var frame = sprite.spriteFrame;
                  var originSize = frame.getOriginalSize();
                  var rect = frame.getRect();
                  var ow = originSize.width;
                  var oh = originSize.height;
                  var rw = rect.width;
                  var rh = rect.height;
                  var offset = frame.getOffset();
                  var scaleX = cw / ow;
                  var scaleY = ch / oh;
                  var trimLeft = offset.x + (ow - rw) / 2;
                  var trimRight = offset.x - (ow - rw) / 2;
                  var trimBottom = offset.y + (oh - rh) / 2;
                  var trimTop = offset.y - (oh - rh) / 2;
                  l = trimLeft * scaleX - appX;
                  b = trimBottom * scaleY - appY;
                  r = cw + trimRight * scaleX - appX;
                  t = ch + trimTop * scaleY - appY;
                }

                dataList[0].x = l;
                dataList[0].y = b;
                dataList[0].z = 0;
                dataList[3].x = r;
                dataList[3].y = t;
                dataList[3].z = 0;
                renderData.vertDirty = false;
              },
              updateUvs: function updateUvs(sprite) {
                var renderData = sprite.renderData;
                var vData = renderData.vData;
                var uv = sprite.spriteFrame.uv;
                vData[3] = uv[0];
                vData[4] = uv[1];
                vData[12] = uv[2];
                vData[13] = uv[3];
                vData[21] = uv[4];
                vData[22] = uv[5];
                vData[30] = uv[6];
                vData[31] = uv[7];
                renderData.uvDirty = false;
              },
              updateColor: function updateColor(sprite) {
                var vData = sprite.renderData.vData;
                var colorOffset = 5;
                var color = sprite.color;
                var colorR = color.r / 255;
                var colorG = color.g / 255;
                var colorB = color.b / 255;
                var colorA = color.a / 255;

                for (var _i = 0; _i < 4; _i++) {
                  vData[colorOffset] = colorR;
                  vData[colorOffset + 1] = colorG;
                  vData[colorOffset + 2] = colorB;
                  vData[colorOffset + 3] = colorA;
                  colorOffset += 9;
                }
              }
            };

            var vec3_temp$1 = new Vec3();
            var matrix$1 = new Mat4();
            var sliced = {
              useModel: false,
              createData: function createData(sprite) {
                var renderData = sprite.requestRenderData();
                renderData.dataLength = 20;
                renderData.vertexCount = 16;
                renderData.indicesCount = 54;
                return renderData;
              },
              updateRenderData: function updateRenderData(sprite) {
                var frame = sprite.spriteFrame;
                dynamicAtlasManager.packToDynamicAtlas(sprite, frame);
                var renderData = sprite.renderData;

                if (renderData && frame) {
                  var vertDirty = renderData.vertDirty;

                  if (vertDirty) {
                    this.updateVertexData(sprite);
                    this.updateWorldVertexData(sprite);
                  }
                }
              },
              updateVertexData: function updateVertexData(sprite) {
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var width = uiTrans.width;
                var height = uiTrans.height;
                var appX = uiTrans.anchorX * width;
                var appY = uiTrans.anchorY * height;
                var frame = sprite.spriteFrame;
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var sizableWidth = width - leftWidth - rightWidth;
                var sizableHeight = height - topHeight - bottomHeight;
                var xScale = width / (leftWidth + rightWidth);
                var yScale = height / (topHeight + bottomHeight);
                xScale = Number.isNaN(xScale) || xScale > 1 ? 1 : xScale;
                yScale = Number.isNaN(yScale) || yScale > 1 ? 1 : yScale;
                sizableWidth = sizableWidth < 0 ? 0 : sizableWidth;
                sizableHeight = sizableHeight < 0 ? 0 : sizableHeight;
                dataList[0].x = -appX;
                dataList[0].y = -appY;
                dataList[1].x = leftWidth * xScale - appX;
                dataList[1].y = bottomHeight * yScale - appY;
                dataList[2].x = dataList[1].x + sizableWidth;
                dataList[2].y = dataList[1].y + sizableHeight;
                dataList[3].x = width - appX;
                dataList[3].y = height - appY;
                renderData.vertDirty = false;
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                if (sprite.node.hasChangedFlags) {
                  this.updateWorldVertexData(sprite);
                }

                var buffer = renderer.acquireBufferBatch();
                var renderData = sprite.renderData;
                var dataList = renderData.data;
                var vertexOffset = buffer.byteOffset >> 2;
                var vertexCount = renderData.vertexCount;
                var indicesOffset = buffer.indicesOffset;
                var vertexId = buffer.vertexOffset;
                var uvSliced = sprite.spriteFrame.uvSliced;
                var isRecreate = buffer.request(vertexCount, renderData.indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                var vBuf = buffer.vData;
                var iBuf = buffer.iData;

                for (var i = 4; i < 20; ++i) {
                  var vert = dataList[i];
                  var uvs = uvSliced[i - 4];
                  vBuf[vertexOffset++] = vert.x;
                  vBuf[vertexOffset++] = vert.y;
                  vBuf[vertexOffset++] = vert.z;
                  vBuf[vertexOffset++] = uvs.u;
                  vBuf[vertexOffset++] = uvs.v;
                  Color.toArray(vBuf, sprite.color, vertexOffset);
                  vertexOffset += 4;
                }

                for (var r = 0; r < 3; ++r) {
                  for (var c = 0; c < 3; ++c) {
                    var start = vertexId + r * 4 + c;
                    iBuf[indicesOffset++] = start;
                    iBuf[indicesOffset++] = start + 1;
                    iBuf[indicesOffset++] = start + 4;
                    iBuf[indicesOffset++] = start + 1;
                    iBuf[indicesOffset++] = start + 5;
                    iBuf[indicesOffset++] = start + 4;
                  }
                }
              },
              updateWorldVertexData: function updateWorldVertexData(sprite) {
                var node = sprite.node;
                var dataList = sprite.renderData.data;
                node.getWorldMatrix(matrix$1);

                for (var row = 0; row < 4; ++row) {
                  var rowD = dataList[row];

                  for (var col = 0; col < 4; ++col) {
                    var colD = dataList[col];
                    var world = dataList[4 + row * 4 + col];
                    Vec3.set(vec3_temp$1, colD.x, rowD.y, 0);
                    Vec3.transformMat4(world, vec3_temp$1, matrix$1);
                  }
                }
              }
            };

            var vec3_temps$2 = [];

            for (var i$2 = 0; i$2 < 4; i$2++) {
              vec3_temps$2.push(new Vec3());
            }

            var _perVertexLength = 9;
            var tiled = {
              useModel: false,
              sizableWidth: 0,
              sizableHeight: 0,
              vRepeat: 0,
              hRepeat: 0,
              row: 0,
              col: 0,
              createData: function createData(sprite) {
                return sprite.requestRenderData();
              },
              updateRenderData: function updateRenderData(sprite) {
                var renderData = sprite.renderData;
                var frame = sprite.spriteFrame;

                if (!frame || !renderData || !(renderData.uvDirty || renderData.vertDirty)) {
                  return;
                }

                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var contentWidth = Math.abs(uiTrans.width);
                var contentHeight = Math.abs(uiTrans.height);
                var rect = frame.getRect();
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var centerHeight = rect.height - topHeight - bottomHeight;
                this.sizableWidth = contentWidth - leftWidth - rightWidth;
                this.sizableHeight = contentHeight - topHeight - bottomHeight;
                this.sizableWidth = this.sizableWidth > 0 ? this.sizableWidth : 0;
                this.sizableHeight = this.sizableHeight > 0 ? this.sizableHeight : 0;
                this.hRepeat = centerWidth === 0 ? this.sizableWidth : this.sizableWidth / centerWidth;
                this.vRepeat = centerHeight === 0 ? this.sizableHeight : this.sizableHeight / centerHeight;
                this.row = Math.ceil(this.vRepeat + 2);
                this.col = Math.ceil(this.hRepeat + 2);
                renderData.dataLength = Math.max(8, this.row + 1, this.col + 1);
                this.updateVerts(sprite);
                renderData.vertexCount = this.row * this.col * 4;
                renderData.indicesCount = this.row * this.col * 6;
                renderData.uvDirty = false;
                renderData.vertDirty = false;
              },
              fillBuffers: function fillBuffers(sprite, renderer) {
                var node = sprite.node;
                var renderData = sprite.renderData;
                var buffer = renderer.acquireBufferBatch();
                var indicesOffset = buffer.indicesOffset;
                var vertexOffset = buffer.byteOffset >> 2;
                var vertexId = buffer.vertexOffset;
                var vertexCount = renderData.vertexCount;
                var indicesCount = renderData.indicesCount;
                var vBuf = buffer.vData;
                var iBuf = buffer.iData;
                var isRecreate = buffer.request(vertexCount, indicesCount);

                if (!isRecreate) {
                  buffer = renderer.currBufferBatch;
                  vertexOffset = 0;
                  indicesOffset = 0;
                  vertexId = 0;
                }

                var frame = sprite.spriteFrame;
                var rotated = frame.isRotated();
                var uv = frame.uv;
                var uvSliced = frame.uvSliced;
                var rect = frame.getRect();
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var centerHeight = rect.height - topHeight - bottomHeight;
                var matrix = node.worldMatrix;
                this.fillVertices(vBuf, vertexOffset, matrix, this.row, this.col, renderData.data);
                var offset = _perVertexLength;
                var offset1 = offset;
                var offset2 = offset * 2;
                var offset3 = offset * 3;
                var offset4 = offset * 4;
                var coefU = 0;
                var coefV = 0;

                for (var yIndex = 0, yLength = this.row; yIndex < yLength; ++yIndex) {
                  if (this.sizableHeight > centerHeight) {
                    if (this.sizableHeight >= yIndex * centerHeight) {
                      coefV = 1;
                    } else {
                      coefV = this.vRepeat % 1;
                    }
                  } else {
                    coefV = this.vRepeat;
                  }

                  for (var xIndex = 0, xLength = this.col; xIndex < xLength; ++xIndex) {
                    if (this.sizableWidth > centerWidth) {
                      if (this.sizableWidth >= xIndex * centerWidth) {
                        coefU = 1;
                      } else {
                        coefU = this.hRepeat % 1;
                      }
                    } else {
                      coefU = this.hRepeat;
                    }

                    var vertexOffsetU = vertexOffset + 3;
                    var vertexOffsetV = vertexOffsetU + 1;

                    if (rotated) {
                      vBuf[vertexOffsetU] = uv[0];
                      vBuf[vertexOffsetV] = uv[1];
                      vBuf[vertexOffsetU + offset1] = uv[0];
                      vBuf[vertexOffsetV + offset1] = uv[1] + (uv[7] - uv[1]) * coefU;
                      vBuf[vertexOffsetU + offset2] = uv[0] + (uv[6] - uv[0]) * coefV;
                      vBuf[vertexOffsetV + offset2] = uv[1];
                      vBuf[vertexOffsetU + offset3] = vBuf[vertexOffsetU + offset2];
                      vBuf[vertexOffsetV + offset3] = vBuf[vertexOffsetV + offset1];
                    } else {
                      if (xIndex === 0) {
                        vBuf[vertexOffsetU] = uv[0];
                      } else if (xIndex > 0 && xIndex < this.col - 1) {
                        vBuf[vertexOffsetU] = uvSliced[1].u;
                      } else if (xIndex === this.col - 1) {
                        vBuf[vertexOffsetU] = uvSliced[2].u;
                      }

                      if (yIndex === 0) {
                        vBuf[vertexOffsetV] = uvSliced[0].v;
                      } else if (yIndex > 0 && yIndex < this.row - 1) {
                        vBuf[vertexOffsetV] = uvSliced[4].v;
                      } else if (yIndex === this.row - 1) {
                        vBuf[vertexOffsetV] = uvSliced[8].v;
                      }

                      if (xIndex === 0) {
                        vBuf[vertexOffsetU + offset1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                      } else if (xIndex > 0 && xIndex < this.col - 1) {
                        vBuf[vertexOffsetU + offset1] = uvSliced[1].u + (uvSliced[2].u - uvSliced[1].u) * coefU;
                      } else if (xIndex === this.col - 1) {
                        vBuf[vertexOffsetU + offset1] = uvSliced[3].u;
                      }

                      if (yIndex === 0) {
                        vBuf[vertexOffsetV + offset1] = uvSliced[0].v;
                      } else if (yIndex > 0 && yIndex < this.row - 1) {
                        vBuf[vertexOffsetV + offset1] = uvSliced[4].v;
                      } else if (yIndex === this.row - 1) {
                        vBuf[vertexOffsetV + offset1] = uvSliced[8].v;
                      }

                      if (xIndex === 0) {
                        vBuf[vertexOffsetU + offset2] = uv[0];
                      } else if (xIndex > 0 && xIndex < this.col - 1) {
                        vBuf[vertexOffsetU + offset2] = uvSliced[1].u;
                      } else if (xIndex === this.col - 1) {
                        vBuf[vertexOffsetU + offset2] = uvSliced[2].u;
                      }

                      if (yIndex === 0) {
                        vBuf[vertexOffsetV + offset2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                      } else if (yIndex > 0 && yIndex < this.row - 1) {
                        vBuf[vertexOffsetV + offset2] = uvSliced[4].v + (uvSliced[8].v - uvSliced[4].v) * coefV;
                      } else if (yIndex === this.row - 1) {
                        vBuf[vertexOffsetV + offset2] = uvSliced[12].v;
                      }

                      vBuf[vertexOffsetU + offset3] = vBuf[vertexOffsetU + offset1];
                      vBuf[vertexOffsetV + offset3] = vBuf[vertexOffsetV + offset2];
                    }

                    Color.toArray(vBuf, sprite.color, vertexOffsetV + 1);
                    Color.toArray(vBuf, sprite.color, vertexOffsetV + offset1 + 1);
                    Color.toArray(vBuf, sprite.color, vertexOffsetV + offset2 + 1);
                    Color.toArray(vBuf, sprite.color, vertexOffsetV + offset3 + 1);
                    vertexOffset += offset4;
                  }
                }

                for (var _i = 0; _i < indicesCount; _i += 6) {
                  iBuf[indicesOffset++] = vertexId;
                  iBuf[indicesOffset++] = vertexId + 1;
                  iBuf[indicesOffset++] = vertexId + 2;
                  iBuf[indicesOffset++] = vertexId + 1;
                  iBuf[indicesOffset++] = vertexId + 3;
                  iBuf[indicesOffset++] = vertexId + 2;
                  vertexId += 4;
                }
              },
              fillVertices: function fillVertices(vBuf, vertexOffset, matrix, row, col, dataList) {
                var x = 0;
                var x1 = 0;
                var y = 0;
                var y1 = 0;

                for (var yIndex = 0, yLength = row; yIndex < yLength; ++yIndex) {
                  y = dataList[yIndex].y;
                  y1 = dataList[yIndex + 1].y;

                  for (var xIndex = 0, xLength = col; xIndex < xLength; ++xIndex) {
                    x = dataList[xIndex].x;
                    x1 = dataList[xIndex + 1].x;
                    Vec3.set(vec3_temps$2[0], x, y, 0);
                    Vec3.set(vec3_temps$2[1], x1, y, 0);
                    Vec3.set(vec3_temps$2[2], x, y1, 0);
                    Vec3.set(vec3_temps$2[3], x1, y1, 0);

                    for (var _i2 = 0; _i2 < 4; _i2++) {
                      var vec3_temp = vec3_temps$2[_i2];
                      Vec3.transformMat4(vec3_temp, vec3_temp, matrix);
                      var offset = _i2 * _perVertexLength;
                      vBuf[vertexOffset + offset] = vec3_temp.x;
                      vBuf[vertexOffset + offset + 1] = vec3_temp.y;
                      vBuf[vertexOffset + offset + 2] = vec3_temp.z;
                    }

                    vertexOffset += 36;
                  }
                }
              },
              updateVerts: function updateVerts(sprite) {
                var uiTrans = sprite.node._uiProps.uiTransformComp;
                var data = sprite.renderData.data;
                var frame = sprite.spriteFrame;
                var rect = frame.getRect();
                var contentWidth = Math.abs(uiTrans.width);
                var contentHeight = Math.abs(uiTrans.height);
                var appx = uiTrans.anchorX * contentWidth;
                var appy = uiTrans.anchorY * contentHeight;
                var leftWidth = frame.insetLeft;
                var rightWidth = frame.insetRight;
                var centerWidth = rect.width - leftWidth - rightWidth;
                var topHeight = frame.insetTop;
                var bottomHeight = frame.insetBottom;
                var centerHeight = rect.height - topHeight - bottomHeight;
                var xScale = uiTrans.width / (leftWidth + rightWidth) > 1 ? 1 : uiTrans.width / (leftWidth + rightWidth);
                var yScale = uiTrans.height / (topHeight + bottomHeight) > 1 ? 1 : uiTrans.height / (topHeight + bottomHeight);
                var offsetWidth = 0;
                var offsetHeight = 0;

                if (centerWidth > 0) {
                  offsetWidth = Math.floor(this.sizableWidth * 1000) / 1000 % centerWidth === 0 ? centerWidth : this.sizableWidth % centerWidth;
                } else {
                  offsetWidth = this.sizableWidth;
                }

                if (centerHeight > 0) {
                  offsetHeight = Math.floor(this.sizableHeight * 1000) / 1000 % centerHeight === 0 ? centerHeight : this.sizableHeight % centerHeight;
                } else {
                  offsetHeight = this.sizableHeight;
                }

                for (var _i3 = 0; _i3 <= this.col; _i3++) {
                  if (_i3 === 0) {
                    data[_i3].x = -appx;
                  } else if (_i3 > 0 && _i3 < this.col) {
                    if (_i3 === 1) {
                      data[_i3].x = leftWidth * xScale + Math.min(centerWidth, this.sizableWidth) - appx;
                    } else if (centerWidth > 0) {
                      if (_i3 === this.col - 1) {
                        data[_i3].x = leftWidth + offsetWidth + centerWidth * (_i3 - 2) - appx;
                      } else {
                        data[_i3].x = leftWidth + Math.min(centerWidth, this.sizableWidth) + centerWidth * (_i3 - 2) - appx;
                      }
                    } else {
                      data[_i3].x = leftWidth + this.sizableWidth - appx;
                    }
                  } else if (_i3 === this.col) {
                    data[_i3].x = Math.min(leftWidth + this.sizableWidth + rightWidth, contentWidth) - appx;
                  }
                }

                for (var _i4 = 0; _i4 <= this.row; _i4++) {
                  if (_i4 === 0) {
                    data[_i4].y = -appy;
                  } else if (_i4 > 0 && _i4 < this.row) {
                    if (_i4 === 1) {
                      data[_i4].y = bottomHeight * yScale + Math.min(centerHeight, this.sizableHeight) - appy;
                    } else if (centerHeight > 0) {
                      if (_i4 === this.row - 1) {
                        data[_i4].y = bottomHeight + offsetHeight + (_i4 - 2) * centerHeight - appy;
                      } else {
                        data[_i4].y = bottomHeight + Math.min(centerHeight, this.sizableHeight) + (_i4 - 2) * centerHeight - appy;
                      }
                    } else {
                      data[_i4].y = bottomHeight + this.sizableHeight - appy;
                    }
                  } else if (_i4 === this.row) {
                    data[_i4].y = Math.min(bottomHeight + this.sizableHeight + topHeight, contentHeight) - appy;
                  }
                }
              }
            };

            var SpriteType$1 = Sprite.Type;
            var FillType$2 = Sprite.FillType;
            var spriteAssembler = exports('spriteAssembler', {
              getAssembler: function getAssembler(spriteComp) {
                var util = simple;
                var comp = spriteComp;

                switch (comp.type) {
                  case SpriteType$1.SLICED:
                    util = sliced;
                    break;

                  case SpriteType$1.TILED:
                    util = tiled;
                    break;

                  case SpriteType$1.FILLED:
                    if (comp.fillType === FillType$2.RADIAL) {
                      util = radialFilled;
                    } else {
                      util = barFilled;
                    }

                    break;
                }

                return util;
              }
            });
            Sprite.Assembler = spriteAssembler;

            var _stencilManager = StencilManager.sharedManager;

            function applyClearMask(mask, renderer) {
              _stencilManager.clear(mask);

              renderer.commitModel(mask, mask._clearModel, mask._clearStencilMtl);
            }

            function applyAreaMask(mask, renderer) {
              _stencilManager.enterLevel(mask);

              if (mask.type === MaskType.IMAGE_STENCIL) {
                simple.fillBuffers(mask, renderer);
                var mat = mask.graphics.getMaterialInstance(0);
                renderer.forceMergeBatches(mat, mask.spriteFrame, mask.graphics);
              } else {
                mask.graphics.updateAssembler(renderer);
              }
            }

            var maskAssembler = {
              createData: function createData(mask) {
                var renderData = mask.requestRenderData();
                renderData.dataLength = 4;
                renderData.vertexCount = 4;
                renderData.indicesCount = 6;
                renderData.vData = new Float32Array(4 * 9);
                return renderData;
              },
              updateRenderData: function updateRenderData(mask) {
                if (mask.type === MaskType.IMAGE_STENCIL) {
                  simple.updateRenderData(mask);
                  simple.updateColor(mask);
                }
              },
              fillBuffers: function fillBuffers(mask, renderer) {
                if (mask.type !== MaskType.IMAGE_STENCIL || mask.spriteFrame) {
                  _stencilManager.pushMask(mask);

                  renderer.finishMergeBatches();
                  applyClearMask(mask, renderer);
                  applyAreaMask(mask, renderer);

                  _stencilManager.enableMask();
                }
              }
            };
            var maskEndAssembler = {
              fillBuffers: function fillBuffers(mask, ui) {
                _stencilManager.exitMask();
              }
            };
            var StartAssembler = {
              getAssembler: function getAssembler() {
                return maskAssembler;
              }
            };
            var PostAssembler = {
              getAssembler: function getAssembler() {
                return maskEndAssembler;
              }
            };
            Mask.Assembler = StartAssembler;
            Mask.PostAssembler = PostAssembler;

            var _dsInfo = new DescriptorSetInfo(null);

            var m4_1$5 = new Mat4();
            var Batcher2D = exports('UI', function () {
              var _proto = Batcher2D.prototype;

              _proto.acquireBufferBatch = function acquireBufferBatch(attributes) {
                if (attributes === void 0) {
                  attributes = vfmtPosUvColor;
                }

                var strideBytes = attributes === vfmtPosUvColor ? 36 : getAttributeStride(attributes);

                if (!this._currMeshBuffer || this._currMeshBuffer.vertexFormatBytes !== strideBytes) {
                  this._requireBufferBatch(attributes);

                  return this._currMeshBuffer;
                }

                return this._currMeshBuffer;
              };

              _proto.registerCustomBuffer = function registerCustomBuffer(attributes, callback) {
                var batch;

                if (attributes instanceof MeshBuffer) {
                  batch = attributes;
                } else {
                  batch = this._bufferBatchPool.add();
                  batch.initialize(attributes, callback || this._recreateMeshBuffer.bind(this, attributes));
                }

                var strideBytes = batch.vertexFormatBytes;

                var buffers = this._customMeshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._customMeshBuffers.set(strideBytes, buffers);
                }

                buffers.push(batch);
                return batch;
              };

              _proto.unRegisterCustomBuffer = function unRegisterCustomBuffer(buffer) {
                var buffers = this._customMeshBuffers.get(buffer.vertexFormatBytes);

                if (buffers) {
                  for (var i = 0; i < buffers.length; i++) {
                    if (buffers[i] === buffer) {
                      buffers.splice(i, 1);
                      break;
                    }
                  }
                }
              };

              _createClass(Batcher2D, [{
                key: "currBufferBatch",
                get: function get() {
                  if (this._currMeshBuffer) return this._currMeshBuffer;
                  this._currMeshBuffer = this.acquireBufferBatch();
                  return this._currMeshBuffer;
                },
                set: function set(buffer) {
                  if (buffer) {
                    this._currMeshBuffer = buffer;
                  }
                }
              }, {
                key: "batches",
                get: function get() {
                  return this._batches;
                }
              }, {
                key: "currStaticRoot",
                set: function set(value) {
                  this._currStaticRoot = value;
                }
              }]);

              function Batcher2D(_root) {
                var _this = this;

                this.device = void 0;
                this._screens = [];
                this._bufferBatchPool = new RecyclePool(function () {
                  return new MeshBuffer(_this);
                }, 128);
                this._drawBatchPool = void 0;
                this._meshBuffers = new Map();
                this._customMeshBuffers = new Map();
                this._meshBufferUseCount = new Map();
                this._batches = void 0;
                this._doUploadBuffersCall = new Map();
                this._emptyMaterial = new Material();
                this._currScene = null;
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currSampler = null;
                this._currMeshBuffer = null;
                this._currStaticRoot = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currBlendTargetHash = 0;
                this._currLayer = 0;
                this._currDepthStencilStateStage = null;
                this._parentOpacity = 1;
                this._descriptorSetCache = new DescriptorSetCache();
                this._root = _root;
                this.device = _root.device;
                this._batches = new CachedArray(64);
                this._drawBatchPool = new Pool(function () {
                  return new DrawBatch2D();
                }, 128);
              }

              _proto.initialize = function initialize() {
                return true;
              };

              _proto.destroy = function destroy() {
                var _this2 = this;

                for (var i = 0; i < this._batches.length; i++) {
                  if (this._batches.array[i]) {
                    this._batches.array[i].destroy(this);
                  }
                }

                this._batches.destroy();

                for (var _iterator = _createForOfIteratorHelperLoose(this._meshBuffers.keys()), _step; !(_step = _iterator()).done;) {
                  var size = _step.value;

                  var buffers = this._meshBuffers.get(size);

                  if (buffers) {
                    buffers.forEach(function (buffer) {
                      return buffer.destroy();
                    });
                  }
                }

                if (this._drawBatchPool) {
                  this._drawBatchPool.destroy(function (obj) {
                    obj.destroy(_this2);
                  });
                }

                this._descriptorSetCache.destroy();

                this._meshBuffers.clear();

                StencilManager.sharedManager.destroy();
              };

              _proto.addScreen = function addScreen(comp) {
                this._screens.push(comp);

                this._screens.sort(this._screenSort);
              };

              _proto.getFirstRenderCamera = function getFirstRenderCamera(node) {
                if (node.scene && node.scene.renderScene) {
                  var cameras = node.scene.renderScene.cameras;

                  for (var i = 0; i < cameras.length; i++) {
                    var camera = cameras[i];

                    if (camera.visibility & node.layer) {
                      return camera;
                    }
                  }
                }

                return null;
              };

              _proto.removeScreen = function removeScreen(comp) {
                var idx = this._screens.indexOf(comp);

                if (idx === -1) {
                  return;
                }

                this._screens.splice(idx, 1);
              };

              _proto.sortScreens = function sortScreens() {
                this._screens.sort(this._screenSort);
              };

              _proto.addUploadBuffersFunc = function addUploadBuffersFunc(target, func) {
                this._doUploadBuffersCall.set(target, func);
              };

              _proto.removeUploadBuffersFunc = function removeUploadBuffersFunc(target) {
                this._doUploadBuffersCall["delete"](target);
              };

              _proto.update = function update() {
                var screens = this._screens;

                for (var i = 0; i < screens.length; ++i) {
                  var screen = screens[i];

                  if (!screen.enabledInHierarchy) {
                    continue;
                  }

                  this._recursiveScreenNode(screen.node);
                }

                var batchPriority = 0;

                if (this._batches.length) {
                  for (var _i = 0; _i < this._batches.length; ++_i) {
                    var batch = this._batches.array[_i];
                    if (!batch.renderScene) continue;

                    if (batch.model) {
                      var subModels = batch.model.subModels;

                      for (var j = 0; j < subModels.length; j++) {
                        subModels[j].priority = batchPriority++;
                      }
                    } else {
                      batch.hDescriptorSet = this._descriptorSetCache.getDescriptorSet(batch);
                    }

                    batch.renderScene.addBatch(batch);
                  }
                }
              };

              _proto.uploadBuffers = function uploadBuffers() {
                if (this._batches.length > 0) {
                  var calls = this._doUploadBuffersCall;

                  for (var _iterator2 = _createForOfIteratorHelperLoose(calls.keys()), _step2; !(_step2 = _iterator2()).done;) {
                    var key = _step2.value;
                    var list = calls.get(key);
                    list.call(key, this);
                  }

                  var buffers = this._meshBuffers;

                  for (var _iterator3 = _createForOfIteratorHelperLoose(buffers.keys()), _step3; !(_step3 = _iterator3()).done;) {
                    var i = _step3.value;

                    var _list = buffers.get(i);

                    if (_list) {
                      _list.forEach(function (bb) {
                        bb.uploadBuffers();
                        bb.reset();
                      });
                    }
                  }

                  var customs = this._customMeshBuffers;

                  for (var _iterator4 = _createForOfIteratorHelperLoose(customs.keys()), _step4; !(_step4 = _iterator4()).done;) {
                    var _i2 = _step4.value;

                    var _list2 = customs.get(_i2);

                    if (_list2) {
                      _list2.forEach(function (bb) {
                        bb.uploadBuffers();
                        bb.reset();
                      });
                    }
                  }

                  this._descriptorSetCache.update();
                }
              };

              _proto.reset = function reset() {
                for (var i = 0; i < this._batches.length; ++i) {
                  var batch = this._batches.array[i];

                  if (batch.isStatic) {
                    continue;
                  }

                  batch.clear();

                  this._drawBatchPool.free(batch);
                }

                this._parentOpacity = 1;
                this._currLayer = 0;
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currSampler = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currScene = null;
                this._currMeshBuffer = null;

                this._meshBufferUseCount.clear();

                this._batches.clear();

                StencilManager.sharedManager.reset();

                this._descriptorSetCache.reset();
              };

              _proto.commitComp = function commitComp(comp, frame, assembler, transform) {
                var renderComp = comp;
                var texture;
                var samp;
                var textureHash = 0;
                var samplerHash = 0;

                if (frame) {
                  texture = frame.getGFXTexture();
                  samp = frame.getGFXSampler();
                  textureHash = frame.getHash();
                  samplerHash = frame.getSamplerHash();
                } else {
                  texture = null;
                  samp = null;
                }

                var renderScene = renderComp._getRenderScene();

                var mat = renderComp.getRenderMaterial(0);
                renderComp.stencilStage = StencilManager.sharedManager.stage;
                var blendTargetHash = renderComp.blendHash;
                var depthStencilStateStage = renderComp.stencilStage;

                if (this._currScene !== renderScene || this._currLayer !== comp.node.layer || this._currMaterial !== mat || this._currBlendTargetHash !== blendTargetHash || this._currDepthStencilStateStage !== depthStencilStateStage || this._currTextureHash !== textureHash || this._currSamplerHash !== samplerHash || this._currTransform !== transform) {
                  this.autoMergeBatches(this._currComponent);
                  this._currScene = renderScene;
                  this._currComponent = renderComp;
                  this._currTransform = transform;
                  this._currMaterial = mat;
                  this._currTexture = texture;
                  this._currSampler = samp;
                  this._currTextureHash = textureHash;
                  this._currSamplerHash = samplerHash;
                  this._currBlendTargetHash = blendTargetHash;
                  this._currDepthStencilStateStage = depthStencilStateStage;
                  this._currLayer = comp.node.layer;
                }

                if (assembler) {
                  assembler.fillBuffers(renderComp, this);

                  this._applyOpacity(renderComp);
                }
              };

              _proto.commitModel = function commitModel(comp, model, mat) {
                if (this._currMaterial !== this._emptyMaterial) {
                  this.autoMergeBatches(this._currComponent);
                }

                var depthStencil;
                var dssHash = 0;

                if (mat) {
                  if (comp.stencilStage === Stage.ENABLED || comp.stencilStage === Stage.DISABLED) {
                    comp.stencilStage = StencilManager.sharedManager.stage;
                  }

                  depthStencil = StencilManager.sharedManager.getStencilStage(comp.stencilStage, mat);
                  dssHash = StencilManager.sharedManager.getStencilHash(comp.stencilStage);
                }

                var stamp = legacyCC.director.getTotalFrames();

                if (model) {
                  model.updateTransform(stamp);
                  model.updateUBOs(stamp);
                }

                for (var i = 0; i < model.subModels.length; i++) {
                  var curDrawBatch = this._drawBatchPool.alloc();

                  var subModel = model.subModels[i];
                  curDrawBatch.renderScene = comp._getRenderScene();
                  curDrawBatch.visFlags = comp.node.layer;
                  curDrawBatch.model = model;
                  curDrawBatch.bufferBatch = null;
                  curDrawBatch.texture = null;
                  curDrawBatch.sampler = null;
                  curDrawBatch.useLocalData = null;

                  if (!depthStencil) {
                    depthStencil = null;
                  }

                  curDrawBatch.fillPasses(mat, depthStencil, dssHash, null, 0, subModel.patches);
                  curDrawBatch.hDescriptorSet = SubModelPool.get(subModel.handle, SubModelView.DESCRIPTOR_SET);
                  curDrawBatch.hInputAssembler = SubModelPool.get(subModel.handle, SubModelView.INPUT_ASSEMBLER);
                  curDrawBatch.model.visFlags = curDrawBatch.visFlags;

                  this._batches.push(curDrawBatch);
                }

                this._currMaterial = this._emptyMaterial;
                this._currScene = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTexture = null;
                this._currSampler = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currLayer = 0;
              };

              _proto.commitStaticBatch = function commitStaticBatch(comp) {
                this._batches.concat(comp.drawBatchList);

                this.finishMergeBatches();
              };

              _proto.autoMergeBatches = function autoMergeBatches(renderComp) {
                var buffer = this.currBufferBatch;
                var hIA = buffer === null || buffer === void 0 ? void 0 : buffer.recordBatch();
                var mat = this._currMaterial;

                if (!hIA || !mat || !buffer) {
                  return;
                }

                var blendState;
                var depthStencil;
                var dssHash = 0;
                var bsHash = 0;

                if (renderComp) {
                  blendState = renderComp.blendHash === -1 ? null : renderComp.getBlendState();
                  bsHash = renderComp.blendHash;

                  if (renderComp.customMaterial !== null) {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage, mat);
                  } else {
                    depthStencil = StencilManager.sharedManager.getStencilStage(renderComp.stencilStage);
                  }

                  dssHash = StencilManager.sharedManager.getStencilHash(renderComp.stencilStage);
                }

                var curDrawBatch = this._currStaticRoot ? this._currStaticRoot._requireDrawBatch() : this._drawBatchPool.alloc();
                curDrawBatch.renderScene = this._currScene;
                curDrawBatch.visFlags = this._currLayer;
                curDrawBatch.bufferBatch = buffer;
                curDrawBatch.texture = this._currTexture;
                curDrawBatch.sampler = this._currSampler;
                curDrawBatch.hInputAssembler = hIA;
                curDrawBatch.useLocalData = this._currTransform;
                curDrawBatch.textureHash = this._currTextureHash;
                curDrawBatch.samplerHash = this._currSamplerHash;
                curDrawBatch.fillPasses(mat, depthStencil, dssHash, blendState, bsHash, null);

                this._batches.push(curDrawBatch);

                buffer.vertexStart = buffer.vertexOffset;
                buffer.indicesStart = buffer.indicesOffset;
                buffer.byteStart = buffer.byteOffset;

                if (sys.__isWebIOS14OrIPadOS14Env) {
                  this._currMeshBuffer = null;
                }
              };

              _proto.forceMergeBatches = function forceMergeBatches(material, frame, renderComp) {
                this._currMaterial = material;

                if (frame) {
                  this._currTexture = frame.getGFXTexture();
                  this._currSampler = frame.getGFXSampler();
                  this._currTextureHash = frame.getHash();
                  this._currSamplerHash = frame.getSamplerHash();
                } else {
                  this._currTexture = this._currSampler = null;
                  this._currTextureHash = this._currSamplerHash = 0;
                }

                this._currLayer = renderComp.node.layer;
                this._currScene = renderComp._getRenderScene();
                this.autoMergeBatches(renderComp);
              };

              _proto.finishMergeBatches = function finishMergeBatches() {
                this.autoMergeBatches();
                this._currMaterial = this._emptyMaterial;
                this._currTexture = null;
                this._currComponent = null;
                this._currTransform = null;
                this._currTextureHash = 0;
                this._currSamplerHash = 0;
                this._currLayer = 0;
              };

              _proto.flushMaterial = function flushMaterial(mat) {
                this._currMaterial = mat;
              };

              _proto.walk = function walk(node, level) {
                if (level === void 0) {
                  level = 0;
                }

                var len = node.children.length;
                var parentOpacity = this._parentOpacity;
                this._parentOpacity *= node._uiProps.opacity;

                this._preProcess(node);

                if (len > 0 && !node._static) {
                  var children = node.children;

                  for (var i = 0; i < children.length; ++i) {
                    var child = children[i];
                    this.walk(child, level);
                  }
                }

                this._postProcess(node);

                this._parentOpacity = parentOpacity;
                level += 1;
              };

              _proto._preProcess = function _preProcess(node) {
                if (!node._uiProps.uiTransformComp) {
                  return;
                }

                var render = node._uiProps.uiComp;

                if (render && render.enabledInHierarchy) {
                  render.updateAssembler(this);
                }
              };

              _proto._postProcess = function _postProcess(node) {
                var render = node._uiProps.uiComp;

                if (render && render.enabledInHierarchy) {
                  render.postUpdateAssembler(this);
                }
              };

              _proto._recursiveScreenNode = function _recursiveScreenNode(screen) {
                this.walk(screen);
                this.autoMergeBatches(this._currComponent);
              };

              _proto._createMeshBuffer = function _createMeshBuffer(attributes) {
                var batch = this._bufferBatchPool.add();

                batch.initialize(attributes, this._recreateMeshBuffer.bind(this, attributes));
                var strideBytes = getAttributeStride(attributes);

                var buffers = this._meshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._meshBuffers.set(strideBytes, buffers);
                }

                buffers.push(batch);
                return batch;
              };

              _proto._recreateMeshBuffer = function _recreateMeshBuffer(attributes, vertexCount, indexCount) {
                this.autoMergeBatches();

                this._requireBufferBatch(attributes, vertexCount, indexCount);
              };

              _proto._requireBufferBatch = function _requireBufferBatch(attributes, vertexCount, indexCount) {
                var strideBytes = getAttributeStride(attributes);

                var buffers = this._meshBuffers.get(strideBytes);

                if (!buffers) {
                  buffers = [];

                  this._meshBuffers.set(strideBytes, buffers);
                }

                var meshBufferUseCount = this._meshBufferUseCount.get(strideBytes) || 0;

                if (meshBufferUseCount >= buffers.length) {
                  this._currMeshBuffer = this._createMeshBuffer(attributes);
                } else {
                  this._currMeshBuffer = buffers[meshBufferUseCount];
                }

                this._meshBufferUseCount.set(strideBytes, meshBufferUseCount + 1);

                if (vertexCount && indexCount) {
                  this._currMeshBuffer.request(vertexCount, indexCount);
                }
              };

              _proto._screenSort = function _screenSort(a, b) {
                return a.node.getSiblingIndex() - b.node.getSiblingIndex();
              };

              _proto._applyOpacity = function _applyOpacity(comp) {
                var color = comp.color.a / 255;
                var opacity = this._parentOpacity *= color;
                var currMeshBuffer = this.currBufferBatch;
                var byteOffset = currMeshBuffer.byteOffset >> 2;
                var vBuf = currMeshBuffer.vData;
                var lastByteOffset = currMeshBuffer.lastByteOffset >> 2;
                var stride = currMeshBuffer.vertexFormatBytes / 4;

                for (var i = lastByteOffset; i < byteOffset; i += stride) {
                  vBuf[i + MeshBuffer.OPACITY_OFFSET] *= opacity;
                }

                currMeshBuffer.lastByteOffset = currMeshBuffer.byteOffset;
              };

              _proto._releaseDescriptorSetCache = function _releaseDescriptorSetCache(textureHash) {
                this._descriptorSetCache.releaseDescriptorSetCache(textureHash);
              };

              return Batcher2D;
            }());

            var LocalDescriptorSet = function () {
              _createClass(LocalDescriptorSet, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                }
              }]);

              function LocalDescriptorSet() {
                this._handle = null;
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
                this._localBuffer = null;
                this._transformUpdate = true;
                var device = legacyCC.director.root.device;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = device.createBuffer(new BufferInfo(BufferUsageBit.UNIFORM | BufferUsageBit.TRANSFER_DST, MemoryUsageBit.HOST | MemoryUsageBit.DEVICE, UBOLocal.SIZE, UBOLocal.SIZE));
              }

              var _proto2 = LocalDescriptorSet.prototype;

              _proto2.initialize = function initialize(batch) {
                var device = legacyCC.director.root.device;
                this._transform = batch.useLocalData;
                this._textureHash = batch.textureHash;
                this._samplerHash = batch.samplerHash;
                _dsInfo.layout = batch.passes[0].localSetLayout;

                if (this._handle) {
                  DSPool.free(this._handle);
                  this._handle = null;
                }

                this._handle = DSPool.alloc(device, _dsInfo);
                this._descriptorSet = DSPool.get(this._handle);

                this._descriptorSet.bindBuffer(UBOLocal.BINDING, this._localBuffer);

                var binding = ModelLocalBindings.SAMPLER_SPRITE;

                this._descriptorSet.bindTexture(binding, batch.texture);

                this._descriptorSet.bindSampler(binding, batch.sampler);

                this._descriptorSet.update();

                this._transformUpdate = true;
              };

              _proto2.updateTransform = function updateTransform(transform) {
                if (transform === this._transform) return;
                this._transform = transform;
                this._transformUpdate = true;
                this.uploadLocalData();
              };

              _proto2.updateLocal = function updateLocal() {
                if (!this._transform) return;
                this.uploadLocalData();
              };

              _proto2.equals = function equals(transform, textureHash, samplerHash) {
                return this._transform === transform && this._textureHash === textureHash && this._samplerHash === samplerHash;
              };

              _proto2.reset = function reset() {
                this._transform = null;
                this._textureHash = 0;
                this._samplerHash = 0;
              };

              _proto2.destroy = function destroy() {
                if (this._localBuffer) {
                  this._localBuffer.destroy();

                  this._localBuffer = null;
                }

                if (this._handle) {
                  DSPool.free(this._handle);
                  this._handle = null;
                }

                this._localData = null;
              };

              _proto2.uploadLocalData = function uploadLocalData() {
                var node = this._transform;

                if (node.hasChangedFlags || node._dirtyFlags) {
                  node.updateWorldTransform();
                }

                if (this._transformUpdate) {
                  var worldMatrix = node._mat;
                  Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                  Mat4.inverseTranspose(m4_1$5, worldMatrix);
                  Mat4.toArray(this._localData, m4_1$5, UBOLocal.MAT_WORLD_IT_OFFSET);

                  this._localBuffer.update(this._localData);

                  this._transformUpdate = false;
                }
              };

              return LocalDescriptorSet;
            }();

            var DescriptorSetCache = function () {
              function DescriptorSetCache() {
                this._descriptorSetCache = new Map();
                this._localDescriptorSetCache = [];
                this._localCachePool = void 0;
                this._localCachePool = new Pool(function () {
                  return new LocalDescriptorSet();
                }, 16);
              }

              var _proto3 = DescriptorSetCache.prototype;

              _proto3.getDescriptorSet = function getDescriptorSet(batch) {
                var root = legacyCC.director.root;

                if (batch.useLocalData) {
                  var caches = this._localDescriptorSetCache;

                  for (var i = 0, len = caches.length; i < len; i++) {
                    var cache = caches[i];

                    if (cache.equals(batch.useLocalData, batch.textureHash, batch.samplerHash)) {
                      return cache.handle;
                    }
                  }

                  var localDs = this._localCachePool.alloc();

                  localDs.initialize(batch);

                  this._localDescriptorSetCache.push(localDs);

                  return localDs.handle;
                } else {
                  var descriptorSetTextureMap = this._descriptorSetCache.get(batch.textureHash);

                  if (descriptorSetTextureMap && descriptorSetTextureMap.has(batch.samplerHash)) {
                    return descriptorSetTextureMap.get(batch.samplerHash);
                  } else {
                    _dsInfo.layout = batch.passes[0].localSetLayout;
                    var handle = DSPool.alloc(root.device, _dsInfo);
                    var descriptorSet = DSPool.get(handle);
                    var binding = ModelLocalBindings.SAMPLER_SPRITE;
                    descriptorSet.bindTexture(binding, batch.texture);
                    descriptorSet.bindSampler(binding, batch.sampler);
                    descriptorSet.update();

                    if (descriptorSetTextureMap) {
                      this._descriptorSetCache.get(batch.textureHash).set(batch.samplerHash, handle);
                    } else {
                      this._descriptorSetCache.set(batch.textureHash, new Map([[batch.samplerHash, handle]]));
                    }

                    return handle;
                  }
                }
              };

              _proto3.update = function update() {
                var caches = this._localDescriptorSetCache;
                caches.forEach(function (value) {
                  value.updateLocal();
                });
              };

              _proto3.reset = function reset() {
                var _this3 = this;

                var caches = this._localDescriptorSetCache;
                caches.forEach(function (value) {
                  _this3._localCachePool.free(value);
                });
                this._localDescriptorSetCache.length = 0;
              };

              _proto3.releaseDescriptorSetCache = function releaseDescriptorSetCache(textureHash) {
                if (this._descriptorSetCache.has(textureHash)) {
                  this._descriptorSetCache.get(textureHash).forEach(function (value) {
                    DSPool.free(value);
                  });

                  this._descriptorSetCache["delete"](textureHash);
                }
              };

              _proto3.destroy = function destroy() {
                this._descriptorSetCache.forEach(function (value, key, map) {
                  value.forEach(function (hDescriptorSet) {
                    DSPool.free(hDescriptorSet);
                  });
                });

                this._descriptorSetCache.clear();

                this._localDescriptorSetCache.length = 0;

                this._localCachePool.destroy(function (obj) {
                  obj.destroy();
                });
              };

              return DescriptorSetCache;
            }();

            legacyCC.internal.Batcher2D = Batcher2D;

            var _canvasContext = null;

            var _intervalId = -1;

            var _testString = "BES bswy:->@123\u4E01\u3041\u1101";

            var _fontFaces = Object.create(null);

            var _loadingFonts = [];
            var _timeout = 3000;

            var useNativeCheck = function () {
              var nativeCheck;
              return function () {
                if (nativeCheck === undefined) {
                  if ('FontFace' in window) {
                    var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
                    var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);

                    if (match) {
                      nativeCheck = parseInt(match[1], 10) > 42;
                    } else if (safari10Match) {
                      nativeCheck = false;
                    } else {
                      nativeCheck = true;
                    }
                  } else {
                    nativeCheck = false;
                  }
                }

                return nativeCheck;
              };
            }();

            function checkFontLoaded() {
              var allFontsLoaded = true;
              var now = Date.now();

              for (var i = _loadingFonts.length - 1; i >= 0; i--) {
                var fontLoadHandle = _loadingFonts[i];
                var fontFamily = fontLoadHandle.fontFamilyName;

                if (now - fontLoadHandle.startTime > _timeout) {
                  warnID(4933, fontFamily);
                  fontLoadHandle.onComplete(null, fontFamily);

                  _loadingFonts.splice(i, 1);

                  continue;
                }

                var oldWidth = fontLoadHandle.refWidth;
                var fontDesc = "40px " + fontFamily;
                _canvasContext.font = fontDesc;
                var newWidth = safeMeasureText(_canvasContext, _testString, fontDesc);

                if (oldWidth !== newWidth) {
                  _loadingFonts.splice(i, 1);

                  fontLoadHandle.onComplete(null, fontFamily);
                } else {
                  allFontsLoaded = false;
                }
              }

              if (allFontsLoaded) {
                clearInterval(_intervalId);
                _intervalId = -1;
              }
            }

            function nativeCheckFontLoaded(start, font, callback) {
              var loader = new Promise(function (resolve, reject) {
                var check = function check() {
                  var now = Date.now();

                  if (now - start >= _timeout) {
                    reject();
                  } else {
                    document.fonts.load("40px " + font).then(function (fonts) {
                      if (fonts.length >= 1) {
                        resolve();
                      } else {
                        setTimeout(check, 100);
                      }
                    }, function () {
                      reject();
                    });
                  }
                };

                check();
              });
              var timeoutId = null;
              var timer = new Promise(function (resolve, reject) {
                timeoutId = setTimeout(reject, _timeout);
              });
              Promise.race([timer, loader]).then(function () {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }

                callback(null, font);
              }, function () {
                warnID(4933, font);
                callback(null, font);
              });
            }

            function loadFont(url, options, onComplete) {
              var fontFamilyName = getFontFamily(url);

              if (_fontFaces[fontFamilyName]) {
                onComplete(null, fontFamilyName);
                return;
              }

              if (!_canvasContext) {
                var labelCanvas = document.createElement('canvas');
                labelCanvas.width = 100;
                labelCanvas.height = 100;
                _canvasContext = labelCanvas.getContext('2d');
              }

              var fontDesc = "40px " + fontFamilyName;
              var refWidth = safeMeasureText(_canvasContext, _testString, fontDesc);
              var fontStyle = document.createElement('style');
              fontStyle.type = 'text/css';
              var fontStr = '';

              if (Number.isNaN(fontFamilyName)) {
                fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";
              } else {
                fontStr += "@font-face { font-family:\"" + fontFamilyName + "\"; src:";
              }

              fontStr += "url(\"" + url + "\");";
              fontStyle.textContent = fontStr + "}";
              document.body.appendChild(fontStyle);
              var preloadDiv = document.createElement('div');
              var divStyle = preloadDiv.style;
              divStyle.fontFamily = fontFamilyName;
              preloadDiv.innerHTML = '.';
              divStyle.position = 'absolute';
              divStyle.left = '-100px';
              divStyle.top = '-100px';
              document.body.appendChild(preloadDiv);

              if (useNativeCheck()) {
                nativeCheckFontLoaded(Date.now(), fontFamilyName, onComplete);
              } else {
                var fontLoadHandle = {
                  fontFamilyName: fontFamilyName,
                  refWidth: refWidth,
                  onComplete: onComplete,
                  startTime: Date.now()
                };

                _loadingFonts.push(fontLoadHandle);

                if (_intervalId === -1) {
                  _intervalId = setInterval(checkFontLoaded, 100);
                }
              }

              _fontFaces[fontFamilyName] = fontStyle;
            }
            function getFontFamily(fontHandle) {
              var ttfIndex = fontHandle.lastIndexOf('.ttf');

              if (ttfIndex === -1) {
                return fontHandle;
              }

              var slashPos = fontHandle.lastIndexOf('/');
              var fontFamilyName;

              if (slashPos === -1) {
                fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
              } else {
                fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
              }

              if (fontFamilyName.indexOf(' ') !== -1) {
                fontFamilyName = "\"" + fontFamilyName + "\"";
              }

              return fontFamilyName;
            }

            function createFont(id, data, options, onComplete) {
              var out = new TTFFont();
              out._nativeUrl = id;
              out._nativeAsset = data;
              onComplete(null, out);
            }

            downloader.register({
              '.font': loadFont,
              '.eot': loadFont,
              '.ttf': loadFont,
              '.woff': loadFont,
              '.svg': loadFont,
              '.ttc': loadFont
            });
            factory.register({
              '.font': createFont,
              '.eot': createFont,
              '.ttf': createFont,
              '.woff': createFont,
              '.svg': createFont,
              '.ttc': createFont
            });

            legacyCC.UI = {
              MeshBuffer: MeshBuffer,
              spriteAssembler: spriteAssembler,
              graphicsAssembler: graphicsAssemblerManager,
              labelAssembler: labelAssembler
            };

            var _dec$v, _dec2$p, _dec3$o, _dec4$m, _dec5$j, _dec6$i, _dec7$i, _dec8$f, _dec9$d, _dec10$b, _dec11$a, _dec12$9, _dec13$9, _dec14$7, _dec15$6, _dec16$6, _dec17$5, _dec18$4, _dec19$3, _dec20$2, _dec21$2, _dec22$2, _dec23$2, _dec24$2, _dec25$2, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32$1, _class$v, _class2$p, _descriptor$o, _descriptor2$k, _descriptor3$h, _descriptor4$d, _descriptor5$a, _descriptor6$7, _descriptor7$6, _descriptor8$6, _descriptor9$5, _descriptor10$4, _descriptor11$3, _descriptor12$2, _descriptor13$1, _descriptor14$1, _class3$7, _temp$s;

            var _tempColor = new Color();

            var Transition;

            (function (Transition) {
              Transition[Transition["NONE"] = 0] = "NONE";
              Transition[Transition["COLOR"] = 1] = "COLOR";
              Transition[Transition["SPRITE"] = 2] = "SPRITE";
              Transition[Transition["SCALE"] = 3] = "SCALE";
            })(Transition || (Transition = {}));

            ccenum(Transition);
            var State;

            (function (State) {
              State["NORMAL"] = "normal";
              State["HOVER"] = "hover";
              State["PRESSED"] = "pressed";
              State["DISABLED"] = "disabled";
            })(State || (State = {}));

            var EventType$1;

            (function (EventType) {
              EventType["CLICK"] = "click";
            })(EventType$1 || (EventType$1 = {}));

            var Button = function (v) { return exports({ Button: v, ButtonComponent: v }), v; }((_dec$v = ccclass('cc.Button'), _dec2$p = help(), _dec3$o = executionOrder(110), _dec4$m = menu(), _dec5$j = requireComponent(UITransform), _dec6$i = type(Node), _dec7$i = displayOrder(), _dec8$f = tooltip(), _dec9$d = displayOrder(), _dec10$b = tooltip(), _dec11$a = type(Transition), _dec12$9 = displayOrder(), _dec13$9 = tooltip(), _dec14$7 = tooltip(), _dec15$6 = tooltip(), _dec16$6 = tooltip(), _dec17$5 = tooltip(), _dec18$4 = rangeMin(), _dec19$3 = rangeMax(), _dec20$2 = tooltip(), _dec21$2 = tooltip(), _dec22$2 = type(SpriteFrame), _dec23$2 = tooltip(), _dec24$2 = type(SpriteFrame), _dec25$2 = tooltip(), _dec26$1 = type(SpriteFrame), _dec27$1 = tooltip(), _dec28$1 = type(SpriteFrame), _dec29$1 = tooltip(), _dec30$1 = type([EventHandler]), _dec31$1 = displayOrder(), _dec32$1 = tooltip(), _dec$v(_class$v = _dec2$p(_class$v = _dec3$o(_class$v = _dec4$m(_class$v = _dec5$j(_class$v = executeInEditMode(_class$v = (_class2$p = (_temp$s = _class3$7 = function (_Component) {
              _inheritsLoose(Button, _Component);

              function Button() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "clickEvents", _descriptor$o, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_interactable", _descriptor2$k, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_transition", _descriptor3$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_normalColor", _descriptor4$d, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_hoverColor", _descriptor5$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pressedColor", _descriptor6$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_disabledColor", _descriptor7$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_normalSprite", _descriptor8$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_hoverSprite", _descriptor9$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pressedSprite", _descriptor10$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_disabledSprite", _descriptor11$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_duration", _descriptor12$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_zoomScale", _descriptor13$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_target", _descriptor14$1, _assertThisInitialized(_this));

                _this._pressed = false;
                _this._hovered = false;
                _this._fromColor = new Color();
                _this._toColor = new Color();
                _this._time = 0;
                _this._transitionFinished = true;
                _this._fromScale = new Vec3();
                _this._toScale = new Vec3();
                _this._originalScale = null;
                _this._sprite = null;
                _this._targetScale = new Vec3();
                return _this;
              }

              var _proto = Button.prototype;

              _proto.__preload = function __preload() {
                if (!this.target) {
                  this.target = this.node;
                }

                var sprite = this.node.getComponent(Sprite);

                if (sprite) {
                  this._normalSprite = sprite.spriteFrame;
                }

                this._applyTarget();

                this._resetState();
              };

              _proto.onEnable = function onEnable() {

                {
                  this._registerNodeEvent();
                }
              };

              _proto.onDisable = function onDisable() {
                this._resetState();

                {
                  this._unregisterNodeEvent();
                }
              };

              _proto.update = function update(dt) {
                var target = this.target;

                if (this._transitionFinished || !target) {
                  return;
                }

                if (this._transition !== Transition.COLOR && this._transition !== Transition.SCALE) {
                  return;
                }

                this._time += dt;
                var ratio = 1.0;

                if (this._duration > 0) {
                  ratio = this._time / this._duration;
                }

                if (ratio >= 1) {
                  ratio = 1;
                }

                if (this._transition === Transition.COLOR) {
                  var renderComp = target._uiProps.uiComp;
                  Color.lerp(_tempColor, this._fromColor, this._toColor, ratio);

                  if (renderComp) {
                    renderComp.color = _tempColor;
                  }
                } else if (this.transition === Transition.SCALE) {
                  target.getScale(this._targetScale);
                  this._targetScale.x = lerp(this._fromScale.x, this._toScale.x, ratio);
                  this._targetScale.y = lerp(this._fromScale.y, this._toScale.y, ratio);
                  target.setScale(this._targetScale);
                }

                if (ratio === 1) {
                  this._transitionFinished = true;
                }
              };

              _proto._resizeNodeToTargetNode = function _resizeNodeToTargetNode() {
                if (!this.target) {
                  return;
                }

                var targetTrans = this.target._uiProps.uiTransformComp;
              };

              _proto._resetState = function _resetState() {
                this._pressed = false;
                this._hovered = false;
                var target = this.target;

                if (!target) {
                  return;
                }

                var renderComp = target.getComponent(Renderable2D);

                if (!renderComp) {
                  return;
                }

                var transition = this._transition;

                if (transition === Transition.COLOR && this._interactable) {
                  renderComp.color = this._normalColor;
                } else if (transition === Transition.SCALE && this._originalScale) {
                  target.setScale(this._originalScale);
                }

                this._transitionFinished = true;
              };

              _proto._registerNodeEvent = function _registerNodeEvent() {
                this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.on(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.on(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
              };

              _proto._registerTargetEvent = function _registerTargetEvent(target) {

                target.on(SystemEventType.TRANSFORM_CHANGED, this._onTargetTransformChanged, this);
              };

              _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
                this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMove, this);
                this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancel, this);
                this.node.off(SystemEventType.MOUSE_ENTER, this._onMouseMoveIn, this);
                this.node.off(SystemEventType.MOUSE_LEAVE, this._onMouseMoveOut, this);
              };

              _proto._unregisterTargetEvent = function _unregisterTargetEvent(target) {

                target.off(SystemEventType.TRANSFORM_CHANGED);
              };

              _proto._getTargetSprite = function _getTargetSprite(target) {
                var sprite = null;

                if (target) {
                  sprite = target.getComponent(Sprite);
                }

                return sprite;
              };

              _proto._applyTarget = function _applyTarget() {
                if (this.target) {
                  this._sprite = this._getTargetSprite(this.target);

                  if (!this._originalScale) {
                    this._originalScale = new Vec3();
                  }

                  Vec3.copy(this._originalScale, this.target.getScale());
                }
              };

              _proto._onTargetSpriteFrameChanged = function _onTargetSpriteFrameChanged(comp) {
                if (this._transition === Transition.SPRITE) {
                  this._setCurrentStateSpriteFrame(comp.spriteFrame);
                }
              };

              _proto._setCurrentStateSpriteFrame = function _setCurrentStateSpriteFrame(spriteFrame) {
                if (!spriteFrame) {
                  return;
                }

                switch (this._getButtonState()) {
                  case State.NORMAL:
                    this._normalSprite = spriteFrame;
                    break;

                  case State.HOVER:
                    this._hoverSprite = spriteFrame;
                    break;

                  case State.PRESSED:
                    this._pressedSprite = spriteFrame;
                    break;

                  case State.DISABLED:
                    this._disabledSprite = spriteFrame;
                    break;
                }
              };

              _proto._onTargetColorChanged = function _onTargetColorChanged(color) {
                if (this._transition === Transition.COLOR) {
                  this._setCurrentStateColor(color);
                }
              };

              _proto._setCurrentStateColor = function _setCurrentStateColor(color) {
                switch (this._getButtonState()) {
                  case State.NORMAL:
                    this._normalColor = color;
                    break;

                  case State.HOVER:
                    this._hoverColor = color;
                    break;

                  case State.PRESSED:
                    this._pressedColor = color;
                    break;

                  case State.DISABLED:
                    this._disabledColor = color;
                    break;
                }
              };

              _proto._onTargetTransformChanged = function _onTargetTransformChanged(transformBit) {
                if (transformBit | TransformBit.SCALE && this._originalScale && this._transition === Transition.SCALE && this._transitionFinished) {
                  Vec3.copy(this._originalScale, this.target.getScale());
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = true;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchMove = function _onTouchMove(event) {
                if (!this._interactable || !this.enabledInHierarchy || !this._pressed) {
                  return;
                }

                if (!event) {
                  return;
                }

                var touch = event.touch;

                if (!touch) {
                  return;
                }

                var hit = this.node._uiProps.uiTransformComp.isHit(touch.getUILocation());

                if (this._transition === Transition.SCALE && this.target && this._originalScale) {
                  if (hit) {
                    Vec3.copy(this._fromScale, this._originalScale);
                    Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                    this._transitionFinished = false;
                  } else {
                    this._time = 0;
                    this._transitionFinished = true;
                    this.target.setScale(this._originalScale);
                  }
                } else {
                  var state;

                  if (hit) {
                    state = State.PRESSED;
                  } else {
                    state = State.NORMAL;
                  }

                  this._applyTransition(state);
                }

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._pressed) {
                  EventHandler.emitEvents(this.clickEvents, event);
                  this.node.emit(EventType$1.CLICK, this);
                }

                this._pressed = false;

                this._updateState();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchCancel = function _onTouchCancel(event) {
                if (!this._interactable || !this.enabledInHierarchy) {
                  return;
                }

                this._pressed = false;

                this._updateState();
              };

              _proto._onMouseMoveIn = function _onMouseMoveIn(event) {
                if (this._pressed || !this.interactable || !this.enabledInHierarchy) {
                  return;
                }

                if (this._transition === Transition.SPRITE && !this._hoverSprite) {
                  return;
                }

                if (!this._hovered) {
                  this._hovered = true;

                  this._updateState();
                }
              };

              _proto._onMouseMoveOut = function _onMouseMoveOut(event) {
                if (this._hovered) {
                  this._hovered = false;

                  this._updateState();
                }
              };

              _proto._updateState = function _updateState() {
                var state = this._getButtonState();

                this._applyTransition(state);
              };

              _proto._getButtonState = function _getButtonState() {
                var state = State.NORMAL;

                if (!this._interactable) {
                  state = State.DISABLED;
                } else if (this._pressed) {
                  state = State.PRESSED;
                } else if (this._hovered) {
                  state = State.HOVER;
                }

                return state.toString();
              };

              _proto._updateColorTransition = function _updateColorTransition(state) {
                var _this$target;

                var color = this[state + "Color"];
                var renderComp = (_this$target = this.target) === null || _this$target === void 0 ? void 0 : _this$target.getComponent(Renderable2D);

                if (!renderComp) {
                  return;
                }

                if ( state === State.DISABLED) {
                  renderComp.color = color;
                } else {
                  this._fromColor = renderComp.color.clone();
                  this._toColor = color;
                  this._time = 0;
                  this._transitionFinished = false;
                }
              };

              _proto._updateSpriteTransition = function _updateSpriteTransition(state) {
                var sprite = this[state + "Sprite"];

                if (this._sprite && sprite) {
                  this._sprite.spriteFrame = sprite;
                }
              };

              _proto._updateScaleTransition = function _updateScaleTransition(state) {
                if (!this._interactable) {
                  return;
                }

                if (state === State.PRESSED) {
                  this._zoomUp();
                } else {
                  this._zoomBack();
                }
              };

              _proto._zoomUp = function _zoomUp() {
                if (!this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this._originalScale);
                Vec3.multiplyScalar(this._toScale, this._originalScale, this._zoomScale);
                this._time = 0;
                this._transitionFinished = false;
              };

              _proto._zoomBack = function _zoomBack() {
                if (!this.target || !this._originalScale) {
                  return;
                }

                Vec3.copy(this._fromScale, this.target.getScale());
                Vec3.copy(this._toScale, this._originalScale);
                this._time = 0;
                this._transitionFinished = false;
              };

              _proto._applyTransition = function _applyTransition(state) {
                var transition = this._transition;

                if (transition === Transition.COLOR) {
                  this._updateColorTransition(state);
                } else if (transition === Transition.SPRITE) {
                  this._updateSpriteTransition(state);
                } else if (transition === Transition.SCALE) {
                  this._updateScaleTransition(state);
                }
              };

              _createClass(Button, [{
                key: "target",
                get: function get() {
                  return this._target || this.node;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  if (this._target) {
                    this._unregisterTargetEvent(this._target);
                  }

                  this._target = value;

                  this._applyTarget();
                }
              }, {
                key: "interactable",
                get: function get() {
                  return this._interactable;
                },
                set: function set(value) {
                  this._interactable = value;

                  this._updateState();

                  if (!this._interactable) {
                    this._resetState();
                  }
                }
              }, {
                key: "_resizeToTarget",
                set: function set(value) {
                  if (value) {
                    this._resizeNodeToTargetNode();
                  }
                }
              }, {
                key: "transition",
                get: function get() {
                  return this._transition;
                },
                set: function set(value) {
                  if (this._transition === value) {
                    return;
                  }

                  if (this._transition === Transition.COLOR) {
                    this._updateColorTransition(State.NORMAL);
                  } else if (this._transition === Transition.SPRITE) {
                    this._updateSpriteTransition(State.NORMAL);
                  }

                  this._transition = value;

                  this._updateState();
                }
              }, {
                key: "normalColor",
                get: function get() {
                  return this._normalColor;
                },
                set: function set(value) {
                  if (this._normalColor === value) {
                    return;
                  }

                  this._normalColor.set(value);

                  this._updateState();
                }
              }, {
                key: "pressedColor",
                get: function get() {
                  return this._pressedColor;
                },
                set: function set(value) {
                  if (this._pressedColor === value) {
                    return;
                  }

                  this._pressedColor.set(value);
                }
              }, {
                key: "hoverColor",
                get: function get() {
                  return this._hoverColor;
                },
                set: function set(value) {
                  if (this._hoverColor === value) {
                    return;
                  }

                  this._hoverColor.set(value);
                }
              }, {
                key: "disabledColor",
                get: function get() {
                  return this._disabledColor;
                },
                set: function set(value) {
                  if (this._disabledColor === value) {
                    return;
                  }

                  this._disabledColor.set(value);

                  this._updateState();
                }
              }, {
                key: "duration",
                get: function get() {
                  return this._duration;
                },
                set: function set(value) {
                  if (this._duration === value) {
                    return;
                  }

                  this._duration = value;
                }
              }, {
                key: "zoomScale",
                get: function get() {
                  return this._zoomScale;
                },
                set: function set(value) {
                  if (this._zoomScale === value) {
                    return;
                  }

                  this._zoomScale = value;
                }
              }, {
                key: "normalSprite",
                get: function get() {
                  return this._normalSprite;
                },
                set: function set(value) {
                  if (this._normalSprite === value) {
                    return;
                  }

                  this._normalSprite = value;
                  var sprite = this.node.getComponent(Sprite);

                  if (sprite) {
                    sprite.spriteFrame = value;
                  }

                  this._updateState();
                }
              }, {
                key: "pressedSprite",
                get: function get() {
                  return this._pressedSprite;
                },
                set: function set(value) {
                  if (this._pressedSprite === value) {
                    return;
                  }

                  this._pressedSprite = value;

                  this._updateState();
                }
              }, {
                key: "hoverSprite",
                get: function get() {
                  return this._hoverSprite;
                },
                set: function set(value) {
                  if (this._hoverSprite === value) {
                    return;
                  }

                  this._hoverSprite = value;

                  this._updateState();
                }
              }, {
                key: "disabledSprite",
                get: function get() {
                  return this._disabledSprite;
                },
                set: function set(value) {
                  if (this._disabledSprite === value) {
                    return;
                  }

                  this._disabledSprite = value;

                  this._updateState();
                }
              }]);

              return Button;
            }(Component), _class3$7.Transition = Transition, _class3$7.EventType = EventType$1, _temp$s), (_applyDecoratedDescriptor(_class2$p.prototype, "target", [_dec6$i, _dec7$i, _dec8$f], Object.getOwnPropertyDescriptor(_class2$p.prototype, "target"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "interactable", [_dec9$d, _dec10$b], Object.getOwnPropertyDescriptor(_class2$p.prototype, "interactable"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "transition", [_dec11$a, _dec12$9, _dec13$9], Object.getOwnPropertyDescriptor(_class2$p.prototype, "transition"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "normalColor", [_dec14$7], Object.getOwnPropertyDescriptor(_class2$p.prototype, "normalColor"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "pressedColor", [_dec15$6], Object.getOwnPropertyDescriptor(_class2$p.prototype, "pressedColor"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "hoverColor", [_dec16$6], Object.getOwnPropertyDescriptor(_class2$p.prototype, "hoverColor"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "disabledColor", [_dec17$5], Object.getOwnPropertyDescriptor(_class2$p.prototype, "disabledColor"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "duration", [_dec18$4, _dec19$3, _dec20$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "duration"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "zoomScale", [_dec21$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "zoomScale"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "normalSprite", [_dec22$2, _dec23$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "normalSprite"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "pressedSprite", [_dec24$2, _dec25$2], Object.getOwnPropertyDescriptor(_class2$p.prototype, "pressedSprite"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "hoverSprite", [_dec26$1, _dec27$1], Object.getOwnPropertyDescriptor(_class2$p.prototype, "hoverSprite"), _class2$p.prototype), _applyDecoratedDescriptor(_class2$p.prototype, "disabledSprite", [_dec28$1, _dec29$1], Object.getOwnPropertyDescriptor(_class2$p.prototype, "disabledSprite"), _class2$p.prototype), _descriptor$o = _applyDecoratedDescriptor(_class2$p.prototype, "clickEvents", [_dec30$1, serializable, _dec31$1, _dec32$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$p.prototype, "_interactable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class2$p.prototype, "_transition", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Transition.NONE;
              }
            }), _descriptor4$d = _applyDecoratedDescriptor(_class2$p.prototype, "_normalColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.WHITE.clone();
              }
            }), _descriptor5$a = _applyDecoratedDescriptor(_class2$p.prototype, "_hoverColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(211, 211, 211, 255);
              }
            }), _descriptor6$7 = _applyDecoratedDescriptor(_class2$p.prototype, "_pressedColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Color.WHITE.clone();
              }
            }), _descriptor7$6 = _applyDecoratedDescriptor(_class2$p.prototype, "_disabledColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(124, 124, 124, 255);
              }
            }), _descriptor8$6 = _applyDecoratedDescriptor(_class2$p.prototype, "_normalSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor9$5 = _applyDecoratedDescriptor(_class2$p.prototype, "_hoverSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor10$4 = _applyDecoratedDescriptor(_class2$p.prototype, "_pressedSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor11$3 = _applyDecoratedDescriptor(_class2$p.prototype, "_disabledSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor12$2 = _applyDecoratedDescriptor(_class2$p.prototype, "_duration", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class2$p.prototype, "_zoomScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1.2;
              }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class2$p.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$p)) || _class$v) || _class$v) || _class$v) || _class$v) || _class$v) || _class$v));

            var tabIndexUtil = function () {
              function tabIndexUtil() {}

              tabIndexUtil.add = function add(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);

                if (index === -1) {
                  list.push(editBoxImpl);
                }
              };

              tabIndexUtil.remove = function remove(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);

                if (index !== -1) {
                  list.splice(index, 1);
                }
              };

              tabIndexUtil.resort = function resort() {
                this._tabIndexList.sort(function (a, b) {
                  return a._delegate.tabIndex - b._delegate.tabIndex;
                });
              };

              tabIndexUtil.next = function next(editBoxImpl) {
                var list = this._tabIndexList;
                var index = list.indexOf(editBoxImpl);
                editBoxImpl.setFocus(false);

                if (index !== -1) {
                  var nextImpl = list[index + 1];

                  if (nextImpl && nextImpl._delegate.tabIndex >= 0) {
                    nextImpl.setFocus(true);
                  }
                }
              };

              return tabIndexUtil;
            }();
            tabIndexUtil._tabIndexList = [];

            var KeyboardReturnType;

            (function (KeyboardReturnType) {
              KeyboardReturnType[KeyboardReturnType["DEFAULT"] = 0] = "DEFAULT";
              KeyboardReturnType[KeyboardReturnType["DONE"] = 1] = "DONE";
              KeyboardReturnType[KeyboardReturnType["SEND"] = 2] = "SEND";
              KeyboardReturnType[KeyboardReturnType["SEARCH"] = 3] = "SEARCH";
              KeyboardReturnType[KeyboardReturnType["GO"] = 4] = "GO";
              KeyboardReturnType[KeyboardReturnType["NEXT"] = 5] = "NEXT";
            })(KeyboardReturnType || (KeyboardReturnType = {}));

            Enum(KeyboardReturnType);
            var InputMode;

            (function (InputMode) {
              InputMode[InputMode["ANY"] = 0] = "ANY";
              InputMode[InputMode["EMAIL_ADDR"] = 1] = "EMAIL_ADDR";
              InputMode[InputMode["NUMERIC"] = 2] = "NUMERIC";
              InputMode[InputMode["PHONE_NUMBER"] = 3] = "PHONE_NUMBER";
              InputMode[InputMode["URL"] = 4] = "URL";
              InputMode[InputMode["DECIMAL"] = 5] = "DECIMAL";
              InputMode[InputMode["SINGLE_LINE"] = 6] = "SINGLE_LINE";
            })(InputMode || (InputMode = {}));

            Enum(InputMode);
            var InputFlag;

            (function (InputFlag) {
              InputFlag[InputFlag["PASSWORD"] = 0] = "PASSWORD";
              InputFlag[InputFlag["SENSITIVE"] = 1] = "SENSITIVE";
              InputFlag[InputFlag["INITIAL_CAPS_WORD"] = 2] = "INITIAL_CAPS_WORD";
              InputFlag[InputFlag["INITIAL_CAPS_SENTENCE"] = 3] = "INITIAL_CAPS_SENTENCE";
              InputFlag[InputFlag["INITIAL_CAPS_ALL_CHARACTERS"] = 4] = "INITIAL_CAPS_ALL_CHARACTERS";
              InputFlag[InputFlag["DEFAULT"] = 5] = "DEFAULT";
            })(InputFlag || (InputFlag = {}));

            Enum(InputFlag);

            var EditBoxImplBase = function () {
              function EditBoxImplBase() {
                this._editing = false;
                this._delegate = null;
              }

              var _proto = EditBoxImplBase.prototype;

              _proto.init = function init(delegate) {};

              _proto.onEnable = function onEnable() {};

              _proto.update = function update() {};

              _proto.onDisable = function onDisable() {
                if (this._editing) {
                  this.endEditing();
                }
              };

              _proto.clear = function clear() {
                this._delegate = null;
              };

              _proto.setTabIndex = function setTabIndex(index) {};

              _proto.setSize = function setSize(width, height) {};

              _proto.setFocus = function setFocus(value) {
                if (value) {
                  this.beginEditing();
                } else {
                  this.endEditing();
                }
              };

              _proto.isFocused = function isFocused() {
                return this._editing;
              };

              _proto.beginEditing = function beginEditing() {};

              _proto.endEditing = function endEditing() {};

              return EditBoxImplBase;
            }();

            var SCROLLY = 40;
            var LEFT_PADDING = 2;
            var DELAY_TIME = 400;

            var _matrix$1 = new Mat4();

            var _matrix_temp = new Mat4();

            var _vec3 = new Vec3();

            var _currentEditBoxImpl = null;
            var _domCount = 0;
            var EditBoxImpl = function (_EditBoxImplBase) {
              _inheritsLoose(EditBoxImpl, _EditBoxImplBase);

              function EditBoxImpl() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _EditBoxImplBase.call.apply(_EditBoxImplBase, [this].concat(args)) || this;
                _this._delegate = null;
                _this._inputMode = -1;
                _this._inputFlag = -1;
                _this._returnType = -1;
                _this.__eventListeners = {};
                _this.__fullscreen = false;
                _this.__autoResize = false;
                _this.__orientationChanged = void 0;
                _this._edTxt = null;
                _this._isTextArea = false;
                _this._textLabelFont = null;
                _this._textLabelFontSize = null;
                _this._textLabelFontColor = null;
                _this._textLabelAlign = null;
                _this._placeholderLabelFont = null;
                _this._placeholderLabelFontSize = null;
                _this._placeholderLabelFontColor = null;
                _this._placeholderLabelAlign = null;
                _this._placeholderLineHeight = null;
                _this._placeholderStyleSheet = null;
                _this._domId = "EditBoxId_" + ++_domCount;
                return _this;
              }

              var _proto = EditBoxImpl.prototype;

              _proto.init = function init(delegate) {
                if (!delegate) {
                  return;
                }

                this._delegate = delegate;

                if (delegate.inputMode === InputMode.ANY) {
                  this._createTextArea();
                } else {
                  this._createInput();
                }

                tabIndexUtil.add(this);
                this.setTabIndex(delegate.tabIndex);

                this._initStyleSheet();

                this._registerEventListeners();

                this._addDomToGameContainer();

                this.__fullscreen = view.isAutoFullScreenEnabled();
                this.__autoResize = view._resizeWithBrowserSize;
              };

              _proto.clear = function clear() {
                this._removeEventListeners();

                this._removeDomFromGameContainer();

                tabIndexUtil.remove(this);

                if (_currentEditBoxImpl === this) {
                  _currentEditBoxImpl = null;
                }

                this._delegate = null;
              };

              _proto.update = function update() {
                this._updateMatrix();
              };

              _proto.setTabIndex = function setTabIndex(index) {
                this._edTxt.tabIndex = index;
                tabIndexUtil.resort();
              };

              _proto.setSize = function setSize(width, height) {
                var elem = this._edTxt;

                if (elem) {
                  elem.style.width = width + "px";
                  elem.style.height = height + "px";
                }
              };

              _proto.beginEditing = function beginEditing() {
                if (_currentEditBoxImpl && _currentEditBoxImpl !== this) {
                  _currentEditBoxImpl.setFocus(false);
                }

                this._editing = true;
                _currentEditBoxImpl = this;

                this._delegate._editBoxEditingDidBegan();

                this._showDom();

                this._edTxt.focus();
              };

              _proto.endEditing = function endEditing() {
                this._edTxt.blur();
              };

              _proto._createInput = function _createInput() {
                this._isTextArea = false;
                this._edTxt = document.createElement('input');
              };

              _proto._createTextArea = function _createTextArea() {
                this._isTextArea = true;
                this._edTxt = document.createElement('textarea');
              };

              _proto._addDomToGameContainer = function _addDomToGameContainer() {
                if (legacyCC.GAME_VIEW && this._edTxt) {
                  legacyCC.gameView.container.appendChild(this._edTxt);
                  legacyCC.gameView.head.appendChild(this._placeholderStyleSheet);
                } else if (game.container && this._edTxt) {
                  game.container.appendChild(this._edTxt);
                  document.head.appendChild(this._placeholderStyleSheet);
                }
              };

              _proto._removeDomFromGameContainer = function _removeDomFromGameContainer() {
                var hasElem = legacyCC.GAME_VIEW ? contains(legacyCC.gameView.container, this._edTxt) : contains(game.container, this._edTxt);

                if (hasElem && this._edTxt) {
                  if (legacyCC.GAME_VIEW) {
                    legacyCC.gameView.container.removeChild(this._edTxt);
                  } else {
                    game.container.removeChild(this._edTxt);
                  }
                }

                var hasStyleSheet = legacyCC.GAME_VIEW ? contains(legacyCC.gameView.head, this._placeholderStyleSheet) : contains(document.head, this._placeholderStyleSheet);

                if (hasStyleSheet) {
                  if (legacyCC.GAME_VIEW) {
                    legacyCC.gameView.head.removeChild(this._placeholderStyleSheet);
                  } else {
                    document.head.removeChild(this._placeholderStyleSheet);
                  }
                }

                this._edTxt = null;
                this._placeholderStyleSheet = null;
              };

              _proto._showDom = function _showDom() {
                this._updateMaxLength();

                this._updateInputType();

                this._updateStyleSheet();

                if (this._edTxt && this._delegate) {
                  this._edTxt.style.display = '';

                  this._delegate._hideLabels();
                }

                if (sys.isMobile) {
                  this._showDomOnMobile();
                }
              };

              _proto._hideDom = function _hideDom() {
                var elem = this._edTxt;

                if (elem && this._delegate) {
                  elem.style.display = 'none';

                  this._delegate._showLabels();
                }

                if (sys.isMobile) {
                  this._hideDomOnMobile();
                }
              };

              _proto._showDomOnMobile = function _showDomOnMobile() {
                if (sys.os !== sys.OS_ANDROID) {
                  return;
                }

                if (this.__fullscreen) {
                  view.enableAutoFullScreen(false);
                  screen.exitFullScreen();
                }

                if (this.__autoResize) {
                  view.resizeWithBrowserSize(false);
                }

                this._adjustWindowScroll();
              };

              _proto._hideDomOnMobile = function _hideDomOnMobile() {
                var _this2 = this;

                if (sys.os === sys.OS_ANDROID) {
                  if (this.__autoResize) {
                    view.resizeWithBrowserSize(true);
                  }

                  setTimeout(function () {
                    if (!_currentEditBoxImpl) {
                      if (_this2.__fullscreen) {
                        view.enableAutoFullScreen(true);
                      }
                    }
                  }, DELAY_TIME);
                }

                this._scrollBackWindow();
              };

              _proto._adjustWindowScroll = function _adjustWindowScroll() {
                var _this3 = this;

                setTimeout(function () {
                  if (window.scrollY < SCROLLY) {
                    _this3._edTxt.scrollIntoView({
                      block: 'start',
                      inline: 'nearest',
                      behavior: 'smooth'
                    });
                  }
                }, DELAY_TIME);
              };

              _proto._scrollBackWindow = function _scrollBackWindow() {
                setTimeout(function () {
                  if (sys.browserType === sys.BROWSER_TYPE_WECHAT && sys.os === sys.OS_IOS) {
                    if (window.top) {
                      window.top.scrollTo(0, 0);
                    }

                    return;
                  }

                  window.scrollTo(0, 0);
                }, DELAY_TIME);
              };

              _proto._updateMatrix = function _updateMatrix() {
                if (!this._edTxt) {
                  return;
                }

                var node = this._delegate.node;
                var scaleX = view.getScaleX();
                var scaleY = view.getScaleY();
                var widthRatio = 1;
                var heightRatio = 1;

                if (legacyCC.GAME_VIEW) {
                  widthRatio = legacyCC.gameView.canvas.width / legacyCC.game.canvas.width;
                  heightRatio = legacyCC.gameView.canvas.height / legacyCC.game.canvas.height;
                }

                scaleX *= widthRatio;
                scaleY *= heightRatio;
                var viewport = view.getViewportRect();
                var dpr = view.getDevicePixelRatio();
                node.getWorldMatrix(_matrix$1);
                var transform = node._uiProps.uiTransformComp;

                if (transform) {
                  Vec3.set(_vec3, -transform.anchorX * transform.width, -transform.anchorY * transform.height, _vec3.z);
                }

                Mat4.transform(_matrix$1, _matrix$1, _vec3);

                if (!node._uiProps.uiTransformComp) {
                  return;
                }

                var camera = director.root.batcher2D.getFirstRenderCamera(node);
                if (!camera) return;
                camera.node.getWorldRT(_matrix_temp);
                var m12 = _matrix_temp.m12;
                var m13 = _matrix_temp.m13;
                var center = visibleRect.center;
                _matrix_temp.m12 = center.x - (_matrix_temp.m00 * m12 + _matrix_temp.m04 * m13);
                _matrix_temp.m13 = center.y - (_matrix_temp.m01 * m12 + _matrix_temp.m05 * m13);
                Mat4.multiply(_matrix_temp, _matrix_temp, _matrix$1);
                scaleX /= dpr;
                scaleY /= dpr;
                var container = legacyCC.GAME_VIEW ? legacyCC.gameView.container : game.container;
                var a = _matrix_temp.m00 * scaleX;
                var b = _matrix$1.m01;
                var c = _matrix$1.m04;
                var d = _matrix_temp.m05 * scaleY;
                var offsetX = parseInt(container && container.style.paddingLeft || '0');
                offsetX += viewport.x * widthRatio / dpr;
                var offsetY = parseInt(container && container.style.paddingBottom || '0');
                offsetY += viewport.y / dpr;
                var tx = _matrix_temp.m12 * scaleX + offsetX;
                var ty = _matrix_temp.m13 * scaleY + offsetY;
                var matrix = "matrix(" + a + "," + -b + "," + -c + "," + d + "," + tx + "," + -ty + ")";
                this._edTxt.style.transform = matrix;
                this._edTxt.style['-webkit-transform'] = matrix;
                this._edTxt.style['transform-origin'] = '0px 100% 0px';
                this._edTxt.style['-webkit-transform-origin'] = '0px 100% 0px';
              };

              _proto._updateInputType = function _updateInputType() {
                var delegate = this._delegate;
                var inputMode = delegate.inputMode;
                var inputFlag = delegate.inputFlag;
                var returnType = delegate.returnType;
                var elem = this._edTxt;

                if (this._inputMode === inputMode && this._inputFlag === inputFlag && this._returnType === returnType) {
                  return;
                }

                this._inputMode = inputMode;
                this._inputFlag = inputFlag;
                this._returnType = returnType;

                if (this._isTextArea) {
                  var transform = 'none';

                  if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                    transform = 'uppercase';
                  } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                    transform = 'capitalize';
                  }

                  elem.style.textTransform = transform;
                  return;
                }

                elem = elem;

                if (inputFlag === InputFlag.PASSWORD) {
                  elem.type = 'password';
                  elem.style.textTransform = 'none';
                  return;
                }

                var type = elem.type;

                if (inputMode === InputMode.EMAIL_ADDR) {
                  type = 'email';
                } else if (inputMode === InputMode.NUMERIC || inputMode === InputMode.DECIMAL) {
                  type = 'number';
                } else if (inputMode === InputMode.PHONE_NUMBER) {
                  type = 'number';
                  elem.pattern = '[0-9]*';
                } else if (inputMode === InputMode.URL) {
                  type = 'url';
                } else {
                  type = 'text';

                  if (returnType === KeyboardReturnType.SEARCH) {
                    type = 'search';
                  }
                }

                elem.type = type;
                var textTransform = 'none';

                if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  textTransform = 'uppercase';
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  textTransform = 'capitalize';
                }

                elem.style.textTransform = textTransform;
              };

              _proto._updateMaxLength = function _updateMaxLength() {
                var maxLength = this._delegate.maxLength;

                if (maxLength < 0) {
                  maxLength = 65535;
                }

                this._edTxt.maxLength = maxLength;
              };

              _proto._initStyleSheet = function _initStyleSheet() {
                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                elem.style.color = '#000000';
                elem.style.border = '0px';
                elem.style.background = 'transparent';
                elem.style.width = '100%';
                elem.style.height = '100%';
                elem.style.outline = 'medium';
                elem.style.padding = '0';
                elem.style.textTransform = 'none';
                elem.style.display = 'none';
                elem.style.position = 'absolute';
                elem.style.bottom = '0px';
                elem.style.left = LEFT_PADDING + "px";
                elem.className = 'cocosEditBox';
                elem.style.fontFamily = 'Arial';
                elem.id = this._domId;

                if (!this._isTextArea) {
                  elem = elem;
                  elem.type = 'text';
                  elem.style['-moz-appearance'] = 'textfield';
                } else {
                  elem.style.resize = 'none';
                  elem.style.overflowY = 'scroll';
                }

                this._placeholderStyleSheet = document.createElement('style');
              };

              _proto._updateStyleSheet = function _updateStyleSheet() {
                var delegate = this._delegate;
                var elem = this._edTxt;

                if (elem && delegate) {
                  elem.value = delegate.string;
                  elem.placeholder = delegate.placeholder;

                  this._updateTextLabel(delegate.textLabel);

                  this._updatePlaceholderLabel(delegate.placeholderLabel);
                }
              };

              _proto._updateTextLabel = function _updateTextLabel(textLabel) {
                if (!textLabel) {
                  return;
                }

                var font = textLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = font._fontFamily;
                } else {
                  font = textLabel.fontFamily;
                }

                var fontSize = textLabel.fontSize * textLabel.node.scale.y;

                if (this._textLabelFont === font && this._textLabelFontSize === fontSize && this._textLabelFontColor === textLabel.fontColor && this._textLabelAlign === textLabel.horizontalAlign) {
                  return;
                }

                this._textLabelFont = font;
                this._textLabelFontSize = fontSize;
                this._textLabelFontColor = textLabel.fontColor;
                this._textLabelAlign = textLabel.horizontalAlign;

                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                elem.style.fontSize = fontSize + "px";
                elem.style.color = textLabel.color.toCSS();
                elem.style.fontFamily = font;

                switch (textLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    elem.style.textAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    elem.style.textAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    elem.style.textAlign = 'right';
                    break;
                }
              };

              _proto._updatePlaceholderLabel = function _updatePlaceholderLabel(placeholderLabel) {
                if (!placeholderLabel) {
                  return;
                }

                var font = placeholderLabel.font;

                if (font && !(font instanceof BitmapFont)) {
                  font = placeholderLabel.font._fontFamily;
                } else {
                  font = placeholderLabel.fontFamily;
                }

                var fontSize = placeholderLabel.fontSize * placeholderLabel.node.scale.y;

                if (this._placeholderLabelFont === font && this._placeholderLabelFontSize === fontSize && this._placeholderLabelFontColor === placeholderLabel.fontColor && this._placeholderLabelAlign === placeholderLabel.horizontalAlign && this._placeholderLineHeight === placeholderLabel.fontSize) {
                  return;
                }

                this._placeholderLabelFont = font;
                this._placeholderLabelFontSize = fontSize;
                this._placeholderLabelFontColor = placeholderLabel.fontColor;
                this._placeholderLabelAlign = placeholderLabel.horizontalAlign;
                this._placeholderLineHeight = placeholderLabel.fontSize;
                var styleEl = this._placeholderStyleSheet;
                var fontColor = placeholderLabel.color.toCSS();
                var lineHeight = placeholderLabel.fontSize;
                var horizontalAlign = '';

                switch (placeholderLabel.horizontalAlign) {
                  case Label.HorizontalAlign.LEFT:
                    horizontalAlign = 'left';
                    break;

                  case Label.HorizontalAlign.CENTER:
                    horizontalAlign = 'center';
                    break;

                  case Label.HorizontalAlign.RIGHT:
                    horizontalAlign = 'right';
                    break;
                }

                styleEl.innerHTML = "#" + this._domId + "::-webkit-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}" + ("#" + this._domId + "::-moz-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}") + ("#" + this._domId + "::-ms-input-placeholder{text-transform: initial;-family: " + font + ";font-size: " + fontSize + "px;color: " + fontColor + ";line-height: " + lineHeight + "px;text-align: " + horizontalAlign + ";}");

                if (legacyCC.sys.browserType === legacyCC.sys.BROWSER_TYPE_EDGE) {
                  styleEl.innerHTML += "#" + this._domId + "::-ms-clear{display: none;}";
                }
              };

              _proto._registerEventListeners = function _registerEventListeners() {
                var _this4 = this;

                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                var inputLock = false;
                var cbs = this.__eventListeners;

                cbs.compositionStart = function () {
                  inputLock = true;
                };

                cbs.compositionEnd = function () {
                  inputLock = false;

                  _this4._delegate._editBoxTextChanged(elem.value);
                };

                cbs.onInput = function () {
                  if (inputLock) {
                    return;
                  }

                  var delegate = _this4._delegate;
                  var maxLength = delegate.maxLength;

                  if (maxLength >= 0) {
                    elem.value = elem.value.slice(0, maxLength);
                  }

                  delegate._editBoxTextChanged(elem.value);
                };

                cbs.onClick = function () {
                  if (_this4._editing) {
                    if (sys.isMobile) {
                      _this4._adjustWindowScroll();
                    }
                  }
                };

                cbs.onKeydown = function (e) {
                  if (e.keyCode === macro.KEY.enter) {
                    e.propagationStopped = true;

                    _this4._delegate._editBoxEditingReturn();

                    if (!_this4._isTextArea) {
                      elem.blur();
                    }
                  } else if (e.keyCode === macro.KEY.tab) {
                    e.propagationStopped = true;
                    e.preventDefault();
                    tabIndexUtil.next(_this4);
                  }
                };

                cbs.onBlur = function () {
                  if (sys.isMobile && inputLock) {
                    cbs.compositionEnd();
                  }

                  _this4._editing = false;
                  _currentEditBoxImpl = null;

                  _this4._hideDom();

                  _this4._delegate._editBoxEditingDidEnded();
                };

                elem.addEventListener('compositionstart', cbs.compositionStart);
                elem.addEventListener('compositionend', cbs.compositionEnd);
                elem.addEventListener('input', cbs.onInput);
                elem.addEventListener('keydown', cbs.onKeydown);
                elem.addEventListener('blur', cbs.onBlur);
                elem.addEventListener('touchstart', cbs.onClick);
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                if (!this._edTxt) {
                  return;
                }

                var elem = this._edTxt;
                var cbs = this.__eventListeners;
                elem.removeEventListener('compositionstart', cbs.compositionStart);
                elem.removeEventListener('compositionend', cbs.compositionEnd);
                elem.removeEventListener('input', cbs.onInput);
                elem.removeEventListener('keydown', cbs.onKeydown);
                elem.removeEventListener('blur', cbs.onBlur);
                elem.removeEventListener('touchstart', cbs.onClick);
                cbs.compositionStart = null;
                cbs.compositionEnd = null;
                cbs.onInput = null;
                cbs.onKeydown = null;
                cbs.onBlur = null;
                cbs.onClick = null;
              };

              return EditBoxImpl;
            }(EditBoxImplBase);

            var _dec$w, _dec2$q, _dec3$p, _dec4$n, _dec5$k, _dec6$j, _dec7$j, _dec8$g, _dec9$e, _dec10$c, _dec11$b, _dec12$a, _dec13$a, _dec14$8, _dec15$7, _dec16$7, _dec17$6, _dec18$5, _dec19$4, _dec20$3, _dec21$3, _dec22$3, _dec23$3, _dec24$3, _dec25$3, _dec26$2, _dec27$2, _dec28$2, _dec29$2, _dec30$2, _dec31$2, _dec32$2, _dec33$1, _dec34$1, _dec35$1, _dec36$1, _dec37$1, _dec38$1, _dec39$1, _dec40$1, _dec41, _dec42, _dec43, _class$w, _class2$q, _descriptor$p, _descriptor2$l, _descriptor3$i, _descriptor4$e, _descriptor5$b, _descriptor6$8, _descriptor7$7, _descriptor8$7, _descriptor9$6, _descriptor10$5, _descriptor11$4, _descriptor12$3, _descriptor13$2, _class3$8, _temp$t;
            var LEFT_PADDING$1 = 2;

            function capitalize(str) {
              return str.replace(/(?:^|\s)\S/g, function (a) {
                return a.toUpperCase();
              });
            }

            function capitalizeFirstLetter(str) {
              return str.charAt(0).toUpperCase() + str.slice(1);
            }

            var EventType$2;

            (function (EventType) {
              EventType["EDITING_DID_BEGAN"] = "editing-did-began";
              EventType["EDITING_DID_ENDED"] = "editing-did-ended";
              EventType["TEXT_CHANGED"] = "text-changed";
              EventType["EDITING_RETURN"] = "editing-return";
            })(EventType$2 || (EventType$2 = {}));

            var EditBox = function (v) { return exports({ EditBox: v, EditBoxComponent: v }), v; }((_dec$w = ccclass('cc.EditBox'), _dec2$q = help(), _dec3$p = executionOrder(100), _dec4$n = menu(), _dec5$k = requireComponent(UITransform), _dec6$j = displayOrder(), _dec7$j = tooltip(), _dec8$g = displayOrder(), _dec9$e = tooltip(), _dec10$c = type(Label), _dec11$b = displayOrder(), _dec12$a = tooltip(), _dec13$a = type(Label), _dec14$8 = displayOrder(), _dec15$7 = tooltip(), _dec16$7 = type(SpriteFrame), _dec17$6 = displayOrder(), _dec18$5 = tooltip(), _dec19$4 = type(InputFlag), _dec20$3 = displayOrder(), _dec21$3 = tooltip(), _dec22$3 = type(InputMode), _dec23$3 = displayOrder(), _dec24$3 = tooltip(), _dec25$3 = type(KeyboardReturnType), _dec26$2 = displayOrder(), _dec27$2 = tooltip(), _dec28$2 = displayOrder(), _dec29$2 = tooltip(), _dec30$2 = displayOrder(), _dec31$2 = tooltip(), _dec32$2 = type([EventHandler]), _dec33$1 = displayOrder(), _dec34$1 = tooltip(), _dec35$1 = type([EventHandler]), _dec36$1 = displayOrder(), _dec37$1 = tooltip(), _dec38$1 = type([EventHandler]), _dec39$1 = displayOrder(), _dec40$1 = tooltip(), _dec41 = type([EventHandler]), _dec42 = displayOrder(), _dec43 = tooltip(), _dec$w(_class$w = _dec2$q(_class$w = _dec3$p(_class$w = _dec4$n(_class$w = _dec5$k(_class$w = executeInEditMode(_class$w = (_class2$q = (_temp$t = _class3$8 = function (_Component) {
              _inheritsLoose(EditBox, _Component);

              function EditBox() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "editingDidBegan", _descriptor$p, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "textChanged", _descriptor2$l, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "editingDidEnded", _descriptor3$i, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "editingReturn", _descriptor4$e, _assertThisInitialized(_this));

                _this._impl = null;
                _this._background = null;

                _initializerDefineProperty(_this, "_textLabel", _descriptor5$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_placeholderLabel", _descriptor6$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_returnType", _descriptor7$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_string", _descriptor8$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_tabIndex", _descriptor9$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_backgroundImage", _descriptor10$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_inputFlag", _descriptor11$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_inputMode", _descriptor12$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_maxLength", _descriptor13$2, _assertThisInitialized(_this));

                _this._isLabelVisible = false;
                return _this;
              }

              var _proto = EditBox.prototype;

              _proto.__preload = function __preload() {
                this._init();
              };

              _proto.onEnable = function onEnable() {
                {
                  this._registerEvent();
                }

                if (this._impl) {
                  this._impl.onEnable();
                }
              };

              _proto.update = function update() {
                if (this._impl) {
                  this._impl.update();
                }
              };

              _proto.onDisable = function onDisable() {
                {
                  this._unregisterEvent();
                }

                if (this._impl) {
                  this._impl.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._impl) {
                  this._impl.clear();
                }
              };

              _proto.setFocus = function setFocus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              };

              _proto.focus = function focus() {
                if (this._impl) {
                  this._impl.setFocus(true);
                }
              };

              _proto.blur = function blur() {
                if (this._impl) {
                  this._impl.setFocus(false);
                }
              };

              _proto.isFocused = function isFocused() {
                if (this._impl) {
                  return this._impl.isFocused();
                }

                return false;
              };

              _proto._editBoxEditingDidBegan = function _editBoxEditingDidBegan() {
                EventHandler.emitEvents(this.editingDidBegan, this);
                this.node.emit(EventType$2.EDITING_DID_BEGAN, this);
              };

              _proto._editBoxEditingDidEnded = function _editBoxEditingDidEnded() {
                EventHandler.emitEvents(this.editingDidEnded, this);
                this.node.emit(EventType$2.EDITING_DID_ENDED, this);
              };

              _proto._editBoxTextChanged = function _editBoxTextChanged(text) {
                text = this._updateLabelStringStyle(text, true);
                this.string = text;
                EventHandler.emitEvents(this.textChanged, text, this);
                this.node.emit(EventType$2.TEXT_CHANGED, this);
              };

              _proto._editBoxEditingReturn = function _editBoxEditingReturn() {
                EventHandler.emitEvents(this.editingReturn, this);
                this.node.emit(EventType$2.EDITING_RETURN, this);
              };

              _proto._showLabels = function _showLabels() {
                this._isLabelVisible = true;

                this._updateLabels();
              };

              _proto._hideLabels = function _hideLabels() {
                this._isLabelVisible = false;

                if (this._textLabel) {
                  this._textLabel.node.active = false;
                }

                if (this._placeholderLabel) {
                  this._placeholderLabel.node.active = false;
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                event.propagationStopped = true;
              };

              _proto._onTouchCancel = function _onTouchCancel(event) {
                event.propagationStopped = true;
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                if (this._impl) {
                  this._impl.beginEditing();
                }

                event.propagationStopped = true;
              };

              _proto._init = function _init() {
                this._createBackgroundSprite();

                this._updatePlaceholderLabel();

                this._updateTextLabel();

                this._isLabelVisible = true;
                this.node.on(SystemEventType.SIZE_CHANGED, this._resizeChildNodes, this);
                var impl = this._impl = new EditBox._EditBoxImpl();
                impl.init(this);

                this._updateString(this._string);

                this._syncSize();
              };

              _proto._createBackgroundSprite = function _createBackgroundSprite() {
                if (!this._background) {
                  this._background = this.node.getComponent(Sprite);

                  if (!this._background) {
                    this._background = this.node.addComponent(Sprite);
                  }
                }

                this._background.type = Sprite.Type.SLICED;
                this._background.spriteFrame = this._backgroundImage;
              };

              _proto._updateTextLabel = function _updateTextLabel() {
                var textLabel = this._textLabel;

                if (!textLabel) {
                  var node = this.node.getChildByName('TEXT_LABEL');

                  if (!node) {
                    node = new Node('TEXT_LABEL');
                  }

                  textLabel = node.getComponent(Label);

                  if (!textLabel) {
                    textLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._textLabel = textLabel;
                }

                var transformComp = this._textLabel.node._uiProps.uiTransformComp;
                transformComp.setAnchorPoint(0, 1);
                textLabel.overflow = Label.Overflow.CLAMP;

                if (this._inputMode === InputMode.ANY) {
                  textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  textLabel.enableWrapText = true;
                } else {
                  textLabel.enableWrapText = false;
                }

                textLabel.string = this._updateLabelStringStyle(this._string);
              };

              _proto._updatePlaceholderLabel = function _updatePlaceholderLabel() {
                var placeholderLabel = this._placeholderLabel;

                if (!placeholderLabel) {
                  var node = this.node.getChildByName('PLACEHOLDER_LABEL');

                  if (!node) {
                    node = new Node('PLACEHOLDER_LABEL');
                  }

                  placeholderLabel = node.getComponent(Label);

                  if (!placeholderLabel) {
                    placeholderLabel = node.addComponent(Label);
                  }

                  node.parent = this.node;
                  this._placeholderLabel = placeholderLabel;
                }

                var transform = this._placeholderLabel.node._uiProps.uiTransformComp;
                transform.setAnchorPoint(0, 1);
                placeholderLabel.overflow = Label.Overflow.CLAMP;

                if (this._inputMode === InputMode.ANY) {
                  placeholderLabel.verticalAlign = VerticalTextAlignment.TOP;
                  placeholderLabel.enableWrapText = true;
                } else {
                  placeholderLabel.enableWrapText = false;
                }

                placeholderLabel.string = this.placeholder;
              };

              _proto._syncSize = function _syncSize() {
                var trans = this.node._uiProps.uiTransformComp;
                var size = trans.contentSize;

                if (this._background) {
                  var bgTrans = this._background.node._uiProps.uiTransformComp;
                  bgTrans.anchorPoint = trans.anchorPoint;
                  bgTrans.setContentSize(size);
                }

                this._updateLabelPosition(size);

                if (this._impl) {
                  this._impl.setSize(size.width, size.height);
                }
              };

              _proto._updateLabels = function _updateLabels() {
                if (this._isLabelVisible) {
                  var content = this._string;

                  if (this._textLabel) {
                    this._textLabel.node.active = content !== '';
                  }

                  if (this._placeholderLabel) {
                    this._placeholderLabel.node.active = content === '';
                  }
                }
              };

              _proto._updateString = function _updateString(text) {
                var textLabel = this._textLabel;

                if (!textLabel) {
                  return;
                }

                var displayText = text;

                if (displayText) {
                  displayText = this._updateLabelStringStyle(displayText);
                }

                textLabel.string = displayText;

                this._updateLabels();
              };

              _proto._updateLabelStringStyle = function _updateLabelStringStyle(text, ignorePassword) {
                if (ignorePassword === void 0) {
                  ignorePassword = false;
                }

                var inputFlag = this._inputFlag;

                if (!ignorePassword && inputFlag === InputFlag.PASSWORD) {
                  var passwordString = '';
                  var len = text.length;

                  for (var i = 0; i < len; ++i) {
                    passwordString += "\u25CF";
                  }

                  text = passwordString;
                } else if (inputFlag === InputFlag.INITIAL_CAPS_ALL_CHARACTERS) {
                  text = text.toUpperCase();
                } else if (inputFlag === InputFlag.INITIAL_CAPS_WORD) {
                  text = capitalize(text);
                } else if (inputFlag === InputFlag.INITIAL_CAPS_SENTENCE) {
                  text = capitalizeFirstLetter(text);
                }

                return text;
              };

              _proto._registerEvent = function _registerEvent() {
                this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._unregisterEvent = function _unregisterEvent() {
                this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this);
              };

              _proto._updateLabelPosition = function _updateLabelPosition(size) {
                var trans = this.node._uiProps.uiTransformComp;
                var offX = -trans.anchorX * trans.width;
                var offY = -trans.anchorY * trans.height;
                var placeholderLabel = this._placeholderLabel;
                var textLabel = this._textLabel;

                if (textLabel) {
                  textLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  textLabel.node.position = new Vec3(offX + LEFT_PADDING$1, offY + size.height, textLabel.node.position.z);

                  if (this._inputMode === InputMode.ANY) {
                    textLabel.verticalAlign = VerticalTextAlignment.TOP;
                  }

                  textLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }

                if (placeholderLabel) {
                  placeholderLabel.node._uiProps.uiTransformComp.setContentSize(size.width - LEFT_PADDING$1, size.height);

                  placeholderLabel.lineHeight = size.height;
                  placeholderLabel.node.position = new Vec3(offX + LEFT_PADDING$1, offY + size.height, placeholderLabel.node.position.z);

                  if (this._inputMode === InputMode.ANY) {
                    placeholderLabel.verticalAlign = VerticalTextAlignment.TOP;
                  }

                  placeholderLabel.enableWrapText = this._inputMode === InputMode.ANY;
                }
              };

              _proto._resizeChildNodes = function _resizeChildNodes() {
                var trans = this.node._uiProps.uiTransformComp;
                var textLabelNode = this._textLabel && this._textLabel.node;

                if (textLabelNode) {
                  textLabelNode.position = new Vec3(-trans.width / 2, trans.height / 2, textLabelNode.position.z);

                  textLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                var placeholderLabelNode = this._placeholderLabel && this._placeholderLabel.node;

                if (placeholderLabelNode) {
                  placeholderLabelNode.position = new Vec3(-trans.width / 2, trans.height / 2, placeholderLabelNode.position.z);

                  placeholderLabelNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }

                var backgroundNode = this._background && this._background.node;

                if (backgroundNode) {
                  backgroundNode._uiProps.uiTransformComp.setContentSize(trans.contentSize);
                }
              };

              _createClass(EditBox, [{
                key: "string",
                get: function get() {
                  return this._string;
                },
                set: function set(value) {
                  if (this._maxLength >= 0 && value.length >= this._maxLength) {
                    value = value.slice(0, this._maxLength);
                  }

                  this._string = value;

                  this._updateString(value);
                }
              }, {
                key: "placeholder",
                get: function get() {
                  if (!this._placeholderLabel) {
                    return '';
                  }

                  return this._placeholderLabel.string;
                },
                set: function set(value) {
                  if (this._placeholderLabel) {
                    this._placeholderLabel.string = value;
                  }
                }
              }, {
                key: "textLabel",
                get: function get() {
                  return this._textLabel;
                },
                set: function set(oldValue) {
                  if (this._textLabel !== oldValue) {
                    this._textLabel = oldValue;

                    if (this._textLabel) {
                      this._updateTextLabel();

                      this._updateLabels();
                    }
                  }
                }
              }, {
                key: "placeholderLabel",
                get: function get() {
                  return this._placeholderLabel;
                },
                set: function set(oldValue) {
                  if (this._placeholderLabel !== oldValue) {
                    this._placeholderLabel = oldValue;

                    if (this._placeholderLabel) {
                      this._updatePlaceholderLabel();

                      this._updateLabels();
                    }
                  }
                }
              }, {
                key: "backgroundImage",
                get: function get() {
                  return this._backgroundImage;
                },
                set: function set(value) {
                  if (this._backgroundImage === value) {
                    return;
                  }

                  this._backgroundImage = value;

                  this._createBackgroundSprite();
                }
              }, {
                key: "inputFlag",
                get: function get() {
                  return this._inputFlag;
                },
                set: function set(value) {
                  this._inputFlag = value;

                  this._updateString(this._string);
                }
              }, {
                key: "inputMode",
                get: function get() {
                  return this._inputMode;
                },
                set: function set(oldValue) {
                  if (this._inputMode !== oldValue) {
                    this._inputMode = oldValue;

                    this._updateTextLabel();

                    this._updatePlaceholderLabel();
                  }
                }
              }, {
                key: "returnType",
                get: function get() {
                  return this._returnType;
                },
                set: function set(value) {
                  this._returnType = value;
                }
              }, {
                key: "maxLength",
                get: function get() {
                  return this._maxLength;
                },
                set: function set(value) {
                  this._maxLength = value;
                }
              }, {
                key: "tabIndex",
                get: function get() {
                  return this._tabIndex;
                },
                set: function set(value) {
                  if (this._tabIndex !== value) {
                    this._tabIndex = value;

                    if (this._impl) {
                      this._impl.setTabIndex(value);
                    }
                  }
                }
              }]);

              return EditBox;
            }(Component), _class3$8._EditBoxImpl = EditBoxImplBase, _class3$8.KeyboardReturnType = KeyboardReturnType, _class3$8.InputFlag = InputFlag, _class3$8.InputMode = InputMode, _class3$8.EventType = EventType$2, _temp$t), (_applyDecoratedDescriptor(_class2$q.prototype, "string", [_dec6$j, _dec7$j], Object.getOwnPropertyDescriptor(_class2$q.prototype, "string"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "placeholder", [_dec8$g, _dec9$e], Object.getOwnPropertyDescriptor(_class2$q.prototype, "placeholder"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "textLabel", [_dec10$c, _dec11$b, _dec12$a], Object.getOwnPropertyDescriptor(_class2$q.prototype, "textLabel"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "placeholderLabel", [_dec13$a, _dec14$8, _dec15$7], Object.getOwnPropertyDescriptor(_class2$q.prototype, "placeholderLabel"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "backgroundImage", [_dec16$7, _dec17$6, _dec18$5], Object.getOwnPropertyDescriptor(_class2$q.prototype, "backgroundImage"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "inputFlag", [_dec19$4, _dec20$3, _dec21$3], Object.getOwnPropertyDescriptor(_class2$q.prototype, "inputFlag"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "inputMode", [_dec22$3, _dec23$3, _dec24$3], Object.getOwnPropertyDescriptor(_class2$q.prototype, "inputMode"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "returnType", [_dec25$3, _dec26$2, _dec27$2], Object.getOwnPropertyDescriptor(_class2$q.prototype, "returnType"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "maxLength", [_dec28$2, _dec29$2], Object.getOwnPropertyDescriptor(_class2$q.prototype, "maxLength"), _class2$q.prototype), _applyDecoratedDescriptor(_class2$q.prototype, "tabIndex", [_dec30$2, _dec31$2], Object.getOwnPropertyDescriptor(_class2$q.prototype, "tabIndex"), _class2$q.prototype), _descriptor$p = _applyDecoratedDescriptor(_class2$q.prototype, "editingDidBegan", [_dec32$2, serializable, _dec33$1, _dec34$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$l = _applyDecoratedDescriptor(_class2$q.prototype, "textChanged", [_dec35$1, serializable, _dec36$1, _dec37$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class2$q.prototype, "editingDidEnded", [_dec38$1, serializable, _dec39$1, _dec40$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor4$e = _applyDecoratedDescriptor(_class2$q.prototype, "editingReturn", [_dec41, serializable, _dec42, _dec43], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor5$b = _applyDecoratedDescriptor(_class2$q.prototype, "_textLabel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor6$8 = _applyDecoratedDescriptor(_class2$q.prototype, "_placeholderLabel", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor7$7 = _applyDecoratedDescriptor(_class2$q.prototype, "_returnType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return KeyboardReturnType.DEFAULT;
              }
            }), _descriptor8$7 = _applyDecoratedDescriptor(_class2$q.prototype, "_string", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor9$6 = _applyDecoratedDescriptor(_class2$q.prototype, "_tabIndex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor10$5 = _applyDecoratedDescriptor(_class2$q.prototype, "_backgroundImage", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor11$4 = _applyDecoratedDescriptor(_class2$q.prototype, "_inputFlag", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return InputFlag.DEFAULT;
              }
            }), _descriptor12$3 = _applyDecoratedDescriptor(_class2$q.prototype, "_inputMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return InputMode.ANY;
              }
            }), _descriptor13$2 = _applyDecoratedDescriptor(_class2$q.prototype, "_maxLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 20;
              }
            })), _class2$q)) || _class$w) || _class$w) || _class$w) || _class$w) || _class$w) || _class$w));

            if (typeof window === 'object' && typeof document === 'object' && !MINIGAME && !JSB && !RUNTIME_BASED) {
              EditBox._EditBoxImpl = EditBoxImpl;
            }

            var _dec$x, _dec2$r, _dec3$q, _dec4$o, _dec5$l, _dec6$k, _dec7$k, _dec8$h, _dec9$f, _dec10$d, _dec11$c, _dec12$b, _dec13$b, _dec14$9, _dec15$8, _dec16$8, _dec17$7, _dec18$6, _dec19$5, _dec20$4, _dec21$4, _dec22$4, _dec23$4, _dec24$4, _dec25$4, _dec26$3, _dec27$3, _dec28$3, _dec29$3, _dec30$3, _dec31$3, _dec32$3, _dec33$2, _dec34$2, _class$x, _class2$r, _descriptor$q, _descriptor2$m, _descriptor3$j, _descriptor4$f, _descriptor5$c, _descriptor6$9, _descriptor7$8, _descriptor8$8, _descriptor9$7, _descriptor10$6, _descriptor11$5, _descriptor12$4, _descriptor13$3, _descriptor14$2, _descriptor15$1, _descriptor16$1, _class3$9, _temp$u;
            var NodeEvent = SystemEventType;
            var Type;

            (function (Type) {
              Type[Type["NONE"] = 0] = "NONE";
              Type[Type["HORIZONTAL"] = 1] = "HORIZONTAL";
              Type[Type["VERTICAL"] = 2] = "VERTICAL";
              Type[Type["GRID"] = 3] = "GRID";
            })(Type || (Type = {}));

            ccenum(Type);
            var ResizeMode;

            (function (ResizeMode) {
              ResizeMode[ResizeMode["NONE"] = 0] = "NONE";
              ResizeMode[ResizeMode["CONTAINER"] = 1] = "CONTAINER";
              ResizeMode[ResizeMode["CHILDREN"] = 2] = "CHILDREN";
            })(ResizeMode || (ResizeMode = {}));

            ccenum(ResizeMode);
            var AxisDirection;

            (function (AxisDirection) {
              AxisDirection[AxisDirection["HORIZONTAL"] = 0] = "HORIZONTAL";
              AxisDirection[AxisDirection["VERTICAL"] = 1] = "VERTICAL";
            })(AxisDirection || (AxisDirection = {}));

            ccenum(AxisDirection);
            var VerticalDirection;

            (function (VerticalDirection) {
              VerticalDirection[VerticalDirection["BOTTOM_TO_TOP"] = 0] = "BOTTOM_TO_TOP";
              VerticalDirection[VerticalDirection["TOP_TO_BOTTOM"] = 1] = "TOP_TO_BOTTOM";
            })(VerticalDirection || (VerticalDirection = {}));

            ccenum(VerticalDirection);
            var HorizontalDirection;

            (function (HorizontalDirection) {
              HorizontalDirection[HorizontalDirection["LEFT_TO_RIGHT"] = 0] = "LEFT_TO_RIGHT";
              HorizontalDirection[HorizontalDirection["RIGHT_TO_LEFT"] = 1] = "RIGHT_TO_LEFT";
            })(HorizontalDirection || (HorizontalDirection = {}));

            ccenum(HorizontalDirection);
            var Constraint;

            (function (Constraint) {
              Constraint[Constraint["NONE"] = 0] = "NONE";
              Constraint[Constraint["FIXED_ROW"] = 1] = "FIXED_ROW";
              Constraint[Constraint["FIXED_COL"] = 2] = "FIXED_COL";
            })(Constraint || (Constraint = {}));

            ccenum(Constraint);

            var _tempVec3 = new Vec3();

            var Layout = function (v) { return exports({ Layout: v, LayoutComponent: v }), v; }((_dec$x = ccclass('cc.Layout'), _dec2$r = help(), _dec3$q = executionOrder(110), _dec4$o = menu(), _dec5$l = requireComponent(UITransform), _dec6$k = visible(), _dec7$k = tooltip(), _dec8$h = visible(), _dec9$f = tooltip(), _dec10$d = type(Type), _dec11$c = tooltip(), _dec12$b = type(ResizeMode), _dec13$b = visible(), _dec14$9 = tooltip(), _dec15$8 = visible(), _dec16$8 = tooltip(), _dec17$7 = type(AxisDirection), _dec18$6 = tooltip(), _dec19$5 = tooltip(), _dec20$4 = tooltip(), _dec21$4 = tooltip(), _dec22$4 = tooltip(), _dec23$4 = tooltip(), _dec24$4 = tooltip(), _dec25$4 = type(VerticalDirection), _dec26$3 = tooltip(), _dec27$3 = type(HorizontalDirection), _dec28$3 = tooltip(), _dec29$3 = type(Constraint), _dec30$3 = visible(), _dec31$3 = tooltip(), _dec32$3 = visible(), _dec33$2 = tooltip(), _dec34$2 = tooltip(), _dec$x(_class$x = _dec2$r(_class$x = _dec3$q(_class$x = _dec4$o(_class$x = _dec5$l(_class$x = executeInEditMode(_class$x = (_class2$r = (_temp$u = _class3$9 = function (_Component) {
              _inheritsLoose(Layout, _Component);

              function Layout() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_resizeMode", _descriptor$q, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_layoutType", _descriptor2$m, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_cellSize", _descriptor3$j, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_startAxis", _descriptor4$f, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_paddingLeft", _descriptor5$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_paddingRight", _descriptor6$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_paddingTop", _descriptor7$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_paddingBottom", _descriptor8$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spacingX", _descriptor9$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spacingY", _descriptor10$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_verticalDirection", _descriptor11$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_horizontalDirection", _descriptor12$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_constraint", _descriptor13$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_constraintNum", _descriptor14$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_affectedByScale", _descriptor15$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAlign", _descriptor16$1, _assertThisInitialized(_this));

                _this._layoutSize = new Size(300, 200);
                _this._layoutDirty = true;
                _this._childrenDirty = false;
                _this._usefulLayoutObj = [];
                _this._init = false;
                return _this;
              }

              var _proto = Layout.prototype;

              _proto.updateLayout = function updateLayout(force) {
                if (force === void 0) {
                  force = false;
                }

                if ((this._layoutDirty || force) && this.node.children.length > 0) {
                  this._doLayout();

                  this._layoutDirty = false;
                }
              };

              _proto.onEnable = function onEnable() {
                this._addEventListeners();

                var trans = this.node._uiProps.uiTransformComp;

                if (trans.contentSize.equals(Size.ZERO)) {
                  trans.setContentSize(this._layoutSize);
                }

                this._doLayoutDirty();
              };

              _proto.onDisable = function onDisable() {
                this._usefulLayoutObj.length = 0;

                this._removeEventListeners();
              };

              _proto._checkUsefulObj = function _checkUsefulObj() {
                this._usefulLayoutObj.length = 0;
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  var uiTrans = child._uiProps.uiTransformComp;

                  if (child.activeInHierarchy && uiTrans) {
                    this._usefulLayoutObj.push(uiTrans);
                  }
                }
              };

              _proto._addEventListeners = function _addEventListeners() {
                director.on(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.on(NodeEvent.SIZE_CHANGED, this._resized, this);
                this.node.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.on(NodeEvent.CHILD_ADDED, this._childAdded, this);
                this.node.on(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
                this.node.on(NodeEvent.SIBLING_ORDER_CHANGED, this._childrenChanged, this);

                this._addChildrenEventListeners();
              };

              _proto._removeEventListeners = function _removeEventListeners() {
                director.off(Director.EVENT_AFTER_UPDATE, this.updateLayout, this);
                this.node.off(NodeEvent.SIZE_CHANGED, this._resized, this);
                this.node.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                this.node.off(NodeEvent.CHILD_ADDED, this._childAdded, this);
                this.node.off(NodeEvent.CHILD_REMOVED, this._childRemoved, this);
                this.node.off(NodeEvent.SIBLING_ORDER_CHANGED, this._childrenChanged, this);

                this._removeChildrenEventListeners();
              };

              _proto._addChildrenEventListeners = function _addChildrenEventListeners() {
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.on('active-in-hierarchy-changed', this._childrenChanged, this);
                }
              };

              _proto._removeChildrenEventListeners = function _removeChildrenEventListeners() {
                var children = this.node.children;

                for (var i = 0; i < children.length; ++i) {
                  var child = children[i];
                  child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
                  child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this);
                  child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                  child.off('active-in-hierarchy-changed', this._childrenChanged, this);
                }
              };

              _proto._childAdded = function _childAdded(child) {
                child.on(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
                child.on(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this);
                child.on(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.on('active-in-hierarchy-changed', this._childrenChanged, this);

                this._childrenChanged();
              };

              _proto._childRemoved = function _childRemoved(child) {
                child.off(NodeEvent.SIZE_CHANGED, this._doLayoutDirty, this);
                child.off(NodeEvent.TRANSFORM_CHANGED, this._transformDirty, this);
                child.off(NodeEvent.ANCHOR_CHANGED, this._doLayoutDirty, this);
                child.off('active-in-hierarchy-changed', this._childrenChanged, this);

                this._childrenChanged();
              };

              _proto._resized = function _resized() {
                this._layoutSize.set(this.node._uiProps.uiTransformComp.contentSize);

                this._doLayoutDirty();
              };

              _proto._doLayoutHorizontally = function _doLayoutHorizontally(baseWidth, rowBreak, fnPositionY, applyChildren) {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;

                var limit = this._getFixedColumn();

                var sign = 1;
                var paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  paddingX = this._paddingRight;
                }

                var startPos = (this._horizontalDirection - layoutAnchor.x) * baseWidth + sign * paddingX;
                var nextX = startPos - sign * this._spacingX;
                var totalHeight = 0;
                var rowMaxHeight = 0;
                var tempMaxHeight = 0;
                var maxHeight = 0;
                var isBreak = false;
                var activeChildCount = this._usefulLayoutObj.length;
                var newChildWidth = this._cellSize.width;

                var paddingH = this._getPaddingH();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildWidth = (baseWidth - paddingH - (activeChildCount - 1) * this._spacingX) / activeChildCount;
                }

                var children = this._usefulLayoutObj;

                for (var i = 0; i < children.length; ++i) {
                  var childTrans = children[i];
                  var child = childTrans.node;
                  var scale = child.scale;

                  var childScaleX = this._getUsedScaleValue(scale.x);

                  var childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.width = newChildWidth / childScaleX;

                    if (this._layoutType === Type.GRID) {
                      childTrans.height = this._cellSize.height / childScaleY;
                    }
                  }

                  var anchorX = Math.abs(this._horizontalDirection - childTrans.anchorX);
                  var childBoundingBoxWidth = childTrans.width * childScaleX;
                  var childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxHeight > tempMaxHeight) {
                    maxHeight = Math.max(tempMaxHeight, maxHeight);
                    rowMaxHeight = tempMaxHeight || childBoundingBoxHeight;
                    tempMaxHeight = childBoundingBoxHeight;
                  }

                  nextX += sign * (anchorX * childBoundingBoxWidth + this._spacingX);
                  var rightBoundaryOfChild = sign * (1 - anchorX) * childBoundingBoxWidth;

                  if (rowBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        rowMaxHeight = tempMaxHeight > childBoundingBoxHeight ? tempMaxHeight : rowMaxHeight;
                      }
                    } else if (childBoundingBoxWidth > baseWidth - paddingH) {
                      if (nextX > startPos + sign * (anchorX * childBoundingBoxWidth)) {
                        isBreak = true;
                      }
                    } else {
                      var boundary = (1 - this._horizontalDirection - layoutAnchor.x) * baseWidth;
                      var rowBreakBoundary = nextX + rightBoundaryOfChild + sign * (sign > 0 ? this._paddingRight : this._paddingLeft);
                      isBreak = Math.abs(rowBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextX = startPos + sign * (anchorX * childBoundingBoxWidth);

                      if (childBoundingBoxHeight !== tempMaxHeight) {
                        rowMaxHeight = tempMaxHeight;
                      }

                      totalHeight += rowMaxHeight + this._spacingY;
                      rowMaxHeight = tempMaxHeight = childBoundingBoxHeight;
                    }
                  }

                  var finalPositionY = fnPositionY(child, childTrans, totalHeight);

                  if (applyChildren) {
                    child.setPosition(nextX, finalPositionY);
                  }

                  nextX += rightBoundaryOfChild;
                }

                rowMaxHeight = Math.max(rowMaxHeight, tempMaxHeight);

                var containerResizeBoundary = Math.max(maxHeight, totalHeight + rowMaxHeight) + this._getPaddingV();

                return containerResizeBoundary;
              };

              _proto._doLayoutVertically = function _doLayoutVertically(baseHeight, columnBreak, fnPositionX, applyChildren) {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;

                var limit = this._getFixedColumn();

                var sign = 1;
                var paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  paddingY = this._paddingTop;
                }

                var startPos = (this._verticalDirection - layoutAnchor.y) * baseHeight + sign * paddingY;
                var nextY = startPos - sign * this._spacingY;
                var tempMaxWidth = 0;
                var maxWidth = 0;
                var colMaxWidth = 0;
                var totalWidth = 0;
                var isBreak = false;
                var activeChildCount = this._usefulLayoutObj.length;
                var newChildHeight = this._cellSize.height;

                var paddingV = this._getPaddingV();

                if (this._layoutType !== Type.GRID && this._resizeMode === ResizeMode.CHILDREN) {
                  newChildHeight = (baseHeight - paddingV - (activeChildCount - 1) * this._spacingY) / activeChildCount;
                }

                var children = this._usefulLayoutObj;

                for (var i = 0; i < children.length; ++i) {
                  var childTrans = children[i];
                  var child = childTrans.node;
                  var scale = child.scale;

                  var childScaleX = this._getUsedScaleValue(scale.x);

                  var childScaleY = this._getUsedScaleValue(scale.y);

                  if (this._resizeMode === ResizeMode.CHILDREN) {
                    childTrans.height = newChildHeight / childScaleY;

                    if (this._layoutType === Type.GRID) {
                      childTrans.width = this._cellSize.width / childScaleX;
                    }
                  }

                  var anchorY = Math.abs(this._verticalDirection - childTrans.anchorY);
                  var childBoundingBoxWidth = childTrans.width * childScaleX;
                  var childBoundingBoxHeight = childTrans.height * childScaleY;

                  if (childBoundingBoxWidth > tempMaxWidth) {
                    maxWidth = Math.max(tempMaxWidth, maxWidth);
                    colMaxWidth = tempMaxWidth || childBoundingBoxWidth;
                    tempMaxWidth = childBoundingBoxWidth;
                  }

                  nextY += sign * (anchorY * childBoundingBoxHeight + this._spacingY);
                  var topBoundaryOfChild = sign * (1 - anchorY) * childBoundingBoxHeight;

                  if (columnBreak) {
                    if (limit > 0) {
                      isBreak = i / limit > 0 && i % limit === 0;

                      if (isBreak) {
                        colMaxWidth = tempMaxWidth > childBoundingBoxHeight ? tempMaxWidth : colMaxWidth;
                      }
                    } else if (childBoundingBoxHeight > baseHeight - paddingV) {
                      if (nextY > startPos + sign * (anchorY * childBoundingBoxHeight)) {
                        isBreak = true;
                      }
                    } else {
                      var boundary = (1 - this._verticalDirection - layoutAnchor.y) * baseHeight;
                      var columnBreakBoundary = nextY + topBoundaryOfChild + sign * (sign > 0 ? this._paddingTop : this._paddingBottom);
                      isBreak = Math.abs(columnBreakBoundary) > Math.abs(boundary);
                    }

                    if (isBreak) {
                      nextY = startPos + sign * (anchorY * childBoundingBoxHeight);

                      if (childBoundingBoxWidth !== tempMaxWidth) {
                        colMaxWidth = tempMaxWidth;
                      }

                      totalWidth += colMaxWidth + this._spacingX;
                      colMaxWidth = tempMaxWidth = childBoundingBoxWidth;
                    }
                  }

                  var finalPositionX = fnPositionX(child, childTrans, totalWidth);

                  if (applyChildren) {
                    child.getPosition(_tempVec3);
                    child.setPosition(finalPositionX, nextY, _tempVec3.z);
                  }

                  nextY += topBoundaryOfChild;
                }

                colMaxWidth = Math.max(colMaxWidth, tempMaxWidth);

                var containerResizeBoundary = Math.max(maxWidth, totalWidth + colMaxWidth) + this._getPaddingH();

                return containerResizeBoundary;
              };

              _proto._doLayoutGridAxisHorizontal = function _doLayoutGridAxisHorizontal(layoutAnchor, layoutSize) {
                var _this2 = this;

                var baseWidth = layoutSize.width;
                var sign = 1;
                var bottomBoundaryOfLayout = -layoutAnchor.y * layoutSize.height;
                var paddingY = this._paddingBottom;

                if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                  sign = -1;
                  bottomBoundaryOfLayout = (1 - layoutAnchor.y) * layoutSize.height;
                  paddingY = this._paddingTop;
                }

                var fnPositionY = function fnPositionY(child, childTrans, topOffset) {
                  return bottomBoundaryOfLayout + sign * (topOffset + (1 - childTrans.anchorY) * childTrans.height * _this2._getUsedScaleValue(child.scale.y) + paddingY);
                };

                var newHeight = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newHeight = this._doLayoutHorizontally(baseWidth, true, fnPositionY, false);
                  bottomBoundaryOfLayout = -layoutAnchor.y * newHeight;

                  if (this._verticalDirection === VerticalDirection.TOP_TO_BOTTOM) {
                    sign = -1;
                    bottomBoundaryOfLayout = (1 - layoutAnchor.y) * newHeight;
                  }
                }

                this._doLayoutHorizontally(baseWidth, true, fnPositionY, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(baseWidth, newHeight);
                }
              };

              _proto._doLayoutGridAxisVertical = function _doLayoutGridAxisVertical(layoutAnchor, layoutSize) {
                var _this3 = this;

                var baseHeight = layoutSize.height;
                var sign = 1;
                var leftBoundaryOfLayout = -layoutAnchor.x * layoutSize.width;
                var paddingX = this._paddingLeft;

                if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                  sign = -1;
                  leftBoundaryOfLayout = (1 - layoutAnchor.x) * layoutSize.width;
                  paddingX = this._paddingRight;
                }

                var fnPositionX = function fnPositionX(child, childTrans, leftOffset) {
                  return leftBoundaryOfLayout + sign * (leftOffset + (1 - childTrans.anchorX) * childTrans.width * _this3._getUsedScaleValue(child.scale.x) + paddingX);
                };

                var newWidth = 0;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  newWidth = this._doLayoutVertically(baseHeight, true, fnPositionX, false);
                  leftBoundaryOfLayout = -layoutAnchor.x * newWidth;

                  if (this._horizontalDirection === HorizontalDirection.RIGHT_TO_LEFT) {
                    sign = -1;
                    leftBoundaryOfLayout = (1 - layoutAnchor.x) * newWidth;
                  }
                }

                this._doLayoutVertically(baseHeight, true, fnPositionX, true);

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  this.node._uiProps.uiTransformComp.setContentSize(newWidth, baseHeight);
                }
              };

              _proto._doLayoutGrid = function _doLayoutGrid() {
                var trans = this.node._uiProps.uiTransformComp;
                var layoutAnchor = trans.anchorPoint;
                var layoutSize = trans.contentSize;

                if (this.startAxis === AxisDirection.HORIZONTAL) {
                  this._doLayoutGridAxisHorizontal(layoutAnchor, layoutSize);
                } else if (this.startAxis === AxisDirection.VERTICAL) {
                  this._doLayoutGridAxisVertical(layoutAnchor, layoutSize);
                }
              };

              _proto._getHorizontalBaseWidth = function _getHorizontalBaseWidth(horizontal) {

                var children = this._usefulLayoutObj;
                var baseSize = 0;
                var activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (var i = 0; i < children.length; ++i) {
                    var childTrans = children[i];
                    var child = childTrans.node;
                    var scale = child.scale;
                    baseSize += childTrans.width * this._getUsedScaleValue(scale.x);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingX + this._getPaddingH();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.width;
                }

                return baseSize;
              };

              _proto._getVerticalBaseHeight = function _getVerticalBaseHeight() {
                var children = this._usefulLayoutObj;
                var baseSize = 0;
                var activeChildCount = children.length;

                if (this._resizeMode === ResizeMode.CONTAINER) {
                  for (var i = 0; i < children.length; ++i) {
                    var childTrans = children[i];
                    var child = childTrans.node;
                    var scale = child.scale;
                    baseSize += childTrans.height * this._getUsedScaleValue(scale.y);
                  }

                  baseSize += (activeChildCount - 1) * this._spacingY + this._getPaddingV();
                } else {
                  baseSize = this.node._uiProps.uiTransformComp.height;
                }

                return baseSize;
              };

              _proto._doLayout = function _doLayout() {
                var _this4 = this;

                if (!this._init || this._childrenDirty) {
                  this._checkUsefulObj();

                  this._init = true;
                  this._childrenDirty = false;
                }

                if (this._layoutType === Type.HORIZONTAL) {
                  var newWidth = this._getHorizontalBaseWidth();

                  var fnPositionY = function fnPositionY(child) {
                    var pos = _this4._isAlign ? Vec3.ZERO : child.position;
                    return pos.y;
                  };

                  this._doLayoutHorizontally(newWidth, false, fnPositionY, true);

                  this.node._uiProps.uiTransformComp.width = newWidth;
                } else if (this._layoutType === Type.VERTICAL) {
                  var newHeight = this._getVerticalBaseHeight();

                  var fnPositionX = function fnPositionX(child) {
                    var pos = _this4._isAlign ? Vec3.ZERO : child.position;
                    return pos.x;
                  };

                  this._doLayoutVertically(newHeight, false, fnPositionX, true);

                  this.node._uiProps.uiTransformComp.height = newHeight;
                } else if (this._layoutType === Type.GRID) {
                  this._doLayoutGrid();
                }
              };

              _proto._getUsedScaleValue = function _getUsedScaleValue(value) {
                return this._affectedByScale ? Math.abs(value) : 1;
              };

              _proto._transformDirty = function _transformDirty(type) {
                if (!(type & TransformBit.SCALE) || !(type & TransformBit.POSITION) || !this._affectedByScale) {
                  return;
                }

                this._doLayoutDirty();
              };

              _proto._doLayoutDirty = function _doLayoutDirty() {
                this._layoutDirty = true;
              };

              _proto._childrenChanged = function _childrenChanged() {
                this._childrenDirty = true;

                this._doLayoutDirty();
              };

              _proto._getPaddingH = function _getPaddingH() {
                return this._paddingLeft + this._paddingRight;
              };

              _proto._getPaddingV = function _getPaddingV() {
                return this._paddingTop + this._paddingBottom;
              };

              _proto._getFixedColumn = function _getFixedColumn() {
                if (this._layoutType !== Type.GRID || this._constraint === Constraint.NONE || this._constraintNum <= 0) {
                  return 0;
                }

                var num = this._constraint === Constraint.FIXED_ROW ? Math.round(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;

                if (this._startAxis === AxisDirection.VERTICAL) {
                  num = this._constraint === Constraint.FIXED_COL ? Math.round(this._usefulLayoutObj.length / this._constraintNum) : this._constraintNum;
                }

                return num;
              };

              _createClass(Layout, [{
                key: "alignHorizontal",
                get: function get() {
                  return this._isAlign;
                },
                set: function set(value) {
                  if (this._layoutType !== Type.HORIZONTAL) {
                    return;
                  }

                  this._isAlign = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "alignVertical",
                get: function get() {
                  return this._isAlign;
                },
                set: function set(value) {
                  if (this._layoutType !== Type.VERTICAL) {
                    return;
                  }

                  this._isAlign = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "type",
                get: function get() {
                  return this._layoutType;
                },
                set: function set(value) {
                  this._layoutType = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "resizeMode",
                get: function get() {
                  return this._resizeMode;
                },
                set: function set(value) {
                  if (this._layoutType === Type.NONE) {
                    return;
                  }

                  this._resizeMode = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "cellSize",
                get: function get() {
                  return this._cellSize;
                },
                set: function set(value) {
                  if (this._cellSize === value) {
                    return;
                  }

                  this._cellSize.set(value);

                  this._doLayoutDirty();
                }
              }, {
                key: "startAxis",
                get: function get() {
                  return this._startAxis;
                },
                set: function set(value) {
                  if (this._startAxis === value) {
                    return;
                  }

                  this._startAxis = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingLeft",
                get: function get() {
                  return this._paddingLeft;
                },
                set: function set(value) {
                  if (this._paddingLeft === value) {
                    return;
                  }

                  this._paddingLeft = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingRight",
                get: function get() {
                  return this._paddingRight;
                },
                set: function set(value) {
                  if (this._paddingRight === value) {
                    return;
                  }

                  this._paddingRight = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingTop",
                get: function get() {
                  return this._paddingTop;
                },
                set: function set(value) {
                  if (this._paddingTop === value) {
                    return;
                  }

                  this._paddingTop = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "paddingBottom",
                get: function get() {
                  return this._paddingBottom;
                },
                set: function set(value) {
                  if (this._paddingBottom === value) {
                    return;
                  }

                  this._paddingBottom = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "spacingX",
                get: function get() {
                  return this._spacingX;
                },
                set: function set(value) {
                  if (this._spacingX === value) {
                    return;
                  }

                  this._spacingX = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "spacingY",
                get: function get() {
                  return this._spacingY;
                },
                set: function set(value) {
                  if (this._spacingY === value) {
                    return;
                  }

                  this._spacingY = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "verticalDirection",
                get: function get() {
                  return this._verticalDirection;
                },
                set: function set(value) {
                  if (this._verticalDirection === value) {
                    return;
                  }

                  this._verticalDirection = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "horizontalDirection",
                get: function get() {
                  return this._horizontalDirection;
                },
                set: function set(value) {
                  if (this._horizontalDirection === value) {
                    return;
                  }

                  this._horizontalDirection = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "padding",
                get: function get() {
                  return this._paddingLeft;
                },
                set: function set(value) {
                  if (this.paddingLeft !== value || this._paddingRight !== value || this._paddingTop !== value || this._paddingBottom !== value) {
                    this._paddingLeft = this._paddingRight = this._paddingTop = this._paddingBottom = value;

                    this._doLayoutDirty();
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                },
                set: function set(value) {
                  if (this._layoutType === Type.NONE || this._constraint === value) {
                    return;
                  }

                  this._constraint = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "constraintNum",
                get: function get() {
                  return this._constraintNum;
                },
                set: function set(value) {
                  if (this._constraint === Constraint.NONE || this._constraintNum === value) {
                    return;
                  }

                  if (value <= 0) {
                    warn('Limit values to be greater than 0');
                  }

                  this._constraintNum = value;

                  this._doLayoutDirty();
                }
              }, {
                key: "affectedByScale",
                get: function get() {
                  return this._affectedByScale;
                },
                set: function set(value) {
                  this._affectedByScale = value;

                  this._doLayoutDirty();
                }
              }]);

              return Layout;
            }(Component), _class3$9.Type = Type, _class3$9.VerticalDirection = VerticalDirection, _class3$9.HorizontalDirection = HorizontalDirection, _class3$9.ResizeMode = ResizeMode, _class3$9.AxisDirection = AxisDirection, _class3$9.Constraint = Constraint, _temp$u), (_applyDecoratedDescriptor(_class2$r.prototype, "alignHorizontal", [_dec6$k, _dec7$k], Object.getOwnPropertyDescriptor(_class2$r.prototype, "alignHorizontal"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "alignVertical", [_dec8$h, _dec9$f], Object.getOwnPropertyDescriptor(_class2$r.prototype, "alignVertical"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "type", [_dec10$d, _dec11$c], Object.getOwnPropertyDescriptor(_class2$r.prototype, "type"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "resizeMode", [_dec12$b, _dec13$b, _dec14$9], Object.getOwnPropertyDescriptor(_class2$r.prototype, "resizeMode"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "cellSize", [_dec15$8, _dec16$8], Object.getOwnPropertyDescriptor(_class2$r.prototype, "cellSize"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "startAxis", [_dec17$7, _dec18$6], Object.getOwnPropertyDescriptor(_class2$r.prototype, "startAxis"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "paddingLeft", [_dec19$5], Object.getOwnPropertyDescriptor(_class2$r.prototype, "paddingLeft"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "paddingRight", [_dec20$4], Object.getOwnPropertyDescriptor(_class2$r.prototype, "paddingRight"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "paddingTop", [_dec21$4], Object.getOwnPropertyDescriptor(_class2$r.prototype, "paddingTop"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "paddingBottom", [_dec22$4], Object.getOwnPropertyDescriptor(_class2$r.prototype, "paddingBottom"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "spacingX", [_dec23$4], Object.getOwnPropertyDescriptor(_class2$r.prototype, "spacingX"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "spacingY", [_dec24$4], Object.getOwnPropertyDescriptor(_class2$r.prototype, "spacingY"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "verticalDirection", [_dec25$4, _dec26$3], Object.getOwnPropertyDescriptor(_class2$r.prototype, "verticalDirection"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "horizontalDirection", [_dec27$3, _dec28$3], Object.getOwnPropertyDescriptor(_class2$r.prototype, "horizontalDirection"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "constraint", [_dec29$3, _dec30$3, _dec31$3], Object.getOwnPropertyDescriptor(_class2$r.prototype, "constraint"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "constraintNum", [_dec32$3, _dec33$2], Object.getOwnPropertyDescriptor(_class2$r.prototype, "constraintNum"), _class2$r.prototype), _applyDecoratedDescriptor(_class2$r.prototype, "affectedByScale", [_dec34$2], Object.getOwnPropertyDescriptor(_class2$r.prototype, "affectedByScale"), _class2$r.prototype), _descriptor$q = _applyDecoratedDescriptor(_class2$r.prototype, "_resizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ResizeMode.NONE;
              }
            }), _descriptor2$m = _applyDecoratedDescriptor(_class2$r.prototype, "_layoutType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Type.NONE;
              }
            }), _descriptor3$j = _applyDecoratedDescriptor(_class2$r.prototype, "_cellSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Size(40, 40);
              }
            }), _descriptor4$f = _applyDecoratedDescriptor(_class2$r.prototype, "_startAxis", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return AxisDirection.HORIZONTAL;
              }
            }), _descriptor5$c = _applyDecoratedDescriptor(_class2$r.prototype, "_paddingLeft", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor6$9 = _applyDecoratedDescriptor(_class2$r.prototype, "_paddingRight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor7$8 = _applyDecoratedDescriptor(_class2$r.prototype, "_paddingTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor8$8 = _applyDecoratedDescriptor(_class2$r.prototype, "_paddingBottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor9$7 = _applyDecoratedDescriptor(_class2$r.prototype, "_spacingX", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor10$6 = _applyDecoratedDescriptor(_class2$r.prototype, "_spacingY", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor11$5 = _applyDecoratedDescriptor(_class2$r.prototype, "_verticalDirection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return VerticalDirection.TOP_TO_BOTTOM;
              }
            }), _descriptor12$4 = _applyDecoratedDescriptor(_class2$r.prototype, "_horizontalDirection", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return HorizontalDirection.LEFT_TO_RIGHT;
              }
            }), _descriptor13$3 = _applyDecoratedDescriptor(_class2$r.prototype, "_constraint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Constraint.NONE;
              }
            }), _descriptor14$2 = _applyDecoratedDescriptor(_class2$r.prototype, "_constraintNum", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 2;
              }
            }), _descriptor15$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_affectedByScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class2$r.prototype, "_isAlign", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            })), _class2$r)) || _class$x) || _class$x) || _class$x) || _class$x) || _class$x) || _class$x));

            var _dec$y, _dec2$s, _dec3$r, _dec4$p, _dec5$m, _dec6$l, _dec7$l, _dec8$i, _dec9$g, _dec10$e, _dec11$d, _dec12$c, _dec13$c, _class$y, _class2$s, _descriptor$r, _descriptor2$n, _descriptor3$k, _descriptor4$g, _descriptor5$d, _class3$a, _temp$v;
            var Mode;

            (function (Mode) {
              Mode[Mode["HORIZONTAL"] = 0] = "HORIZONTAL";
              Mode[Mode["VERTICAL"] = 1] = "VERTICAL";
              Mode[Mode["FILLED"] = 2] = "FILLED";
            })(Mode || (Mode = {}));

            Enum(Mode);
            var ProgressBar = function (v) { return exports({ ProgressBar: v, ProgressBarComponent: v }), v; }((_dec$y = ccclass('cc.ProgressBar'), _dec2$s = help(), _dec3$r = executionOrder(110), _dec4$p = menu(), _dec5$m = requireComponent(UITransform), _dec6$l = type(Sprite), _dec7$l = tooltip(), _dec8$i = type(Mode), _dec9$g = tooltip(), _dec10$e = tooltip(), _dec11$d = range(), _dec12$c = tooltip(), _dec13$c = tooltip(), _dec$y(_class$y = _dec2$s(_class$y = _dec3$r(_class$y = _dec4$p(_class$y = _dec5$m(_class$y = (_class2$s = (_temp$v = _class3$a = function (_Component) {
              _inheritsLoose(ProgressBar, _Component);

              function ProgressBar() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_barSprite", _descriptor$r, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_mode", _descriptor2$n, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_totalLength", _descriptor3$k, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_progress", _descriptor4$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_reverse", _descriptor5$d, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = ProgressBar.prototype;

              _proto._initBarSprite = function _initBarSprite() {
                if (this._barSprite) {
                  var entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  var trans = this.node._uiProps.uiTransformComp;
                  var nodeSize = trans.contentSize;
                  var nodeAnchor = trans.anchorPoint;
                  var barSpriteSize = entity._uiProps.uiTransformComp.contentSize;

                  if (this._barSprite.fillType === Sprite.FillType.RADIAL) {
                    this._mode = Mode.FILLED;
                  }

                  if (this._mode === Mode.HORIZONTAL) {
                    this.totalLength = barSpriteSize.width;
                  } else if (this._mode === Mode.VERTICAL) {
                    this.totalLength = barSpriteSize.height;
                  } else {
                    this.totalLength = this._barSprite.fillRange;
                  }

                  if (entity.parent === this.node) {
                    var x = -nodeSize.width * nodeAnchor.x;
                    entity.setPosition(x, 0, 0);
                  }
                }
              };

              _proto._updateBarStatus = function _updateBarStatus() {
                if (this._barSprite) {
                  var entity = this._barSprite.node;

                  if (!entity) {
                    return;
                  }

                  var entTrans = entity._uiProps.uiTransformComp;
                  var entityAnchorPoint = entTrans.anchorPoint;
                  var entitySize = entTrans.contentSize;
                  var entityPosition = entity.getPosition();
                  var anchorPoint = new Vec2(0, 0.5);
                  var progress = clamp01(this._progress);
                  var actualLenth = this._totalLength * progress;
                  var finalContentSize = entitySize;
                  var totalWidth = 0;
                  var totalHeight = 0;

                  switch (this._mode) {
                    case Mode.HORIZONTAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(1, 0.5);
                      }

                      finalContentSize = new Size(actualLenth, entitySize.height);
                      totalWidth = this._totalLength;
                      totalHeight = entitySize.height;
                      break;

                    case Mode.VERTICAL:
                      if (this._reverse) {
                        anchorPoint = new Vec2(0.5, 1);
                      } else {
                        anchorPoint = new Vec2(0.5, 0);
                      }

                      finalContentSize = new Size(entitySize.width, actualLenth);
                      totalWidth = entitySize.width;
                      totalHeight = this._totalLength;
                      break;
                  }

                  if (this._mode === Mode.FILLED) {
                    if (this._barSprite.type !== Sprite.Type.FILLED) {
                      warn('ProgressBar FILLED mode only works when barSprite\'s Type is FILLED!');
                    } else {
                      if (this._reverse) {
                        actualLenth *= -1;
                      }

                      this._barSprite.fillRange = actualLenth;
                    }
                  } else if (this._barSprite.type !== Sprite.Type.FILLED) {
                    var anchorOffsetX = anchorPoint.x - entityAnchorPoint.x;
                    var anchorOffsetY = anchorPoint.y - entityAnchorPoint.y;
                    var finalPosition = new Vec3(totalWidth * anchorOffsetX, totalHeight * anchorOffsetY, 0);
                    entity.setPosition(entityPosition.x + finalPosition.x, entityPosition.y + finalPosition.y, entityPosition.z);
                    entTrans.setAnchorPoint(anchorPoint);
                    entTrans.setContentSize(finalContentSize);
                  } else {
                    warn('ProgressBar non-FILLED mode only works when barSprite\'s Type is non-FILLED!');
                  }
                }
              };

              _createClass(ProgressBar, [{
                key: "barSprite",
                get: function get() {
                  return this._barSprite;
                },
                set: function set(value) {
                  if (this._barSprite === value) {
                    return;
                  }

                  this._barSprite = value;

                  this._initBarSprite();
                }
              }, {
                key: "mode",
                get: function get() {
                  return this._mode;
                },
                set: function set(value) {
                  if (this._mode === value) {
                    return;
                  }

                  this._mode = value;

                  if (this._barSprite) {
                    var entity = this._barSprite.node;

                    if (!entity) {
                      return;
                    }

                    var entitySize = entity._uiProps.uiTransformComp.contentSize;

                    if (this._mode === Mode.HORIZONTAL) {
                      this.totalLength = entitySize.width;
                    } else if (this._mode === Mode.VERTICAL) {
                      this.totalLength = entitySize.height;
                    } else if (this._mode === Mode.FILLED) {
                      this.totalLength = this._barSprite.fillRange;
                    }
                  }
                }
              }, {
                key: "totalLength",
                get: function get() {
                  return this._totalLength;
                },
                set: function set(value) {
                  if (this._mode === Mode.FILLED) {
                    value = clamp01(value);
                  }

                  this._totalLength = value;

                  this._updateBarStatus();
                }
              }, {
                key: "progress",
                get: function get() {
                  return this._progress;
                },
                set: function set(value) {
                  if (this._progress === value) {
                    return;
                  }

                  this._progress = value;

                  this._updateBarStatus();
                }
              }, {
                key: "reverse",
                get: function get() {
                  return this._reverse;
                },
                set: function set(value) {
                  if (this._reverse === value) {
                    return;
                  }

                  this._reverse = value;

                  if (this._barSprite) {
                    this._barSprite.fillStart = 1 - this._barSprite.fillStart;
                  }

                  this._updateBarStatus();
                }
              }]);

              return ProgressBar;
            }(Component), _class3$a.Mode = Mode, _temp$v), (_applyDecoratedDescriptor(_class2$s.prototype, "barSprite", [_dec6$l, _dec7$l], Object.getOwnPropertyDescriptor(_class2$s.prototype, "barSprite"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "mode", [_dec8$i, _dec9$g], Object.getOwnPropertyDescriptor(_class2$s.prototype, "mode"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "totalLength", [_dec10$e], Object.getOwnPropertyDescriptor(_class2$s.prototype, "totalLength"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "progress", [_dec11$d, slide, _dec12$c], Object.getOwnPropertyDescriptor(_class2$s.prototype, "progress"), _class2$s.prototype), _applyDecoratedDescriptor(_class2$s.prototype, "reverse", [_dec13$c], Object.getOwnPropertyDescriptor(_class2$s.prototype, "reverse"), _class2$s.prototype), _descriptor$r = _applyDecoratedDescriptor(_class2$s.prototype, "_barSprite", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$s.prototype, "_mode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Mode.HORIZONTAL;
              }
            }), _descriptor3$k = _applyDecoratedDescriptor(_class2$s.prototype, "_totalLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor4$g = _applyDecoratedDescriptor(_class2$s.prototype, "_progress", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor5$d = _applyDecoratedDescriptor(_class2$s.prototype, "_reverse", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            })), _class2$s)) || _class$y) || _class$y) || _class$y) || _class$y) || _class$y));

            var _dec$z, _dec2$t, _dec3$s, _dec4$q, _dec5$n, _dec6$m, _dec7$m, _dec8$j, _dec9$h, _dec10$f, _dec11$e, _dec12$d, _dec13$d, _dec14$a, _dec15$9, _class$z, _class2$t, _descriptor$s, _descriptor2$o, _descriptor3$l, _descriptor4$h, _descriptor5$e, _class3$b, _temp$w;
            var GETTING_SHORTER_FACTOR = 20;
            var ZERO = new Vec3();

            var _tempPos_1 = new Vec3();

            var _tempPos_2 = new Vec3();

            var defaultAnchor = new Vec2();

            var _tempColor$1 = new Color();

            var Direction;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction || (Direction = {}));

            ccenum(Direction);
            var ScrollBar = function (v) { return exports({ ScrollBar: v, ScrollBarComponent: v }), v; }((_dec$z = ccclass('cc.ScrollBar'), _dec2$t = help(), _dec3$s = executionOrder(110), _dec4$q = menu(), _dec5$n = requireComponent(UITransform), _dec6$m = type(Sprite), _dec7$m = displayOrder(), _dec8$j = tooltip(), _dec9$h = type(Direction), _dec10$f = displayOrder(), _dec11$e = tooltip(), _dec12$d = displayOrder(), _dec13$d = tooltip(), _dec14$a = displayOrder(), _dec15$9 = tooltip(), _dec$z(_class$z = _dec2$t(_class$z = _dec3$s(_class$z = _dec4$q(_class$z = _dec5$n(_class$z = (_class2$t = (_temp$w = _class3$b = function (_Component) {
              _inheritsLoose(ScrollBar, _Component);

              function ScrollBar() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_scrollView", _descriptor$s, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_handle", _descriptor2$o, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$l, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_enableAutoHide", _descriptor4$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_autoHideTime", _descriptor5$e, _assertThisInitialized(_this));

                _this._touching = false;
                _this._opacity = 255;
                _this._autoHideRemainingTime = 0;
                return _this;
              }

              var _proto = ScrollBar.prototype;

              _proto.hide = function hide() {
                this._autoHideRemainingTime = 0;

                this._setOpacity(0);
              };

              _proto.show = function show() {
                this._autoHideRemainingTime = this._autoHideTime;

                this._setOpacity(this._opacity);
              };

              _proto.onScroll = function onScroll(outOfBoundary) {
                if (!this._scrollView) {
                  return;
                }

                var content = this._scrollView.content;

                if (!content) {
                  return;
                }

                var contentSize = content._uiProps.uiTransformComp.contentSize;
                var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;
                var barSize = this.node._uiProps.uiTransformComp.contentSize;

                if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                  return;
                }

                if (this._enableAutoHide) {
                  this._autoHideRemainingTime = this._autoHideTime;

                  this._setOpacity(this._opacity);
                }

                var contentMeasure = 0;
                var scrollViewMeasure = 0;
                var outOfBoundaryValue = 0;
                var contentPosition = 0;
                var handleNodeMeasure = 0;

                if (this._direction === Direction.HORIZONTAL) {
                  contentMeasure = contentSize.width;
                  scrollViewMeasure = scrollViewSize.width;
                  handleNodeMeasure = barSize.width;
                  outOfBoundaryValue = outOfBoundary.x;
                  contentPosition = -this._convertToScrollViewSpace(content).x;
                } else if (this._direction === Direction.VERTICAL) {
                  contentMeasure = contentSize.height;
                  scrollViewMeasure = scrollViewSize.height;
                  handleNodeMeasure = barSize.height;
                  outOfBoundaryValue = outOfBoundary.y;
                  contentPosition = -this._convertToScrollViewSpace(content).y;
                }

                var length = this._calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundaryValue);

                var position = this._calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundaryValue, length);

                this._updateLength(length);

                this._updateHandlerPosition(position);
              };

              _proto.setScrollView = function setScrollView(scrollView) {
                this._scrollView = scrollView;
              };

              _proto.onTouchBegan = function onTouchBegan() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = true;
              };

              _proto.onTouchEnded = function onTouchEnded() {
                if (!this._enableAutoHide) {
                  return;
                }

                this._touching = false;

                if (this._autoHideTime <= 0) {
                  return;
                }

                if (this._scrollView) {
                  var content = this._scrollView.content;

                  if (content) {
                    var contentSize = content._uiProps.uiTransformComp.contentSize;
                    var scrollViewSize = this._scrollView.node._uiProps.uiTransformComp.contentSize;

                    if (this._conditionalDisableScrollBar(contentSize, scrollViewSize)) {
                      return;
                    }
                  }
                }

                this._autoHideRemainingTime = this._autoHideTime;
              };

              _proto.onEnable = function onEnable() {
                var renderComp = this.node.getComponent(Sprite);

                if (renderComp) {
                  this._opacity = renderComp.color.a;
                }
              };

              _proto.start = function start() {
                if (this._enableAutoHide) {
                  this._setOpacity(0);
                }
              };

              _proto.update = function update(dt) {
                this._processAutoHide(dt);
              };

              _proto._convertToScrollViewSpace = function _convertToScrollViewSpace(content) {
                var scrollTrans = this._scrollView && this._scrollView.node._uiProps.uiTransformComp;
                var contentTrans = content._uiProps.uiTransformComp;

                if (!scrollTrans || !contentTrans) {
                  return ZERO;
                }

                _tempPos_1.set(-contentTrans.anchorX * contentTrans.width, -contentTrans.anchorY * contentTrans.height, 0);

                contentTrans.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);
                var scrollViewSpacePos = scrollTrans.convertToNodeSpaceAR(_tempPos_2);
                scrollViewSpacePos.x += scrollTrans.anchorX * scrollTrans.width;
                scrollViewSpacePos.y += scrollTrans.anchorY * scrollTrans.height;
                return scrollViewSpacePos;
              };

              _proto._setOpacity = function _setOpacity(opacity) {
                if (this._handle) {
                  var renderComp = this.node.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }

                  renderComp = this._handle.getComponent(Sprite);

                  if (renderComp) {
                    _tempColor$1.set(renderComp.color);

                    _tempColor$1.a = opacity;
                    renderComp.color = _tempColor$1;
                  }
                }
              };

              _proto._updateHandlerPosition = function _updateHandlerPosition(position) {
                if (this._handle) {
                  var oldPosition = this._fixupHandlerPosition();

                  this._handle.node.setPosition(position.x + oldPosition.x, position.y + oldPosition.y, oldPosition.z);
                }
              };

              _proto._fixupHandlerPosition = function _fixupHandlerPosition() {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var barSize = uiTrans.contentSize;
                var barAnchor = uiTrans.anchorPoint;
                var handleSize = this.handle.node._uiProps.uiTransformComp.contentSize;
                var handleParent = this.handle.node.parent;
                Vec3.set(_tempPos_1, -barSize.width * barAnchor.x, -barSize.height * barAnchor.y, 0);

                var leftBottomWorldPosition = this.node._uiProps.uiTransformComp.convertToWorldSpaceAR(_tempPos_1, _tempPos_2);

                var fixupPosition = new Vec3();

                handleParent._uiProps.uiTransformComp.convertToNodeSpaceAR(leftBottomWorldPosition, fixupPosition);

                if (this.direction === Direction.HORIZONTAL) {
                  fixupPosition = new Vec3(fixupPosition.x, fixupPosition.y + (barSize.height - handleSize.height) / 2, 0);
                } else if (this.direction === Direction.VERTICAL) {
                  fixupPosition = new Vec3(fixupPosition.x + (barSize.width - handleSize.width) / 2, fixupPosition.y, 0);
                }

                this.handle.node.setPosition(fixupPosition);
                return fixupPosition;
              };

              _proto._conditionalDisableScrollBar = function _conditionalDisableScrollBar(contentSize, scrollViewSize) {
                if (contentSize.width <= scrollViewSize.width && this._direction === Direction.HORIZONTAL) {
                  return true;
                }

                if (contentSize.height <= scrollViewSize.height && this._direction === Direction.VERTICAL) {
                  return true;
                }

                return false;
              };

              _proto._calculateLength = function _calculateLength(contentMeasure, scrollViewMeasure, handleNodeMeasure, outOfBoundary) {
                var denominatorValue = contentMeasure;

                if (outOfBoundary) {
                  denominatorValue += (outOfBoundary > 0 ? outOfBoundary : -outOfBoundary) * GETTING_SHORTER_FACTOR;
                }

                var lengthRation = scrollViewMeasure / denominatorValue;
                return handleNodeMeasure * lengthRation;
              };

              _proto._calculatePosition = function _calculatePosition(contentMeasure, scrollViewMeasure, handleNodeMeasure, contentPosition, outOfBoundary, actualLenth) {
                var denominatorValue = contentMeasure - scrollViewMeasure;

                if (outOfBoundary) {
                  denominatorValue += Math.abs(outOfBoundary);
                }

                var positionRatio = 0;

                if (denominatorValue) {
                  positionRatio = contentPosition / denominatorValue;
                  positionRatio = clamp01(positionRatio);
                }

                var position = (handleNodeMeasure - actualLenth) * positionRatio;

                if (this._direction === Direction.VERTICAL) {
                  return new Vec3(0, position, 0);
                } else {
                  return new Vec3(position, 0, 0);
                }
              };

              _proto._updateLength = function _updateLength(length) {
                if (this._handle) {
                  var handleNode = this._handle.node;
                  var handleTrans = handleNode._uiProps.uiTransformComp;
                  var handleNodeSize = handleTrans.contentSize;
                  var anchor = handleTrans.anchorPoint;

                  if (anchor.x !== defaultAnchor.x || anchor.y !== defaultAnchor.y) {
                    handleTrans.setAnchorPoint(defaultAnchor);
                  }

                  if (this._direction === Direction.HORIZONTAL) {
                    handleTrans.setContentSize(length, handleNodeSize.height);
                  } else {
                    handleTrans.setContentSize(handleNodeSize.width, length);
                  }
                }
              };

              _proto._processAutoHide = function _processAutoHide(deltaTime) {
                if (!this._enableAutoHide || this._autoHideRemainingTime <= 0) {
                  return;
                } else if (this._touching) {
                  return;
                }

                this._autoHideRemainingTime -= deltaTime;

                if (this._autoHideRemainingTime <= this._autoHideTime) {
                  this._autoHideRemainingTime = Math.max(0, this._autoHideRemainingTime);
                  var opacity = this._opacity * (this._autoHideRemainingTime / this._autoHideTime);

                  this._setOpacity(opacity);
                }
              };

              _createClass(ScrollBar, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                },
                set: function set(value) {
                  if (this._handle === value) {
                    return;
                  }

                  this._handle = value;
                  this.onScroll(ZERO);
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;
                  this.onScroll(new Vec3());
                }
              }, {
                key: "enableAutoHide",
                get: function get() {
                  return this._enableAutoHide;
                },
                set: function set(value) {
                  if (this._enableAutoHide === value) {
                    return;
                  }

                  this._enableAutoHide = value;

                  if (this._enableAutoHide) {
                    this._setOpacity(0);
                  }
                }
              }, {
                key: "autoHideTime",
                get: function get() {
                  return this._autoHideTime;
                },
                set: function set(value) {
                  if (this._autoHideTime === value) {
                    return;
                  }

                  this._autoHideTime = value;
                }
              }]);

              return ScrollBar;
            }(Component), _class3$b.Direction = Direction, _temp$w), (_applyDecoratedDescriptor(_class2$t.prototype, "handle", [_dec6$m, _dec7$m, _dec8$j], Object.getOwnPropertyDescriptor(_class2$t.prototype, "handle"), _class2$t.prototype), _applyDecoratedDescriptor(_class2$t.prototype, "direction", [_dec9$h, _dec10$f, _dec11$e], Object.getOwnPropertyDescriptor(_class2$t.prototype, "direction"), _class2$t.prototype), _applyDecoratedDescriptor(_class2$t.prototype, "enableAutoHide", [_dec12$d, _dec13$d], Object.getOwnPropertyDescriptor(_class2$t.prototype, "enableAutoHide"), _class2$t.prototype), _applyDecoratedDescriptor(_class2$t.prototype, "autoHideTime", [_dec14$a, _dec15$9], Object.getOwnPropertyDescriptor(_class2$t.prototype, "autoHideTime"), _class2$t.prototype), _descriptor$s = _applyDecoratedDescriptor(_class2$t.prototype, "_scrollView", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$o = _applyDecoratedDescriptor(_class2$t.prototype, "_handle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$l = _applyDecoratedDescriptor(_class2$t.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Direction.HORIZONTAL;
              }
            }), _descriptor4$h = _applyDecoratedDescriptor(_class2$t.prototype, "_enableAutoHide", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor5$e = _applyDecoratedDescriptor(_class2$t.prototype, "_autoHideTime", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1.0;
              }
            })), _class2$t)) || _class$z) || _class$z) || _class$z) || _class$z) || _class$z));

            var _dec$A, _dec2$u, _class$A;
            var ViewGroup = exports('ViewGroup', (_dec$A = ccclass('cc.ViewGroup'), _dec2$u = executionOrder(110), _dec$A(_class$A = _dec2$u(_class$A = function (_Component) {
              _inheritsLoose(ViewGroup, _Component);

              function ViewGroup() {
                return _Component.apply(this, arguments) || this;
              }

              return ViewGroup;
            }(Component)) || _class$A) || _class$A));
            legacyCC.ViewGroup = ViewGroup;

            var _dec$B, _dec2$v, _dec3$t, _dec4$r, _dec5$o, _dec6$n, _dec7$n, _dec8$k, _dec9$i, _dec10$g, _dec11$f, _dec12$e, _dec13$e, _dec14$b, _dec15$a, _dec16$9, _dec17$8, _dec18$7, _dec19$6, _dec20$5, _dec21$5, _dec22$5, _dec23$5, _dec24$5, _dec25$5, _dec26$4, _dec27$4, _dec28$4, _dec29$4, _dec30$4, _dec31$4, _dec32$4, _dec33$3, _class$B, _class2$u, _descriptor$t, _descriptor2$p, _descriptor3$m, _descriptor4$i, _descriptor5$f, _descriptor6$a, _descriptor7$9, _descriptor8$9, _descriptor9$8, _descriptor10$7, _descriptor11$6, _class3$c, _temp$x;
            var NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED = 5;
            var OUT_OF_BOUNDARY_BREAKING_FACTOR = 0.05;
            var EPSILON$1 = 1e-4;
            var TOLERANCE = 1e4;
            var MOVEMENT_FACTOR = 0.7;
            var ZERO$1 = new Vec3();

            var _tempVec3$1 = new Vec3();

            var _tempVec3_1 = new Vec3();

            var _tempVec2 = new Vec2();

            var _tempVec2_1 = new Vec2();

            var quintEaseOut = function quintEaseOut(time) {
              time -= 1;
              return time * time * time * time * time + 1;
            };

            var getTimeInMilliseconds = function getTimeInMilliseconds() {
              var currentTime = new Date();
              return currentTime.getMilliseconds();
            };

            var eventMap = {
              'scroll-to-top': 0,
              'scroll-to-bottom': 1,
              'scroll-to-left': 2,
              'scroll-to-right': 3,
              scrolling: 4,
              'bounce-bottom': 6,
              'bounce-left': 7,
              'bounce-right': 8,
              'bounce-top': 5,
              'scroll-ended': 9,
              'touch-up': 10,
              'scroll-ended-with-threshold': 11,
              'scroll-began': 12
            };
            var EventType$3;

            (function (EventType) {
              EventType["SCROLL_TO_TOP"] = "scroll-to-top";
              EventType["SCROLL_TO_BOTTOM"] = "scroll-to-bottom";
              EventType["SCROLL_TO_LEFT"] = "scroll-to-left";
              EventType["SCROLL_TO_RIGHT"] = "scroll-to-right";
              EventType["SCROLL_BEGAN"] = "scroll-began";
              EventType["SCROLL_ENDED"] = "scroll-ended";
              EventType["BOUNCE_TOP"] = "bounce-top";
              EventType["BOUNCE_BOTTOM"] = "bounce-bottom";
              EventType["BOUNCE_LEFT"] = "bounce-left";
              EventType["BOUNCE_RIGHT"] = "bounce-right";
              EventType["SCROLLING"] = "scrolling";
              EventType["SCROLL_ENG_WITH_THRESHOLD"] = "scroll-ended-with-threshold";
              EventType["TOUCH_UP"] = "touch-up";
            })(EventType$3 || (EventType$3 = {}));

            var ScrollView = function (v) { return exports({ ScrollView: v, ScrollViewComponent: v }), v; }((_dec$B = ccclass('cc.ScrollView'), _dec2$v = help(), _dec3$t = executionOrder(110), _dec4$r = menu(), _dec5$o = requireComponent(UITransform), _dec6$n = range(), _dec7$n = displayOrder(), _dec8$k = tooltip(), _dec9$i = range(), _dec10$g = displayOrder(), _dec11$f = tooltip(), _dec12$e = displayOrder(), _dec13$e = tooltip(), _dec14$b = displayOrder(), _dec15$a = tooltip(), _dec16$9 = type(Node), _dec17$8 = displayOrder(), _dec18$7 = tooltip(), _dec19$6 = displayOrder(), _dec20$5 = tooltip(), _dec21$5 = type(ScrollBar), _dec22$5 = displayOrder(), _dec23$5 = tooltip(), _dec24$5 = displayOrder(), _dec25$5 = tooltip(), _dec26$4 = type(ScrollBar), _dec27$4 = displayOrder(), _dec28$4 = tooltip(), _dec29$4 = displayOrder(), _dec30$4 = tooltip(), _dec31$4 = type([EventHandler]), _dec32$4 = displayOrder(), _dec33$3 = tooltip(), _dec$B(_class$B = _dec2$v(_class$B = _dec3$t(_class$B = _dec4$r(_class$B = _dec5$o(_class$B = (_class2$u = (_temp$x = _class3$c = function (_ViewGroup) {
              _inheritsLoose(ScrollView, _ViewGroup);

              function ScrollView() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ViewGroup.call.apply(_ViewGroup, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "bounceDuration", _descriptor$t, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "brake", _descriptor2$p, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "elastic", _descriptor3$m, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "inertia", _descriptor4$i, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "horizontal", _descriptor5$f, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "vertical", _descriptor6$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor7$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "scrollEvents", _descriptor8$9, _assertThisInitialized(_this));

                _this._autoScrolling = false;
                _this._scrolling = false;

                _initializerDefineProperty(_this, "_content", _descriptor9$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_horizontalScrollBar", _descriptor10$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_verticalScrollBar", _descriptor11$6, _assertThisInitialized(_this));

                _this._topBoundary = 0;
                _this._bottomBoundary = 0;
                _this._leftBoundary = 0;
                _this._rightBoundary = 0;
                _this._touchMoveDisplacements = [];
                _this._touchMoveTimeDeltas = [];
                _this._touchMovePreviousTimestamp = 0;
                _this._touchMoved = false;
                _this._autoScrollAttenuate = false;
                _this._autoScrollStartPosition = new Vec3();
                _this._autoScrollTargetDelta = new Vec3();
                _this._autoScrollTotalTime = 0;
                _this._autoScrollAccumulatedTime = 0;
                _this._autoScrollCurrentlyOutOfBoundary = false;
                _this._autoScrollBraking = false;
                _this._autoScrollBrakingStartPosition = new Vec3();
                _this._outOfBoundaryAmount = new Vec3();
                _this._outOfBoundaryAmountDirty = true;
                _this._stopMouseWheel = false;
                _this._mouseWheelEventElapsedTime = 0.0;
                _this._isScrollEndedWithThresholdEventFired = false;
                _this._scrollEventEmitMask = 0;
                _this._isBouncing = false;
                _this._contentPos = new Vec3();
                _this._deltaPos = new Vec3();
                return _this;
              }

              var _proto = ScrollView.prototype;

              _proto.scrollToBottom = function scrollToBottom(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta, true);
                }
              };

              _proto.scrollToTop = function scrollToTop(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToLeft = function scrollToLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToRight = function scrollToRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToTopLeft = function scrollToTopLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToTopRight = function scrollToTopRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 1),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToBottomLeft = function scrollToBottomLeft(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToBottomRight = function scrollToBottomRight(timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(1, 0),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToOffset = function scrollToOffset(offset, timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = true;
                }

                var maxScrollOffset = this.getMaxScrollOffset();
                var anchor = new Vec2(0, 0);

                if (maxScrollOffset.x === 0) {
                  anchor.x = 0;
                } else {
                  anchor.x = offset.x / maxScrollOffset.x;
                }

                if (maxScrollOffset.y === 0) {
                  anchor.y = 1;
                } else {
                  anchor.y = (maxScrollOffset.y - offset.y) / maxScrollOffset.y;
                }

                this.scrollTo(anchor, timeInSecond, attenuated);
              };

              _proto.getScrollOffset = function getScrollOffset() {
                var topDelta = this._getContentTopBoundary() - this._topBoundary;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                return new Vec3(leftDelta, topDelta, 0);
              };

              _proto.getMaxScrollOffset = function getMaxScrollOffset() {
                if (!this._content || !this.view) {
                  return ZERO$1;
                }

                var contentSize = this._content._uiProps.uiTransformComp.contentSize;
                var horizontalMaximizeOffset = contentSize.width - this.view.width;
                var verticalMaximizeOffset = contentSize.height - this.view.height;
                horizontalMaximizeOffset = horizontalMaximizeOffset >= 0 ? horizontalMaximizeOffset : 0;
                verticalMaximizeOffset = verticalMaximizeOffset >= 0 ? verticalMaximizeOffset : 0;
                return new Vec3(horizontalMaximizeOffset, verticalMaximizeOffset, 0);
              };

              _proto.scrollToPercentHorizontal = function scrollToPercentHorizontal(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(percent, 0),
                  applyToHorizontal: true,
                  applyToVertical: false
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated !== false);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollTo = function scrollTo(anchor, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(anchor),
                  applyToHorizontal: true,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.scrollToPercentVertical = function scrollToPercentVertical(percent, timeInSecond, attenuated) {
                var moveDelta = this._calculateMovePercentDelta({
                  anchor: new Vec2(0, percent),
                  applyToHorizontal: false,
                  applyToVertical: true
                });

                if (timeInSecond) {
                  this._startAutoScroll(moveDelta, timeInSecond, attenuated);
                } else {
                  this._moveContent(moveDelta);
                }
              };

              _proto.stopAutoScroll = function stopAutoScroll() {
                this._autoScrolling = false;
                this._autoScrollAccumulatedTime = this._autoScrollTotalTime;
              };

              _proto.setContentPosition = function setContentPosition(position) {
                if (!this._content) {
                  return;
                }

                var contentPos = this.getContentPosition();

                if (Math.abs(position.x - contentPos.x) < EPSILON$1 && Math.abs(position.y - contentPos.y) < EPSILON$1) {
                  return;
                }

                this._content.setPosition(position);

                this._outOfBoundaryAmountDirty = true;
              };

              _proto.getContentPosition = function getContentPosition() {
                if (!this._content) {
                  return ZERO$1;
                }

                this._contentPos.set(this._content.position);

                return this._contentPos;
              };

              _proto.isScrolling = function isScrolling() {
                return this._scrolling;
              };

              _proto.isAutoScrolling = function isAutoScrolling() {
                return this._autoScrolling;
              };

              _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
                return EPSILON$1;
              };

              _proto.start = function start() {
                this._calculateBoundary();

                if (this._content) {
                  director.once(Director.EVENT_BEFORE_DRAW, this._adjustContentOutOfBoundary, this);
                }
              };

              _proto.onEnable = function onEnable() {
                {
                  this._registerEvent();

                  if (this._content) {
                    this._content.on(Node.EventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.on(Node.EventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.on(Node.EventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.on(Node.EventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }

                  this._calculateBoundary();
                }

                this._updateScrollBarState();
              };

              _proto.update = function update(dt) {
                if (this._autoScrolling) {
                  this._processAutoScrolling(dt);
                }
              };

              _proto.onDisable = function onDisable() {
                {
                  this._unregisterEvent();

                  if (this._content) {
                    this._content.off(Node.EventType.SIZE_CHANGED, this._calculateBoundary, this);

                    this._content.off(Node.EventType.TRANSFORM_CHANGED, this._scaleChanged, this);

                    if (this.view) {
                      this.view.node.off(Node.EventType.TRANSFORM_CHANGED, this._scaleChanged, this);
                      this.view.node.off(Node.EventType.SIZE_CHANGED, this._calculateBoundary, this);
                    }
                  }
                }

                this._hideScrollBar();

                this.stopAutoScroll();
              };

              _proto._registerEvent = function _registerEvent() {
                this.node.on(Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.on(Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.on(Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.on(Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.on(Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
              };

              _proto._unregisterEvent = function _unregisterEvent() {
                this.node.off(Node.EventType.TOUCH_START, this._onTouchBegan, this, true);
                this.node.off(Node.EventType.TOUCH_MOVE, this._onTouchMoved, this, true);
                this.node.off(Node.EventType.TOUCH_END, this._onTouchEnded, this, true);
                this.node.off(Node.EventType.TOUCH_CANCEL, this._onTouchCancelled, this, true);
                this.node.off(Node.EventType.MOUSE_WHEEL, this._onMouseWheel, this, true);
              };

              _proto._onMouseWheel = function _onMouseWheel(event, captureListeners) {
                if (!this.enabledInHierarchy) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                var deltaMove = new Vec3();
                var wheelPrecision = -0.1;
                var scrollY = event.getScrollY();

                if (this.vertical) {
                  deltaMove.set(0, scrollY * wheelPrecision, 0);
                } else if (this.horizontal) {
                  deltaMove.set(scrollY * wheelPrecision, 0, 0);
                }

                this._mouseWheelEventElapsedTime = 0;

                this._processDeltaMove(deltaMove);

                if (!this._stopMouseWheel) {
                  this._handlePressLogic();

                  this.schedule(this._checkMouseWheel, 1.0 / 60, NaN, 0);
                  this._stopMouseWheel = true;
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._handlePressLogic();

                this._touchMoved = false;

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                var touch = event.touch;

                this._handleMoveLogic(touch);

                if (!this.cancelInnerEvents) {
                  return;
                }

                var deltaMove = touch.getUILocation(_tempVec2);
                deltaMove.subtract(touch.getUIStartLocation(_tempVec2_1));

                if (deltaMove.length() > 7) {
                  if (!this._touchMoved && event.target !== this.node) {
                    var cancelEvent = new EventTouch(event.getTouches(), event.bubbles);
                    cancelEvent.type = Node.EventType.TOUCH_CANCEL;
                    cancelEvent.touch = event.touch;
                    cancelEvent.simulate = true;
                    event.target.dispatchEvent(cancelEvent);
                    this._touchMoved = true;
                  }
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content || !event) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                this._dispatchEvent(EventType$3.TOUCH_UP);

                var touch = event.touch;

                this._handleReleaseLogic(touch);

                if (this._touchMoved) {
                  event.propagationStopped = true;
                } else {
                  this._stopPropagationIfTargetIsMe(event);
                }
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
                if (!this.enabledInHierarchy || !this._content) {
                  return;
                }

                if (this._hasNestedViewGroup(event, captureListeners)) {
                  return;
                }

                if (event && !event.simulate) {
                  var touch = event.touch;

                  this._handleReleaseLogic(touch);
                }

                this._stopPropagationIfTargetIsMe(event);
              };

              _proto._calculateBoundary = function _calculateBoundary() {
                if (this._content && this.view) {
                  var layout = this._content.getComponent(Layout);

                  if (layout && layout.enabledInHierarchy) {
                    layout.updateLayout();
                  }

                  var viewTrans = this.view;
                  var anchorX = viewTrans.width * viewTrans.anchorX;
                  var anchorY = viewTrans.height * viewTrans.anchorY;
                  this._leftBoundary = -anchorX;
                  this._bottomBoundary = -anchorY;
                  this._rightBoundary = this._leftBoundary + viewTrans.width;
                  this._topBoundary = this._bottomBoundary + viewTrans.height;

                  this._moveContentToTopLeft(viewTrans.contentSize);
                }
              };

              _proto._hasNestedViewGroup = function _hasNestedViewGroup(event, captureListeners) {
                if (!event || event.eventPhase !== Event.CAPTURING_PHASE) {
                  return;
                }

                if (captureListeners) {
                  for (var _iterator = _createForOfIteratorHelperLoose(captureListeners), _step; !(_step = _iterator()).done;) {
                    var listener = _step.value;
                    var item = listener;

                    if (this.node === item) {
                      if (event.target && event.target.getComponent(ViewGroup)) {
                        return true;
                      }

                      return false;
                    }

                    if (item.getComponent(ViewGroup)) {
                      return true;
                    }
                  }
                }

                return false;
              };

              _proto._startInertiaScroll = function _startInertiaScroll(touchMoveVelocity) {
                var inertiaTotalMovement = new Vec3(touchMoveVelocity);
                inertiaTotalMovement.multiplyScalar(MOVEMENT_FACTOR);

                this._startAttenuatingAutoScroll(inertiaTotalMovement, touchMoveVelocity);
              };

              _proto._calculateAttenuatedFactor = function _calculateAttenuatedFactor(distance) {
                if (this.brake <= 0) {
                  return 1 - this.brake;
                }

                return (1 - this.brake) * (1 / (1 + distance * 0.000014 + distance * distance * 0.000000008));
              };

              _proto._startAttenuatingAutoScroll = function _startAttenuatingAutoScroll(deltaMove, initialVelocity) {
                var targetDelta = new Vec3(deltaMove);
                targetDelta.normalize();

                if (this._content && this.view) {
                  var contentSize = this._content._uiProps.uiTransformComp.contentSize;
                  var scrollViewSize = this.view.contentSize;
                  var totalMoveWidth = contentSize.width - scrollViewSize.width;
                  var totalMoveHeight = contentSize.height - scrollViewSize.height;

                  var attenuatedFactorX = this._calculateAttenuatedFactor(totalMoveWidth);

                  var attenuatedFactorY = this._calculateAttenuatedFactor(totalMoveHeight);

                  targetDelta.x = targetDelta.x * totalMoveWidth * (1 - this.brake) * attenuatedFactorX;
                  targetDelta.y = targetDelta.y * totalMoveHeight * attenuatedFactorY * (1 - this.brake);
                  targetDelta.z = 0;
                }

                var originalMoveLength = deltaMove.length();
                var factor = targetDelta.length() / originalMoveLength;
                targetDelta.add(deltaMove);

                if (this.brake > 0 && factor > 7) {
                  factor = Math.sqrt(factor);
                  var a = new Vec3(deltaMove);
                  a.multiplyScalar(factor);
                  targetDelta.set(a);
                  targetDelta.add(deltaMove);
                }

                var time = this._calculateAutoScrollTimeByInitialSpeed(initialVelocity.length());

                if (this.brake > 0 && factor > 3) {
                  factor = 3;
                  time *= factor;
                }

                if (this.brake === 0 && factor > 1) {
                  time *= factor;
                }

                this._startAutoScroll(targetDelta, time, true);
              };

              _proto._calculateAutoScrollTimeByInitialSpeed = function _calculateAutoScrollTimeByInitialSpeed(initialSpeed) {
                return Math.sqrt(Math.sqrt(initialSpeed / 5));
              };

              _proto._startAutoScroll = function _startAutoScroll(deltaMove, timeInSecond, attenuated) {
                if (attenuated === void 0) {
                  attenuated = false;
                }

                var adjustedDeltaMove = this._flattenVectorByDirection(deltaMove);

                this._autoScrolling = true;
                this._autoScrollTargetDelta = adjustedDeltaMove;
                this._autoScrollAttenuate = attenuated;
                Vec3.copy(this._autoScrollStartPosition, this.getContentPosition());
                this._autoScrollTotalTime = timeInSecond;
                this._autoScrollAccumulatedTime = 0;
                this._autoScrollBraking = false;
                this._isScrollEndedWithThresholdEventFired = false;
                this._autoScrollBrakingStartPosition = new Vec3();

                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                if (!currentOutOfBoundary.equals(ZERO$1, EPSILON$1)) {
                  this._autoScrollCurrentlyOutOfBoundary = true;
                }
              };

              _proto._calculateTouchMoveVelocity = function _calculateTouchMoveVelocity() {
                var totalTime = 0;
                totalTime = this._touchMoveTimeDeltas.reduce(function (a, b) {
                  return a + b;
                }, totalTime);

                if (totalTime <= 0 || totalTime >= 0.5) {
                  return new Vec3();
                }

                var totalMovement = new Vec3();
                totalMovement = this._touchMoveDisplacements.reduce(function (a, b) {
                  a.add(b);
                  return a;
                }, totalMovement);
                return new Vec3(totalMovement.x * (1 - this.brake) / totalTime, totalMovement.y * (1 - this.brake) / totalTime, 0);
              };

              _proto._flattenVectorByDirection = function _flattenVectorByDirection(vector) {
                var result = vector;
                result.x = this.horizontal ? result.x : 0;
                result.y = this.vertical ? result.y : 0;
                return result;
              };

              _proto._moveContent = function _moveContent(deltaMove, canStartBounceBack) {
                var adjustedMove = this._flattenVectorByDirection(deltaMove);

                _tempVec3$1.set(this.getContentPosition());

                _tempVec3$1.add(adjustedMove);

                _tempVec3$1.set(Math.floor(_tempVec3$1.x * TOLERANCE) * EPSILON$1, Math.floor(_tempVec3$1.y * TOLERANCE) * EPSILON$1, _tempVec3$1.z);

                this.setContentPosition(_tempVec3$1);

                var outOfBoundary = this._getHowMuchOutOfBoundary();

                this._updateScrollBar(outOfBoundary);

                if (this.elastic && canStartBounceBack) {
                  this._startBounceBackIfNeeded();
                }
              };

              _proto._getContentLeftBoundary = function _getContentLeftBoundary() {
                if (!this._content) {
                  return -1;
                }

                var contentPos = this.getContentPosition();
                var uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.x - uiTrans.anchorX * uiTrans.width;
              };

              _proto._getContentRightBoundary = function _getContentRightBoundary() {
                if (!this._content) {
                  return -1;
                }

                var uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentLeftBoundary() + uiTrans.width;
              };

              _proto._getContentTopBoundary = function _getContentTopBoundary() {
                if (!this._content) {
                  return -1;
                }

                var uiTrans = this._content._uiProps.uiTransformComp;
                return this._getContentBottomBoundary() + uiTrans.height;
              };

              _proto._getContentBottomBoundary = function _getContentBottomBoundary() {
                if (!this._content) {
                  return -1;
                }

                var contentPos = this.getContentPosition();
                var uiTrans = this._content._uiProps.uiTransformComp;
                return contentPos.y - uiTrans.anchorY * uiTrans.height;
              };

              _proto._getHowMuchOutOfBoundary = function _getHowMuchOutOfBoundary(addition) {
                addition = addition || new Vec3();

                if (addition.equals(ZERO$1, EPSILON$1) && !this._outOfBoundaryAmountDirty) {
                  return this._outOfBoundaryAmount;
                }

                var outOfBoundaryAmount = new Vec3();

                if (this._getContentLeftBoundary() + addition.x > this._leftBoundary) {
                  outOfBoundaryAmount.x = this._leftBoundary - (this._getContentLeftBoundary() + addition.x);
                } else if (this._getContentRightBoundary() + addition.x < this._rightBoundary) {
                  outOfBoundaryAmount.x = this._rightBoundary - (this._getContentRightBoundary() + addition.x);
                }

                if (this._getContentTopBoundary() + addition.y < this._topBoundary) {
                  outOfBoundaryAmount.y = this._topBoundary - (this._getContentTopBoundary() + addition.y);
                } else if (this._getContentBottomBoundary() + addition.y > this._bottomBoundary) {
                  outOfBoundaryAmount.y = this._bottomBoundary - (this._getContentBottomBoundary() + addition.y);
                }

                if (addition.equals(ZERO$1, EPSILON$1)) {
                  this._outOfBoundaryAmount = outOfBoundaryAmount;
                  this._outOfBoundaryAmountDirty = false;
                }

                outOfBoundaryAmount = this._clampDelta(outOfBoundaryAmount);
                return outOfBoundaryAmount;
              };

              _proto._updateScrollBar = function _updateScrollBar(outOfBoundary) {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onScroll(outOfBoundary);
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onScroll(outOfBoundary);
                }
              };

              _proto._onScrollBarTouchBegan = function _onScrollBarTouchBegan() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onTouchBegan();
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onTouchBegan();
                }
              };

              _proto._onScrollBarTouchEnded = function _onScrollBarTouchEnded() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.onTouchEnded();
                }

                if (this.verticalScrollBar) {
                  this.verticalScrollBar.onTouchEnded();
                }
              };

              _proto._dispatchEvent = function _dispatchEvent(event) {
                if (event === EventType$3.SCROLL_ENDED) {
                  this._scrollEventEmitMask = 0;
                } else if (event === EventType$3.SCROLL_TO_TOP || event === EventType$3.SCROLL_TO_BOTTOM || event === EventType$3.SCROLL_TO_LEFT || event === EventType$3.SCROLL_TO_RIGHT) {
                  var flag = 1 << eventMap[event];

                  if (this._scrollEventEmitMask & flag) {
                    return;
                  } else {
                    this._scrollEventEmitMask |= flag;
                  }
                }

                EventHandler.emitEvents(this.scrollEvents, this, eventMap[event]);
                this.node.emit(event, this);
              };

              _proto._adjustContentOutOfBoundary = function _adjustContentOutOfBoundary() {
                if (!this._content) {
                  return;
                }

                this._outOfBoundaryAmountDirty = true;

                if (this._isOutOfBoundary()) {
                  var outOfBoundary = this._getHowMuchOutOfBoundary();

                  _tempVec3$1.set(this.getContentPosition());

                  _tempVec3$1.add(outOfBoundary);

                  this._content.setPosition(_tempVec3$1);

                  this._updateScrollBar(ZERO$1);
                }
              };

              _proto._hideScrollBar = function _hideScrollBar() {
                if (this._horizontalScrollBar) {
                  this._horizontalScrollBar.hide();
                }

                if (this._verticalScrollBar) {
                  this._verticalScrollBar.hide();
                }
              };

              _proto._updateScrollBarState = function _updateScrollBarState() {
                if (!this._content || !this.view) {
                  return;
                }

                var viewTrans = this.view;
                var uiTrans = this._content._uiProps.uiTransformComp;

                if (this.verticalScrollBar) {
                  if (uiTrans.height < viewTrans.height) {
                    this.verticalScrollBar.hide();
                  } else {
                    this.verticalScrollBar.show();
                  }
                }

                if (this.horizontalScrollBar) {
                  if (uiTrans.width < viewTrans.width) {
                    this.horizontalScrollBar.hide();
                  } else {
                    this.horizontalScrollBar.show();
                  }
                }
              };

              _proto._stopPropagationIfTargetIsMe = function _stopPropagationIfTargetIsMe(event) {
                if (event.eventPhase === Event.AT_TARGET && event.target === this.node) {
                  event.propagationStopped = true;
                }
              };

              _proto._processDeltaMove = function _processDeltaMove(deltaMove) {
                this._scrollChildren(deltaMove);

                this._gatherTouchMove(deltaMove);
              };

              _proto._handleMoveLogic = function _handleMoveLogic(touch) {
                this._deltaPos.set(this._getLocalAxisAlignDelta(touch));

                this._processDeltaMove(this._deltaPos);
              };

              _proto._handleReleaseLogic = function _handleReleaseLogic(touch) {
                this._deltaPos.set(this._getLocalAxisAlignDelta(touch));

                this._gatherTouchMove(this._deltaPos);

                this._processInertiaScroll();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(EventType$3.SCROLL_ENDED);
                  }
                }
              };

              _proto._getLocalAxisAlignDelta = function _getLocalAxisAlignDelta(touch) {
                var uiTransformComp = this.node._uiProps.uiTransformComp;
                var vec = new Vec3();

                if (uiTransformComp) {
                  touch.getUILocation(_tempVec2);
                  touch.getUIPreviousLocation(_tempVec2_1);

                  _tempVec3$1.set(_tempVec2.x, _tempVec2.y, 0);

                  _tempVec3_1.set(_tempVec2_1.x, _tempVec2_1.y, 0);

                  uiTransformComp.convertToNodeSpaceAR(_tempVec3$1, _tempVec3$1);
                  uiTransformComp.convertToNodeSpaceAR(_tempVec3_1, _tempVec3_1);
                  Vec3.subtract(vec, _tempVec3$1, _tempVec3_1);
                }

                return vec;
              };

              _proto._scrollChildren = function _scrollChildren(deltaMove) {
                deltaMove = this._clampDelta(deltaMove);
                var realMove = deltaMove;
                var outOfBoundary;

                if (this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary();
                  realMove.x *= outOfBoundary.x === 0 ? 1 : 0.5;
                  realMove.y *= outOfBoundary.y === 0 ? 1 : 0.5;
                }

                if (!this.elastic) {
                  outOfBoundary = this._getHowMuchOutOfBoundary(realMove);
                  realMove.add(outOfBoundary);
                }

                var scrollEventType;

                if (this._content) {
                  var _ref = this._content._uiProps.uiTransformComp,
                      anchorX = _ref.anchorX,
                      anchorY = _ref.anchorY,
                      width = _ref.width,
                      height = _ref.height;
                  var pos = this._content.position || ZERO$1;

                  if (realMove.y > 0) {
                    var icBottomPos = pos.y - anchorY * height;

                    if (icBottomPos + realMove.y >= this._bottomBoundary) {
                      scrollEventType = EventType$3.SCROLL_TO_BOTTOM;
                    }
                  } else if (realMove.y < 0) {
                    var icTopPos = pos.y - anchorY * height + height;

                    if (icTopPos + realMove.y <= this._topBoundary) {
                      scrollEventType = EventType$3.SCROLL_TO_TOP;
                    }
                  }

                  if (realMove.x < 0) {
                    var icRightPos = pos.x - anchorX * width + width;

                    if (icRightPos + realMove.x <= this._rightBoundary) {
                      scrollEventType = EventType$3.SCROLL_TO_RIGHT;
                    }
                  } else if (realMove.x > 0) {
                    var icLeftPos = pos.x - anchorX * width;

                    if (icLeftPos + realMove.x >= this._leftBoundary) {
                      scrollEventType = EventType$3.SCROLL_TO_LEFT;
                    }
                  }
                }

                this._moveContent(realMove, false);

                if (realMove.x !== 0 || realMove.y !== 0) {
                  if (!this._scrolling) {
                    this._scrolling = true;

                    this._dispatchEvent(EventType$3.SCROLL_BEGAN);
                  }

                  this._dispatchEvent(EventType$3.SCROLLING);
                }

                if (scrollEventType && scrollEventType.length > 0) {
                  this._dispatchEvent(scrollEventType);
                }
              };

              _proto._handlePressLogic = function _handlePressLogic() {
                if (this._autoScrolling) {
                  this._dispatchEvent(EventType$3.SCROLL_ENDED);
                }

                this._autoScrolling = false;
                this._isBouncing = false;
                this._touchMovePreviousTimestamp = getTimeInMilliseconds();
                this._touchMoveDisplacements.length = 0;
                this._touchMoveTimeDeltas.length = 0;

                this._onScrollBarTouchBegan();
              };

              _proto._clampDelta = function _clampDelta(delta) {
                if (this._content && this.view) {
                  var scrollViewSize = this.view.contentSize;
                  var uiTrans = this._content._uiProps.uiTransformComp;

                  if (uiTrans.width < scrollViewSize.width) {
                    delta.x = 0;
                  }

                  if (uiTrans.height < scrollViewSize.height) {
                    delta.y = 0;
                  }
                }

                return delta;
              };

              _proto._gatherTouchMove = function _gatherTouchMove(delta) {
                var clampDt = delta.clone();

                this._clampDelta(clampDt);

                while (this._touchMoveDisplacements.length >= NUMBER_OF_GATHERED_TOUCHES_FOR_MOVE_SPEED) {
                  this._touchMoveDisplacements.shift();

                  this._touchMoveTimeDeltas.shift();
                }

                this._touchMoveDisplacements.push(clampDt);

                var timeStamp = getTimeInMilliseconds();

                this._touchMoveTimeDeltas.push((timeStamp - this._touchMovePreviousTimestamp) / 1000);

                this._touchMovePreviousTimestamp = timeStamp;
              };

              _proto._startBounceBackIfNeeded = function _startBounceBackIfNeeded() {
                if (!this.elastic) {
                  return false;
                }

                var bounceBackAmount = this._getHowMuchOutOfBoundary();

                bounceBackAmount = this._clampDelta(bounceBackAmount);

                if (bounceBackAmount.equals(ZERO$1, EPSILON$1)) {
                  return false;
                }

                var bounceBackTime = Math.max(this.bounceDuration, 0);

                this._startAutoScroll(bounceBackAmount, bounceBackTime, true);

                if (!this._isBouncing) {
                  if (bounceBackAmount.y > 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_TOP);
                  }

                  if (bounceBackAmount.y < 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_BOTTOM);
                  }

                  if (bounceBackAmount.x > 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_RIGHT);
                  }

                  if (bounceBackAmount.x < 0) {
                    this._dispatchEvent(EventType$3.BOUNCE_LEFT);
                  }

                  this._isBouncing = true;
                }

                return true;
              };

              _proto._processInertiaScroll = function _processInertiaScroll() {
                var bounceBackStarted = this._startBounceBackIfNeeded();

                if (!bounceBackStarted && this.inertia) {
                  var touchMoveVelocity = this._calculateTouchMoveVelocity();

                  if (!touchMoveVelocity.equals(_tempVec3$1, EPSILON$1) && this.brake < 1) {
                    this._startInertiaScroll(touchMoveVelocity);
                  }
                }

                this._onScrollBarTouchEnded();
              };

              _proto._isOutOfBoundary = function _isOutOfBoundary() {
                var outOfBoundary = this._getHowMuchOutOfBoundary();

                return !outOfBoundary.equals(ZERO$1, EPSILON$1);
              };

              _proto._isNecessaryAutoScrollBrake = function _isNecessaryAutoScrollBrake() {
                if (this._autoScrollBraking) {
                  return true;
                }

                if (this._isOutOfBoundary()) {
                  if (!this._autoScrollCurrentlyOutOfBoundary) {
                    this._autoScrollCurrentlyOutOfBoundary = true;
                    this._autoScrollBraking = true;
                    this._autoScrollBrakingStartPosition = this.getContentPosition();
                    return true;
                  }
                } else {
                  this._autoScrollCurrentlyOutOfBoundary = false;
                }

                return false;
              };

              _proto._processAutoScrolling = function _processAutoScrolling(dt) {
                var isAutoScrollBrake = this._isNecessaryAutoScrollBrake();

                var brakingFactor = isAutoScrollBrake ? OUT_OF_BOUNDARY_BREAKING_FACTOR : 1;
                this._autoScrollAccumulatedTime += dt * (1 / brakingFactor);
                var percentage = Math.min(1, this._autoScrollAccumulatedTime / this._autoScrollTotalTime);

                if (this._autoScrollAttenuate) {
                  percentage = quintEaseOut(percentage);
                }

                var a = new Vec3(this._autoScrollTargetDelta);
                a.multiplyScalar(percentage);
                var newPosition = new Vec3(this._autoScrollStartPosition);
                newPosition.add(a);
                var reachedEnd = Math.abs(percentage - 1) <= EPSILON$1;
                var fireEvent = Math.abs(percentage - 1) <= this.getScrollEndedEventTiming();

                if (fireEvent && !this._isScrollEndedWithThresholdEventFired) {
                  this._dispatchEvent(EventType$3.SCROLL_ENG_WITH_THRESHOLD);

                  this._isScrollEndedWithThresholdEventFired = true;
                }

                if (this.elastic) {
                  var brakeOffsetPosition = new Vec3(newPosition);
                  brakeOffsetPosition.subtract(this._autoScrollBrakingStartPosition);

                  if (isAutoScrollBrake) {
                    brakeOffsetPosition.multiplyScalar(brakingFactor);
                  }

                  newPosition.set(this._autoScrollBrakingStartPosition);
                  newPosition.add(brakeOffsetPosition);
                } else {
                  var moveDelta = new Vec3(newPosition);
                  moveDelta.subtract(this.getContentPosition());

                  var outOfBoundary = this._getHowMuchOutOfBoundary(moveDelta);

                  if (!outOfBoundary.equals(ZERO$1, EPSILON$1)) {
                    newPosition.add(outOfBoundary);
                    reachedEnd = true;
                  }
                }

                if (reachedEnd) {
                  this._autoScrolling = false;
                }

                var deltaMove = new Vec3(newPosition);
                deltaMove.subtract(this.getContentPosition());

                this._moveContent(this._clampDelta(deltaMove), reachedEnd);

                this._dispatchEvent(EventType$3.SCROLLING);

                if (!this._autoScrolling) {
                  this._isBouncing = false;
                  this._scrolling = false;

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);
                }
              };

              _proto._checkMouseWheel = function _checkMouseWheel(dt) {
                var currentOutOfBoundary = this._getHowMuchOutOfBoundary();

                var maxElapsedTime = 0.1;

                if (!currentOutOfBoundary.equals(ZERO$1, EPSILON$1)) {
                  this._processInertiaScroll();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                  return;
                }

                this._mouseWheelEventElapsedTime += dt;

                if (this._mouseWheelEventElapsedTime > maxElapsedTime) {
                  this._onScrollBarTouchEnded();

                  this.unschedule(this._checkMouseWheel);

                  this._dispatchEvent(EventType$3.SCROLL_ENDED);

                  this._stopMouseWheel = false;
                }
              };

              _proto._calculateMovePercentDelta = function _calculateMovePercentDelta(options) {
                var anchor = options.anchor;
                var applyToHorizontal = options.applyToHorizontal;
                var applyToVertical = options.applyToVertical;

                this._calculateBoundary();

                anchor.clampf(new Vec2(0, 0), new Vec2(1, 1));

                var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;
                var moveDelta = new Vec3();

                if (this._content && this.view) {
                  var totalScrollDelta = 0;
                  var uiTrans = this._content._uiProps.uiTransformComp;
                  var contentSize = uiTrans.contentSize;
                  var scrollSize = this.view.contentSize;

                  if (applyToHorizontal) {
                    totalScrollDelta = contentSize.width - scrollSize.width;
                    moveDelta.x = leftDelta - totalScrollDelta * anchor.x;
                  }

                  if (applyToVertical) {
                    totalScrollDelta = contentSize.height - scrollSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta * anchor.y;
                  }
                }

                return moveDelta;
              };

              _proto._moveContentToTopLeft = function _moveContentToTopLeft(scrollViewSize) {
                var bottomDelta = this._getContentBottomBoundary() - this._bottomBoundary;

                bottomDelta = -bottomDelta;
                var moveDelta = new Vec3();
                var totalScrollDelta = 0;

                var leftDelta = this._getContentLeftBoundary() - this._leftBoundary;

                leftDelta = -leftDelta;

                if (this._content) {
                  var uiTrans = this._content._uiProps.uiTransformComp;
                  var contentSize = uiTrans.contentSize;

                  if (contentSize.height < scrollViewSize.height) {
                    totalScrollDelta = contentSize.height - scrollViewSize.height;
                    moveDelta.y = bottomDelta - totalScrollDelta;
                  }

                  if (contentSize.width < scrollViewSize.width) {
                    totalScrollDelta = contentSize.width - scrollViewSize.width;
                    moveDelta.x = leftDelta;
                  }
                }

                this._updateScrollBarState();

                this._moveContent(moveDelta);

                this._adjustContentOutOfBoundary();
              };

              _proto._scaleChanged = function _scaleChanged(value) {
                if (value === TransformBit.SCALE) {
                  this._calculateBoundary();
                }
              };

              _createClass(ScrollView, [{
                key: "content",
                get: function get() {
                  return this._content;
                },
                set: function set(value) {
                  if (this._content === value) {
                    return;
                  }

                  var viewTrans = value && value.parent && value.parent._uiProps.uiTransformComp;

                  if (value && (!value || !viewTrans)) {
                    logID(4302);
                    return;
                  }

                  this._content = value;

                  this._calculateBoundary();
                }
              }, {
                key: "horizontalScrollBar",
                get: function get() {
                  return this._horizontalScrollBar;
                },
                set: function set(value) {
                  if (this._horizontalScrollBar === value) {
                    return;
                  }

                  this._horizontalScrollBar = value;

                  if (this._horizontalScrollBar) {
                    this._horizontalScrollBar.setScrollView(this);

                    this._updateScrollBar(ZERO$1);
                  }
                }
              }, {
                key: "verticalScrollBar",
                get: function get() {
                  return this._verticalScrollBar;
                },
                set: function set(value) {
                  if (this._verticalScrollBar === value) {
                    return;
                  }

                  this._verticalScrollBar = value;

                  if (this._verticalScrollBar) {
                    this._verticalScrollBar.setScrollView(this);

                    this._updateScrollBar(ZERO$1);
                  }
                }
              }, {
                key: "view",
                get: function get() {
                  var parent = this._content && this._content.parent;

                  if (!parent) {
                    return null;
                  }

                  return parent._uiProps.uiTransformComp;
                }
              }]);

              return ScrollView;
            }(ViewGroup), _class3$c.EventType = EventType$3, _temp$x), (_descriptor$t = _applyDecoratedDescriptor(_class2$u.prototype, "bounceDuration", [serializable, _dec6$n, _dec7$n, _dec8$k], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor2$p = _applyDecoratedDescriptor(_class2$u.prototype, "brake", [serializable, _dec9$i, _dec10$g, _dec11$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor3$m = _applyDecoratedDescriptor(_class2$u.prototype, "elastic", [serializable, _dec12$e, _dec13$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor4$i = _applyDecoratedDescriptor(_class2$u.prototype, "inertia", [serializable, _dec14$b, _dec15$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$u.prototype, "content", [_dec16$9, _dec17$8, _dec18$7], Object.getOwnPropertyDescriptor(_class2$u.prototype, "content"), _class2$u.prototype), _descriptor5$f = _applyDecoratedDescriptor(_class2$u.prototype, "horizontal", [serializable, _dec19$6, _dec20$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$u.prototype, "horizontalScrollBar", [_dec21$5, _dec22$5, _dec23$5], Object.getOwnPropertyDescriptor(_class2$u.prototype, "horizontalScrollBar"), _class2$u.prototype), _descriptor6$a = _applyDecoratedDescriptor(_class2$u.prototype, "vertical", [serializable, _dec24$5, _dec25$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _applyDecoratedDescriptor(_class2$u.prototype, "verticalScrollBar", [_dec26$4, _dec27$4, _dec28$4], Object.getOwnPropertyDescriptor(_class2$u.prototype, "verticalScrollBar"), _class2$u.prototype), _descriptor7$9 = _applyDecoratedDescriptor(_class2$u.prototype, "cancelInnerEvents", [serializable, _dec29$4, _dec30$4], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor8$9 = _applyDecoratedDescriptor(_class2$u.prototype, "scrollEvents", [_dec31$4, serializable, _dec32$4, _dec33$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor9$8 = _applyDecoratedDescriptor(_class2$u.prototype, "_content", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor10$7 = _applyDecoratedDescriptor(_class2$u.prototype, "_horizontalScrollBar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor11$6 = _applyDecoratedDescriptor(_class2$u.prototype, "_verticalScrollBar", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$u)) || _class$B) || _class$B) || _class$B) || _class$B) || _class$B));

            var _dec$C, _dec2$w, _dec3$u, _dec4$s, _dec5$p, _dec6$o, _dec7$o, _dec8$l, _dec9$j, _dec10$h, _dec11$g, _dec12$f, _dec13$f, _class$C, _class2$v, _descriptor$u, _descriptor2$q, _descriptor3$n, _descriptor4$j, _class3$d, _temp$y;

            var _tempPos = new Vec3();

            var Direction$1;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$1 || (Direction$1 = {}));

            ccenum(Direction$1);
            var Slider = function (v) { return exports({ Slider: v, SliderComponent: v }), v; }((_dec$C = ccclass('cc.Slider'), _dec2$w = help(), _dec3$u = executionOrder(110), _dec4$s = menu(), _dec5$p = requireComponent(UITransform), _dec6$o = type(Sprite), _dec7$o = tooltip(), _dec8$l = type(Direction$1), _dec9$j = tooltip(), _dec10$h = range(), _dec11$g = tooltip(), _dec12$f = type([EventHandler]), _dec13$f = tooltip(), _dec$C(_class$C = _dec2$w(_class$C = _dec3$u(_class$C = _dec4$s(_class$C = _dec5$p(_class$C = (_class2$v = (_temp$y = _class3$d = function (_Component) {
              _inheritsLoose(Slider, _Component);

              function Slider() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "slideEvents", _descriptor$u, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_handle", _descriptor2$q, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$n, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_progress", _descriptor4$j, _assertThisInitialized(_this));

                _this._offset = new Vec3();
                _this._dragging = false;
                _this._touchHandle = false;
                _this._handleLocalPos = new Vec3();
                _this._touchPos = new Vec3();
                return _this;
              }

              var _proto = Slider.prototype;

              _proto.__preload = function __preload() {
                this._updateHandlePosition();
              };

              _proto.onEnable = function onEnable() {
                this._updateHandlePosition();

                this.node.on(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.on(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.on(SystemEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.on(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.on(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                }
              };

              _proto.onDisable = function onDisable() {
                this.node.off(SystemEventType.TOUCH_START, this._onTouchBegan, this);
                this.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this);
                this.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                this.node.off(SystemEventType.TOUCH_CANCEL, this._onTouchCancelled, this);

                if (this._handle && this._handle.isValid) {
                  this._handle.node.off(SystemEventType.TOUCH_START, this._onHandleDragStart, this);

                  this._handle.node.off(SystemEventType.TOUCH_MOVE, this._onTouchMoved, this);

                  this._handle.node.off(SystemEventType.TOUCH_END, this._onTouchEnded, this);
                }
              };

              _proto._onHandleDragStart = function _onHandleDragStart(event) {
                if (!event || !this._handle || !this._handle.node._uiProps.uiTransformComp) {
                  return;
                }

                this._dragging = true;
                this._touchHandle = true;
                var touhPos = event.touch.getUILocation();
                Vec3.set(this._touchPos, touhPos.x, touhPos.y, 0);

                this._handle.node._uiProps.uiTransformComp.convertToNodeSpaceAR(this._touchPos, this._offset);

                event.propagationStopped = true;
              };

              _proto._onTouchBegan = function _onTouchBegan(event) {
                if (!this._handle || !event) {
                  return;
                }

                this._dragging = true;

                if (!this._touchHandle) {
                  this._handleSliderLogic(event.touch);
                }

                event.propagationStopped = true;
              };

              _proto._onTouchMoved = function _onTouchMoved(event) {
                if (!this._dragging || !event) {
                  return;
                }

                this._handleSliderLogic(event.touch);

                event.propagationStopped = true;
              };

              _proto._onTouchEnded = function _onTouchEnded(event) {
                this._dragging = false;
                this._touchHandle = false;
                this._offset = new Vec3();

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event) {
                this._dragging = false;

                if (event) {
                  event.propagationStopped = true;
                }
              };

              _proto._handleSliderLogic = function _handleSliderLogic(touch) {
                this._updateProgress(touch);

                this._emitSlideEvent();
              };

              _proto._emitSlideEvent = function _emitSlideEvent() {
                EventHandler.emitEvents(this.slideEvents, this);
                this.node.emit('slide', this);
              };

              _proto._updateProgress = function _updateProgress(touch) {
                if (!this._handle || !touch) {
                  return;
                }

                var touchPos = touch.getUILocation();
                Vec3.set(this._touchPos, touchPos.x, touchPos.y, 0);
                var uiTrans = this.node._uiProps.uiTransformComp;
                var localTouchPos = uiTrans.convertToNodeSpaceAR(this._touchPos, _tempPos);

                if (this.direction === Direction$1.Horizontal) {
                  this.progress = clamp01(0.5 + (localTouchPos.x - this._offset.x) / uiTrans.width);
                } else {
                  this.progress = clamp01(0.5 + (localTouchPos.y - this._offset.y) / uiTrans.height);
                }
              };

              _proto._updateHandlePosition = function _updateHandlePosition() {
                if (!this._handle) {
                  return;
                }

                this._handleLocalPos.set(this._handle.node.getPosition());

                var uiTrans = this.node._uiProps.uiTransformComp;

                if (this._direction === Direction$1.Horizontal) {
                  this._handleLocalPos.x = -uiTrans.width * uiTrans.anchorX + this.progress * uiTrans.width;
                } else {
                  this._handleLocalPos.y = -uiTrans.height * uiTrans.anchorY + this.progress * uiTrans.height;
                }

                this._handle.node.setPosition(this._handleLocalPos);
              };

              _proto._changeLayout = function _changeLayout() {
                var uiTrans = this.node._uiProps.uiTransformComp;
                var contentSize = uiTrans.contentSize;
                uiTrans.setContentSize(contentSize.height, contentSize.width);

                if (this._handle) {
                  var pos = this._handle.node.position;

                  if (this._direction === Direction$1.Horizontal) {
                    this._handle.node.setPosition(pos.x, 0, pos.z);
                  } else {
                    this._handle.node.setPosition(0, pos.y, pos.z);
                  }

                  this._updateHandlePosition();
                }
              };

              _createClass(Slider, [{
                key: "handle",
                get: function get() {
                  return this._handle;
                },
                set: function set(value) {
                  if (this._handle === value) {
                    return;
                  }

                  this._handle = value;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;

                  this._changeLayout();
                }
              }, {
                key: "progress",
                get: function get() {
                  return this._progress;
                },
                set: function set(value) {
                  if (this._progress === value) {
                    return;
                  }

                  this._progress = value;

                  this._updateHandlePosition();
                }
              }]);

              return Slider;
            }(Component), _class3$d.Direction = Direction$1, _temp$y), (_applyDecoratedDescriptor(_class2$v.prototype, "handle", [_dec6$o, _dec7$o], Object.getOwnPropertyDescriptor(_class2$v.prototype, "handle"), _class2$v.prototype), _applyDecoratedDescriptor(_class2$v.prototype, "direction", [_dec8$l, _dec9$j], Object.getOwnPropertyDescriptor(_class2$v.prototype, "direction"), _class2$v.prototype), _applyDecoratedDescriptor(_class2$v.prototype, "progress", [slide, _dec10$h, _dec11$g], Object.getOwnPropertyDescriptor(_class2$v.prototype, "progress"), _class2$v.prototype), _descriptor$u = _applyDecoratedDescriptor(_class2$v.prototype, "slideEvents", [_dec12$f, serializable, _dec13$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$q = _applyDecoratedDescriptor(_class2$v.prototype, "_handle", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$n = _applyDecoratedDescriptor(_class2$v.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Direction$1.Horizontal;
              }
            }), _descriptor4$j = _applyDecoratedDescriptor(_class2$v.prototype, "_progress", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            })), _class2$v)) || _class$C) || _class$C) || _class$C) || _class$C) || _class$C));

            function extendsEnum() {
              for (var _len = arguments.length, enums = new Array(_len), _key = 0; _key < _len; _key++) {
                enums[_key] = arguments[_key];
              }

              return Object.assign.apply(Object, [{}].concat(enums));
            }

            var _dec$D, _dec2$x, _dec3$v, _dec4$t, _dec5$q, _dec6$p, _dec7$p, _dec8$m, _dec9$k, _dec10$i, _dec11$h, _dec12$g, _class$D, _class2$w, _descriptor$v, _descriptor2$r, _descriptor3$o, _class3$e, _temp$z;
            var EventType$4;

            (function (EventType) {
              EventType["TOGGLE"] = "toggle";
            })(EventType$4 || (EventType$4 = {}));

            var Toggle = function (v) { return exports({ Toggle: v, ToggleComponent: v }), v; }((_dec$D = ccclass('cc.Toggle'), _dec2$x = help(), _dec3$v = executionOrder(110), _dec4$t = menu(), _dec5$q = requireComponent(UITransform), _dec6$p = displayOrder(), _dec7$p = tooltip(), _dec8$m = type(Sprite), _dec9$k = displayOrder(), _dec10$i = tooltip(), _dec11$h = type([EventHandler]), _dec12$g = tooltip(), _dec$D(_class$D = _dec2$x(_class$D = _dec3$v(_class$D = _dec4$t(_class$D = _dec5$q(_class$D = (_class2$w = (_temp$z = _class3$e = function (_Button) {
              _inheritsLoose(Toggle, _Button);

              function Toggle() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Button.call.apply(_Button, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "checkEvents", _descriptor$v, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isChecked", _descriptor2$r, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_checkMark", _descriptor3$o, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = Toggle.prototype;

              _proto._internalToggle = function _internalToggle() {
                this.isChecked = !this.isChecked;
              };

              _proto._set = function _set(value, emitEvent) {
                if (emitEvent === void 0) {
                  emitEvent = true;
                }

                if (this._isChecked == value) return;
                this._isChecked = value;
                var group = this._toggleContainer;

                if (group && group.enabled && this.enabled) {
                  if (value || !group.anyTogglesChecked() && !group.allowSwitchOff) {
                    this._isChecked = true;
                    group.notifyToggleCheck(this, emitEvent);
                  }
                }

                this.playEffect();

                if (emitEvent) {
                  this._emitToggleEvents();
                }
              };

              _proto.playEffect = function playEffect() {
                if (this._checkMark) {
                  this._checkMark.node.active = this._isChecked;
                }
              };

              _proto.setIsCheckedWithoutNotify = function setIsCheckedWithoutNotify(value) {
                this._set(value, false);
              };

              _proto.onEnable = function onEnable() {
                _Button.prototype.onEnable.call(this);

                this.playEffect();

                {
                  this.node.on(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              };

              _proto.onDisable = function onDisable() {
                _Button.prototype.onDisable.call(this);

                {
                  this.node.off(Toggle.EventType.CLICK, this._internalToggle, this);
                }
              };

              _proto.OnDestroy = function OnDestroy() {
                var group = this._toggleContainer;

                if (group) {
                  group.ensureValidState();
                }
              };

              _proto._emitToggleEvents = function _emitToggleEvents() {
                this.node.emit(Toggle.EventType.TOGGLE, this);

                if (this.checkEvents) {
                  EventHandler.emitEvents(this.checkEvents, this);
                }
              };

              _createClass(Toggle, [{
                key: "isChecked",
                get: function get() {
                  return this._isChecked;
                },
                set: function set(value) {
                  this._set(value);
                }
              }, {
                key: "checkMark",
                get: function get() {
                  return this._checkMark;
                },
                set: function set(value) {
                  if (this._checkMark === value) {
                    return;
                  }

                  this._checkMark = value;
                }
              }, {
                key: "_resizeToTarget",
                set: function set(value) {
                  if (value) {
                    this._resizeNodeToTargetNode();
                  }
                }
              }, {
                key: "_toggleContainer",
                get: function get() {
                  var parent = this.node.parent;

                  if (legacyCC.Node.isNode(parent)) {
                    return parent.getComponent('cc.ToggleContainer');
                  }

                  return null;
                }
              }]);

              return Toggle;
            }(Button), _class3$e.EventType = extendsEnum(EventType$4, EventType$1), _temp$z), (_applyDecoratedDescriptor(_class2$w.prototype, "isChecked", [_dec6$p, _dec7$p], Object.getOwnPropertyDescriptor(_class2$w.prototype, "isChecked"), _class2$w.prototype), _applyDecoratedDescriptor(_class2$w.prototype, "checkMark", [_dec8$m, _dec9$k, _dec10$i], Object.getOwnPropertyDescriptor(_class2$w.prototype, "checkMark"), _class2$w.prototype), _descriptor$v = _applyDecoratedDescriptor(_class2$w.prototype, "checkEvents", [_dec11$h, serializable, _dec12$g], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$r = _applyDecoratedDescriptor(_class2$w.prototype, "_isChecked", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor3$o = _applyDecoratedDescriptor(_class2$w.prototype, "_checkMark", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$w)) || _class$D) || _class$D) || _class$D) || _class$D) || _class$D));

            var _dec$E, _dec2$y, _dec3$w, _dec4$u, _dec5$r, _dec6$q, _dec7$q, _class$E, _class2$x, _descriptor$w, _descriptor2$s, _temp$A;
            var ToggleContainer = function (v) { return exports({ ToggleContainer: v, ToggleContainerComponent: v }), v; }((_dec$E = ccclass('cc.ToggleContainer'), _dec2$y = help(), _dec3$w = executionOrder(110), _dec4$u = menu(), _dec5$r = tooltip(), _dec6$q = type([EventHandler]), _dec7$q = tooltip(), _dec$E(_class$E = _dec2$y(_class$E = _dec3$w(_class$E = _dec4$u(_class$E = executeInEditMode(_class$E = (_class2$x = (_temp$A = function (_Component) {
              _inheritsLoose(ToggleContainer, _Component);

              function ToggleContainer() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "_allowSwitchOff", _descriptor$w, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "checkEvents", _descriptor2$s, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = ToggleContainer.prototype;

              _proto.onEnable = function onEnable() {
                this.ensureValidState();
                this.node.on(SystemEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.on(SystemEventType.CHILD_REMOVED, this.ensureValidState, this);
              };

              _proto.onDisable = function onDisable() {
                this.node.off(SystemEventType.CHILD_ADDED, this.ensureValidState, this);
                this.node.off(SystemEventType.CHILD_REMOVED, this.ensureValidState, this);
              };

              _proto.activeToggles = function activeToggles() {
                return this.toggleItems.filter(function (x) {
                  return x.isChecked;
                });
              };

              _proto.anyTogglesChecked = function anyTogglesChecked() {
                return !!this.toggleItems.find(function (x) {
                  return x.isChecked;
                });
              };

              _proto.notifyToggleCheck = function notifyToggleCheck(toggle, emitEvent) {
                if (emitEvent === void 0) {
                  emitEvent = true;
                }

                if (!this.enabledInHierarchy) {
                  return;
                }

                for (var i = 0; i < this.toggleItems.length; i++) {
                  var item = this.toggleItems[i];

                  if (item === toggle) {
                    continue;
                  }

                  if (emitEvent) {
                    item.isChecked = false;
                  } else {
                    item.setIsCheckedWithoutNotify(false);
                  }
                }

                if (this.checkEvents) {
                  legacyCC.Component.EventHandler.emitEvents(this.checkEvents, toggle);
                }
              };

              _proto.ensureValidState = function ensureValidState() {
                var toggles = this.toggleItems;

                if (!this._allowSwitchOff && !this.anyTogglesChecked() && toggles.length !== 0) {
                  var toggle = toggles[0];
                  toggle.isChecked = true;
                  this.notifyToggleCheck(toggle);
                }

                var activeToggles = this.activeToggles();

                if (activeToggles.length > 1) {
                  var firstToggle = activeToggles[0];

                  for (var i = 0; i < activeToggles.length; ++i) {
                    var _toggle = activeToggles[i];

                    if (_toggle === firstToggle) {
                      continue;
                    }

                    _toggle.isChecked = false;
                  }
                }
              };

              _createClass(ToggleContainer, [{
                key: "allowSwitchOff",
                get: function get() {
                  return this._allowSwitchOff;
                },
                set: function set(value) {
                  this._allowSwitchOff = value;
                }
              }, {
                key: "toggleItems",
                get: function get() {
                  return this.node.children.map(function (item) {
                    var toggle = item.getComponent('cc.Toggle');

                    if (toggle && toggle.enabled) {
                      return toggle;
                    }
                  }).filter(Boolean);
                }
              }]);

              return ToggleContainer;
            }(Component), _temp$A), (_descriptor$w = _applyDecoratedDescriptor(_class2$x.prototype, "_allowSwitchOff", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _applyDecoratedDescriptor(_class2$x.prototype, "allowSwitchOff", [_dec5$r], Object.getOwnPropertyDescriptor(_class2$x.prototype, "allowSwitchOff"), _class2$x.prototype), _descriptor2$s = _applyDecoratedDescriptor(_class2$x.prototype, "checkEvents", [_dec6$q, serializable, _dec7$q], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$x)) || _class$E) || _class$E) || _class$E) || _class$E) || _class$E));

            var _dec$F, _dec2$z, _dec3$x, _dec4$v, _dec5$s, _dec6$r, _dec7$r, _dec8$n, _dec9$l, _dec10$j, _dec11$i, _dec12$h, _dec13$g, _dec14$c, _dec15$b, _dec16$a, _dec17$9, _class$F, _class2$y, _descriptor$x, _descriptor2$t, _descriptor3$p, _descriptor4$k, _descriptor5$g, _descriptor6$b, _descriptor7$a, _descriptor8$a, _descriptor9$9, _descriptor10$8, _descriptor11$7, _descriptor12$5, _descriptor13$4, _descriptor14$3, _descriptor15$2, _descriptor16$2, _descriptor17, _descriptor18, _class3$f, _temp$B;

            var _zeroVec3 = new Vec3();

            function getReadonlyNodeSize(parent) {
              if (parent instanceof Scene) {

                return visibleRect;
              } else if (parent._uiProps.uiTransformComp) {
                return parent._uiProps.uiTransformComp.contentSize;
              } else {
                return Size.ZERO;
              }
            }
            function computeInverseTransForTarget(widgetNode, target, out_inverseTranslate, out_inverseScale) {
              var scale = widgetNode.parent ? widgetNode.parent.getScale() : _zeroVec3;
              var scaleX = scale.x;
              var scaleY = scale.y;
              var translateX = 0;
              var translateY = 0;

              for (var node = widgetNode.parent;;) {
                if (!node) {
                  out_inverseTranslate.x = out_inverseTranslate.y = 0;
                  out_inverseScale.x = out_inverseScale.y = 1;
                  return;
                }

                var pos = node.getPosition();
                translateX += pos.x;
                translateY += pos.y;
                node = node.parent;

                if (node !== target) {
                  scale = node ? node.getScale() : _zeroVec3;
                  var sx = scale.x;
                  var sy = scale.y;
                  translateX *= sx;
                  translateY *= sy;
                  scaleX *= sx;
                  scaleY *= sy;
                } else {
                  break;
                }
              }

              out_inverseScale.x = scaleX !== 0 ? 1 / scaleX : 1;
              out_inverseScale.y = scaleY !== 0 ? 1 / scaleY : 1;
              out_inverseTranslate.x = -translateX;
              out_inverseTranslate.y = -translateY;
            }
            var AlignMode;

            (function (AlignMode) {
              AlignMode[AlignMode["ONCE"] = 0] = "ONCE";
              AlignMode[AlignMode["ALWAYS"] = 1] = "ALWAYS";
              AlignMode[AlignMode["ON_WINDOW_RESIZE"] = 2] = "ON_WINDOW_RESIZE";
            })(AlignMode || (AlignMode = {}));

            ccenum(AlignMode);
            var AlignFlags;

            (function (AlignFlags) {
              AlignFlags[AlignFlags["TOP"] = 1] = "TOP";
              AlignFlags[AlignFlags["MID"] = 2] = "MID";
              AlignFlags[AlignFlags["BOT"] = 4] = "BOT";
              AlignFlags[AlignFlags["LEFT"] = 8] = "LEFT";
              AlignFlags[AlignFlags["CENTER"] = 16] = "CENTER";
              AlignFlags[AlignFlags["RIGHT"] = 32] = "RIGHT";
              AlignFlags[AlignFlags["HORIZONTAL"] = 56] = "HORIZONTAL";
              AlignFlags[AlignFlags["VERTICAL"] = 7] = "VERTICAL";
            })(AlignFlags || (AlignFlags = {}));

            var TOP_BOT = AlignFlags.TOP | AlignFlags.BOT;
            var LEFT_RIGHT = AlignFlags.LEFT | AlignFlags.RIGHT;
            var Widget = function (v) { return exports({ Widget: v, WidgetComponent: v }), v; }((_dec$F = ccclass('cc.Widget'), _dec2$z = help(), _dec3$x = executionOrder(110), _dec4$v = menu(), _dec5$s = requireComponent(UITransform), _dec6$r = type(Node), _dec7$r = tooltip(), _dec8$n = tooltip(), _dec9$l = tooltip(), _dec10$j = tooltip(), _dec11$i = tooltip(), _dec12$h = tooltip(), _dec13$g = tooltip(), _dec14$c = visible(), _dec15$b = visible(), _dec16$a = type(AlignMode), _dec17$9 = tooltip(), _dec$F(_class$F = _dec2$z(_class$F = _dec3$x(_class$F = _dec4$v(_class$F = _dec5$s(_class$F = executeInEditMode(_class$F = (_class2$y = (_temp$B = _class3$f = function (_Component) {
              _inheritsLoose(Widget, _Component);

              function Widget() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._lastPos = new Vec3();
                _this._lastSize = new Size();
                _this._dirty = true;

                _initializerDefineProperty(_this, "_alignFlags", _descriptor$x, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_target", _descriptor2$t, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_left", _descriptor3$p, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_right", _descriptor4$k, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_top", _descriptor5$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_bottom", _descriptor6$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_horizontalCenter", _descriptor7$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_verticalCenter", _descriptor8$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsLeft", _descriptor9$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsRight", _descriptor10$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsTop", _descriptor11$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsBottom", _descriptor12$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsHorizontalCenter", _descriptor13$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isAbsVerticalCenter", _descriptor14$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_originalWidth", _descriptor15$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_originalHeight", _descriptor16$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_alignMode", _descriptor17, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lockFlags", _descriptor18, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = Widget.prototype;

              _proto.updateAlignment = function updateAlignment() {
                legacyCC._widgetManager.updateAlignment(this.node);
              };

              _proto._validateTargetInDEV = function _validateTargetInDEV() {
                {
                  return;
                }
              };

              _proto.setDirty = function setDirty() {
                this._recursiveDirty();
              };

              _proto.onEnable = function onEnable() {
                this.node.getPosition(this._lastPos);

                this._lastSize.set(this.node._uiProps.uiTransformComp.contentSize);

                legacyCC._widgetManager.add(this);

                this._registerEvent();

                this._registerTargetEvents();
              };

              _proto.onDisable = function onDisable() {
                legacyCC._widgetManager.remove(this);

                this._unregisterEvent();

                this._unregisterTargetEvents();
              };

              _proto.onDestroy = function onDestroy() {
                this._removeParentEvent();
              };

              _proto._adjustWidgetToAllowMovingInEditor = function _adjustWidgetToAllowMovingInEditor(eventType) {};

              _proto._adjustWidgetToAllowResizingInEditor = function _adjustWidgetToAllowResizingInEditor() {};

              _proto._adjustWidgetToAnchorChanged = function _adjustWidgetToAnchorChanged() {
                this.setDirty();
              };

              _proto._adjustTargetToParentChanged = function _adjustTargetToParentChanged(oldParent) {
                if (oldParent) {
                  this._unregisterOldParentEvents(oldParent);
                }

                if (this.node.getParent()) {
                  this._registerTargetEvents();
                }
              };

              _proto._registerEvent = function _registerEvent() {

                this.node.on(SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
                this.node.on(SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              };

              _proto._unregisterEvent = function _unregisterEvent() {

                this.node.off(SystemEventType.ANCHOR_CHANGED, this._adjustWidgetToAnchorChanged, this);
              };

              _proto._removeParentEvent = function _removeParentEvent() {
                this.node.off(SystemEventType.PARENT_CHANGED, this._adjustTargetToParentChanged, this);
              };

              _proto._autoChangedValue = function _autoChangedValue(flag, isAbs) {
                var current = (this._alignFlags & flag) > 0;

                if (!current) {
                  return;
                }

                var parentUiProps = this.node.parent && this.node.parent._uiProps;
                var parentTrans = parentUiProps && parentUiProps.uiTransformComp;
                var size = parentTrans ? parentTrans.contentSize : visibleRect;

                if (this.isAlignLeft && flag === AlignFlags.LEFT) {
                  this._left = isAbs ? this._left * size.width : this._left / size.width;
                } else if (this.isAlignRight && flag === AlignFlags.RIGHT) {
                  this._right = isAbs ? this._right * size.width : this._right / size.width;
                } else if (this.isAlignHorizontalCenter && flag === AlignFlags.CENTER) {
                  this._horizontalCenter = isAbs ? this._horizontalCenter * size.width : this._horizontalCenter / size.width;
                } else if (this.isAlignTop && flag === AlignFlags.TOP) {
                  this._top = isAbs ? this._top * size.height : this._top / size.height;
                } else if (this.isAlignBottom && flag === AlignFlags.BOT) {
                  this._bottom = isAbs ? this._bottom * size.height : this._bottom / size.height;
                } else if (this.isAbsoluteVerticalCenter && flag === AlignFlags.MID) {
                  this._verticalCenter = isAbs ? this._verticalCenter / size.height : this._verticalCenter / size.height;
                }

                this._recursiveDirty();
              };

              _proto._registerTargetEvents = function _registerTargetEvents() {
                var target = this._target || this.node.parent;

                if (target) {
                  if (target.getComponent(UITransform)) {
                    target.on(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this);
                    target.on(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this);
                  }
                }
              };

              _proto._unregisterTargetEvents = function _unregisterTargetEvents() {
                var target = this._target || this.node.parent;

                if (target) {
                  target.off(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this);
                  target.off(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this);
                }
              };

              _proto._unregisterOldParentEvents = function _unregisterOldParentEvents(oldParent) {
                var target = this._target || oldParent;

                if (target) {
                  target.off(SystemEventType.TRANSFORM_CHANGED, this._targetChangedOperation, this);
                  target.off(SystemEventType.SIZE_CHANGED, this._targetChangedOperation, this);
                }
              };

              _proto._targetChangedOperation = function _targetChangedOperation() {
                if (this.alignMode === AlignMode.ALWAYS) {
                  this._recursiveDirty();
                }
              };

              _proto._setAlign = function _setAlign(flag, isAlign) {
                var current = (this._alignFlags & flag) > 0;

                if (isAlign === current) {
                  return;
                }

                var isHorizontal = (flag & LEFT_RIGHT) > 0;
                var trans = this.node._uiProps.uiTransformComp;

                if (isAlign) {
                  this._alignFlags |= flag;

                  if (isHorizontal) {
                    this.isAlignHorizontalCenter = false;

                    if (this.isStretchWidth) {
                      this._originalWidth = trans.width;
                    }
                  } else {
                    this.isAlignVerticalCenter = false;

                    if (this.isStretchHeight) {
                      this._originalHeight = trans.height;
                    }
                  }
                } else {
                  if (isHorizontal) {
                    if (this.isStretchWidth) {
                      trans.width = this._originalWidth;
                    }
                  } else if (this.isStretchHeight) {
                    trans.height = this._originalHeight;
                  }

                  this._alignFlags &= ~flag;
                }
              };

              _proto._recursiveDirty = function _recursiveDirty() {
                if (this._dirty) {
                  return;
                }

                this._dirty = true;
              };

              _createClass(Widget, [{
                key: "target",
                get: function get() {
                  return this._target;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  this._unregisterTargetEvents();

                  this._target = value;

                  this._registerTargetEvents();

                  this._validateTargetInDEV();

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignTop",
                get: function get() {
                  return (this._alignFlags & AlignFlags.TOP) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.TOP, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignBottom",
                get: function get() {
                  return (this._alignFlags & AlignFlags.BOT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.BOT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignLeft",
                get: function get() {
                  return (this._alignFlags & AlignFlags.LEFT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.LEFT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignRight",
                get: function get() {
                  return (this._alignFlags & AlignFlags.RIGHT) > 0;
                },
                set: function set(value) {
                  this._setAlign(AlignFlags.RIGHT, value);

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignVerticalCenter",
                get: function get() {
                  return (this._alignFlags & AlignFlags.MID) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this.isAlignTop = false;
                    this.isAlignBottom = false;
                    this._alignFlags |= AlignFlags.MID;
                  } else {
                    this._alignFlags &= ~AlignFlags.MID;
                  }

                  this._recursiveDirty();
                }
              }, {
                key: "isAlignHorizontalCenter",
                get: function get() {
                  return (this._alignFlags & AlignFlags.CENTER) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this.isAlignLeft = false;
                    this.isAlignRight = false;
                    this._alignFlags |= AlignFlags.CENTER;
                  } else {
                    this._alignFlags &= ~AlignFlags.CENTER;
                  }

                  this._recursiveDirty();
                }
              }, {
                key: "isStretchWidth",
                get: function get() {
                  return (this._alignFlags & LEFT_RIGHT) === LEFT_RIGHT;
                }
              }, {
                key: "isStretchHeight",
                get: function get() {
                  return (this._alignFlags & TOP_BOT) === TOP_BOT;
                }
              }, {
                key: "top",
                get: function get() {
                  return this._top;
                },
                set: function set(value) {
                  this._top = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorTop",
                get: function get() {
                  return this._isAbsTop ? this._top : this._top * 100;
                },
                set: function set(value) {
                  this._top = this._isAbsTop ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "bottom",
                get: function get() {
                  return this._bottom;
                },
                set: function set(value) {
                  this._bottom = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorBottom",
                get: function get() {
                  return this._isAbsBottom ? this._bottom : this._bottom * 100;
                },
                set: function set(value) {
                  this._bottom = this._isAbsBottom ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "left",
                get: function get() {
                  return this._left;
                },
                set: function set(value) {
                  this._left = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorLeft",
                get: function get() {
                  return this._isAbsLeft ? this._left : this._left * 100;
                },
                set: function set(value) {
                  this._left = this._isAbsLeft ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "right",
                get: function get() {
                  return this._right;
                },
                set: function set(value) {
                  this._right = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorRight",
                get: function get() {
                  return this._isAbsRight ? this._right : this._right * 100;
                },
                set: function set(value) {
                  this._right = this._isAbsRight ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "horizontalCenter",
                get: function get() {
                  return this._horizontalCenter;
                },
                set: function set(value) {
                  this._horizontalCenter = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorHorizontalCenter",
                get: function get() {
                  return this._isAbsHorizontalCenter ? this._horizontalCenter : this._horizontalCenter * 100;
                },
                set: function set(value) {
                  this._horizontalCenter = this._isAbsHorizontalCenter ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "verticalCenter",
                get: function get() {
                  return this._verticalCenter;
                },
                set: function set(value) {
                  this._verticalCenter = value;

                  this._recursiveDirty();
                }
              }, {
                key: "editorVerticalCenter",
                get: function get() {
                  return this._isAbsVerticalCenter ? this._verticalCenter : this._verticalCenter * 100;
                },
                set: function set(value) {
                  this._verticalCenter = this._isAbsVerticalCenter ? value : value / 100;

                  this._recursiveDirty();
                }
              }, {
                key: "isAbsoluteTop",
                get: function get() {
                  return this._isAbsTop;
                },
                set: function set(value) {
                  if (this._isAbsTop === value) {
                    return;
                  }

                  this._isAbsTop = value;

                  this._autoChangedValue(AlignFlags.TOP, this._isAbsTop);
                }
              }, {
                key: "isAbsoluteBottom",
                get: function get() {
                  return this._isAbsBottom;
                },
                set: function set(value) {
                  if (this._isAbsBottom === value) {
                    return;
                  }

                  this._isAbsBottom = value;

                  this._autoChangedValue(AlignFlags.BOT, this._isAbsBottom);
                }
              }, {
                key: "isAbsoluteLeft",
                get: function get() {
                  return this._isAbsLeft;
                },
                set: function set(value) {
                  if (this._isAbsLeft === value) {
                    return;
                  }

                  this._isAbsLeft = value;

                  this._autoChangedValue(AlignFlags.LEFT, this._isAbsLeft);
                }
              }, {
                key: "isAbsoluteRight",
                get: function get() {
                  return this._isAbsRight;
                },
                set: function set(value) {
                  if (this._isAbsRight === value) {
                    return;
                  }

                  this._isAbsRight = value;

                  this._autoChangedValue(AlignFlags.RIGHT, this._isAbsRight);
                }
              }, {
                key: "isAbsoluteHorizontalCenter",
                get: function get() {
                  return this._isAbsHorizontalCenter;
                },
                set: function set(value) {
                  if (this._isAbsHorizontalCenter === value) {
                    return;
                  }

                  this._isAbsHorizontalCenter = value;

                  this._autoChangedValue(AlignFlags.CENTER, this._isAbsHorizontalCenter);
                }
              }, {
                key: "isAbsoluteVerticalCenter",
                get: function get() {
                  return this._isAbsVerticalCenter;
                },
                set: function set(value) {
                  if (this._isAbsVerticalCenter === value) {
                    return;
                  }

                  this._isAbsVerticalCenter = value;

                  this._autoChangedValue(AlignFlags.MID, this._isAbsVerticalCenter);
                }
              }, {
                key: "alignMode",
                get: function get() {
                  return this._alignMode;
                },
                set: function set(value) {
                  this._alignMode = value;

                  this._recursiveDirty();
                }
              }, {
                key: "alignFlags",
                get: function get() {
                  return this._alignFlags;
                },
                set: function set(value) {
                  if (this._alignFlags === value) {
                    return;
                  }

                  this._alignFlags = value;

                  this._recursiveDirty();
                }
              }]);

              return Widget;
            }(Component), _class3$f.AlignMode = AlignMode, _temp$B), (_applyDecoratedDescriptor(_class2$y.prototype, "target", [_dec6$r, _dec7$r], Object.getOwnPropertyDescriptor(_class2$y.prototype, "target"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignTop", [_dec8$n], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignTop"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignBottom", [_dec9$l], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignBottom"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignLeft", [_dec10$j], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignLeft"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignRight", [_dec11$i], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignRight"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignVerticalCenter", [_dec12$h], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignVerticalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAlignHorizontalCenter", [_dec13$g], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAlignHorizontalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isStretchWidth", [_dec14$c], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isStretchWidth"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isStretchHeight", [_dec15$b], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isStretchHeight"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorTop", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorTop"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorBottom", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorBottom"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorLeft", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorLeft"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorRight", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorRight"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorHorizontalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "editorVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "editorVerticalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteTop", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteTop"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteBottom", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteBottom"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteLeft", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteLeft"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteRight", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteRight"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteHorizontalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteHorizontalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "isAbsoluteVerticalCenter", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "isAbsoluteVerticalCenter"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "alignMode", [_dec16$a, _dec17$9], Object.getOwnPropertyDescriptor(_class2$y.prototype, "alignMode"), _class2$y.prototype), _applyDecoratedDescriptor(_class2$y.prototype, "alignFlags", [editable], Object.getOwnPropertyDescriptor(_class2$y.prototype, "alignFlags"), _class2$y.prototype), _descriptor$x = _applyDecoratedDescriptor(_class2$y.prototype, "_alignFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$t = _applyDecoratedDescriptor(_class2$y.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$p = _applyDecoratedDescriptor(_class2$y.prototype, "_left", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor4$k = _applyDecoratedDescriptor(_class2$y.prototype, "_right", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor5$g = _applyDecoratedDescriptor(_class2$y.prototype, "_top", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor6$b = _applyDecoratedDescriptor(_class2$y.prototype, "_bottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor7$a = _applyDecoratedDescriptor(_class2$y.prototype, "_horizontalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor8$a = _applyDecoratedDescriptor(_class2$y.prototype, "_verticalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor9$9 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsLeft", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor10$8 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsRight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor11$7 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor12$5 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsBottom", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor13$4 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsHorizontalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor14$3 = _applyDecoratedDescriptor(_class2$y.prototype, "_isAbsVerticalCenter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor15$2 = _applyDecoratedDescriptor(_class2$y.prototype, "_originalWidth", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor16$2 = _applyDecoratedDescriptor(_class2$y.prototype, "_originalHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor17 = _applyDecoratedDescriptor(_class2$y.prototype, "_alignMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return AlignMode.ON_WINDOW_RESIZE;
              }
            }), _descriptor18 = _applyDecoratedDescriptor(_class2$y.prototype, "_lockFlags", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$y)) || _class$F) || _class$F) || _class$F) || _class$F) || _class$F) || _class$F));
            legacyCC.internal.computeInverseTransForTarget = computeInverseTransForTarget;
            legacyCC.internal.getReadonlyNodeSize = getReadonlyNodeSize;

            var _dec$G, _dec2$A, _dec3$y, _dec4$w, _dec5$t, _dec6$s, _dec7$s, _dec8$o, _dec9$m, _dec10$k, _dec11$j, _class$G, _class2$z, _descriptor$y, _descriptor2$u, _descriptor3$q, _descriptor4$l, _class3$g, _temp$C;

            var _color$1 = new Color();

            var Direction$2;

            (function (Direction) {
              Direction[Direction["HORIZONTAL"] = 0] = "HORIZONTAL";
              Direction[Direction["VERTICAL"] = 1] = "VERTICAL";
            })(Direction$2 || (Direction$2 = {}));

            ccenum(Direction$2);
            var PageViewIndicator = function (v) { return exports({ PageViewIndicator: v, PageViewIndicatorComponent: v }), v; }((_dec$G = ccclass('cc.PageViewIndicator'), _dec2$A = help(), _dec3$y = executionOrder(110), _dec4$w = menu(), _dec5$t = type(SpriteFrame), _dec6$s = tooltip(), _dec7$s = type(Direction$2), _dec8$o = tooltip(), _dec9$m = type(Size), _dec10$k = tooltip(), _dec11$j = tooltip(), _dec$G(_class$G = _dec2$A(_class$G = _dec3$y(_class$G = _dec4$w(_class$G = (_class2$z = (_temp$C = _class3$g = function (_Component) {
              _inheritsLoose(PageViewIndicator, _Component);

              function PageViewIndicator() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "spacing", _descriptor$y, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spriteFrame", _descriptor2$u, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$q, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_cellSize", _descriptor4$l, _assertThisInitialized(_this));

                _this._layout = null;
                _this._pageView = null;
                _this._indicators = [];
                return _this;
              }

              var _proto = PageViewIndicator.prototype;

              _proto.onLoad = function onLoad() {
                this._updateLayout();
              };

              _proto.setPageView = function setPageView(target) {
                this._pageView = target;

                this._refresh();
              };

              _proto._updateLayout = function _updateLayout() {
                this._layout = this.getComponent(Layout);

                if (!this._layout) {
                  this._layout = this.addComponent(Layout);
                }

                var layout = this._layout;

                if (this.direction === Direction$2.HORIZONTAL) {
                  layout.type = Layout.Type.HORIZONTAL;
                  layout.spacingX = this.spacing;
                } else if (this.direction === Direction$2.VERTICAL) {
                  layout.type = Layout.Type.VERTICAL;
                  layout.spacingY = this.spacing;
                }

                layout.resizeMode = Layout.ResizeMode.CONTAINER;
              };

              _proto._createIndicator = function _createIndicator() {
                var node = new Node();
                var sprite = node.addComponent(Sprite);
                sprite.spriteFrame = this.spriteFrame;
                sprite.sizeMode = Sprite.SizeMode.CUSTOM;
                node.parent = this.node;

                node._uiProps.uiTransformComp.setContentSize(this._cellSize);

                return node;
              };

              _proto._changedState = function _changedState() {
                var indicators = this._indicators;

                if (indicators.length === 0 || !this._pageView) {
                  return;
                }

                var idx = this._pageView.curPageIdx;

                if (idx >= indicators.length) {
                  return;
                }

                for (var i = 0; i < indicators.length; ++i) {
                  var node = indicators[i];

                  if (!node._uiProps.uiComp) {
                    continue;
                  }

                  var uiComp = node._uiProps.uiComp;

                  _color$1.set(uiComp.color);

                  _color$1.a = 255 / 2;
                  uiComp.color = _color$1;
                }

                if (indicators[idx]._uiProps.uiComp) {
                  var comp = indicators[idx]._uiProps.uiComp;

                  _color$1.set(comp.color);

                  _color$1.a = 255;
                  comp.color = _color$1;
                }
              };

              _proto._refresh = function _refresh() {
                if (!this._pageView) {
                  return;
                }

                var indicators = this._indicators;

                var pages = this._pageView.getPages();

                if (pages.length === indicators.length) {
                  return;
                }

                var i = 0;

                if (pages.length > indicators.length) {
                  for (i = 0; i < pages.length; ++i) {
                    if (!indicators[i]) {
                      indicators[i] = this._createIndicator();
                    }
                  }
                } else {
                  var count = indicators.length - pages.length;

                  for (i = count; i > 0; --i) {
                    var node = indicators[i - 1];
                    this.node.removeChild(node);
                    indicators.splice(i - 1, 1);
                  }
                }

                if (this._layout && this._layout.enabledInHierarchy) {
                  this._layout.updateLayout();
                }

                this._changedState();
              };

              _createClass(PageViewIndicator, [{
                key: "spriteFrame",
                get: function get() {
                  return this._spriteFrame;
                },
                set: function set(value) {
                  if (this._spriteFrame === value) {
                    return;
                  }

                  this._spriteFrame = value;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;
                }
              }, {
                key: "cellSize",
                get: function get() {
                  return this._cellSize;
                },
                set: function set(value) {
                  if (this._cellSize === value) {
                    return;
                  }

                  this._cellSize = value;
                }
              }]);

              return PageViewIndicator;
            }(Component), _class3$g.Direction = Direction$2, _temp$C), (_applyDecoratedDescriptor(_class2$z.prototype, "spriteFrame", [_dec5$t, _dec6$s], Object.getOwnPropertyDescriptor(_class2$z.prototype, "spriteFrame"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "direction", [_dec7$s, _dec8$o], Object.getOwnPropertyDescriptor(_class2$z.prototype, "direction"), _class2$z.prototype), _applyDecoratedDescriptor(_class2$z.prototype, "cellSize", [_dec9$m, _dec10$k], Object.getOwnPropertyDescriptor(_class2$z.prototype, "cellSize"), _class2$z.prototype), _descriptor$y = _applyDecoratedDescriptor(_class2$z.prototype, "spacing", [serializable, _dec11$j], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$u = _applyDecoratedDescriptor(_class2$z.prototype, "_spriteFrame", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$q = _applyDecoratedDescriptor(_class2$z.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Direction$2.HORIZONTAL;
              }
            }), _descriptor4$l = _applyDecoratedDescriptor(_class2$z.prototype, "_cellSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Size(20, 20);
              }
            })), _class2$z)) || _class$G) || _class$G) || _class$G) || _class$G));

            var _dec$H, _dec2$B, _dec3$z, _dec4$x, _dec5$u, _dec6$t, _dec7$t, _dec8$p, _dec9$n, _dec10$l, _dec11$k, _dec12$i, _dec13$h, _dec14$d, _dec15$c, _dec16$b, _dec17$a, _dec18$8, _dec19$7, _dec20$6, _dec21$6, _dec22$6, _dec23$6, _dec24$6, _dec25$6, _dec26$5, _class$H, _class2$A, _descriptor$z, _descriptor2$v, _descriptor3$r, _descriptor4$m, _descriptor5$h, _descriptor6$c, _descriptor7$b, _descriptor8$b, _descriptor9$a, _descriptor10$9, _descriptor11$8, _descriptor12$6, _class3$h, _temp$D;

            var _temp_vec2 = new Vec2();

            var SizeMode$1;

            (function (SizeMode) {
              SizeMode[SizeMode["Unified"] = 0] = "Unified";
              SizeMode[SizeMode["Free"] = 1] = "Free";
            })(SizeMode$1 || (SizeMode$1 = {}));

            ccenum(SizeMode$1);
            var Direction$3;

            (function (Direction) {
              Direction[Direction["Horizontal"] = 0] = "Horizontal";
              Direction[Direction["Vertical"] = 1] = "Vertical";
            })(Direction$3 || (Direction$3 = {}));

            ccenum(Direction$3);
            var EventType$5;

            (function (EventType) {
              EventType["PAGE_TURNING"] = "page-turning";
            })(EventType$5 || (EventType$5 = {}));

            var PageView = function (v) { return exports({ PageView: v, PageViewComponent: v }), v; }((_dec$H = ccclass('cc.PageView'), _dec2$B = help(), _dec3$z = executionOrder(110), _dec4$x = menu(), _dec5$u = type(SizeMode$1), _dec6$t = tooltip(), _dec7$t = type(Direction$3), _dec8$p = tooltip(), _dec9$n = range(), _dec10$l = tooltip(), _dec11$k = range(), _dec12$i = tooltip(), _dec13$h = type(PageViewIndicator), _dec14$d = tooltip(), _dec15$c = tooltip(), _dec16$b = type(ScrollBar), _dec17$a = visible(), _dec18$8 = type(ScrollBar), _dec19$7 = visible(), _dec20$6 = visible(), _dec21$6 = visible(), _dec22$6 = visible(), _dec23$6 = type([EventHandler]), _dec24$6 = visible(), _dec25$6 = type([EventHandler]), _dec26$5 = tooltip(), _dec$H(_class$H = _dec2$B(_class$H = _dec3$z(_class$H = _dec4$x(_class$H = (_class2$A = (_temp$D = _class3$h = function (_ScrollView) {
              _inheritsLoose(PageView, _ScrollView);

              function PageView() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _ScrollView.call.apply(_ScrollView, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "autoPageTurningThreshold", _descriptor$z, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "horizontal", _descriptor2$v, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "vertical", _descriptor3$r, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "cancelInnerEvents", _descriptor4$m, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "scrollEvents", _descriptor5$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "pageTurningSpeed", _descriptor6$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "pageEvents", _descriptor7$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_sizeMode", _descriptor8$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor9$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_scrollThreshold", _descriptor10$9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pageTurningEventTiming", _descriptor11$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_indicator", _descriptor12$6, _assertThisInitialized(_this));

                _this._curPageIdx = 0;
                _this._lastPageIdx = 0;
                _this._pages = [];
                _this._initContentPos = new Vec3();
                _this._scrollCenterOffsetX = [];
                _this._scrollCenterOffsetY = [];
                _this._touchBeganPosition = new Vec3();
                _this._touchEndPosition = new Vec3();
                return _this;
              }

              var _proto = PageView.prototype;

              _proto.onEnable = function onEnable() {
                _ScrollView.prototype.onEnable.call(this);

                this.node.on(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.on(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              };

              _proto.onDisable = function onDisable() {
                _ScrollView.prototype.onDisable.call(this);

                this.node.off(SystemEventType.SIZE_CHANGED, this._updateAllPagesSize, this);

                {
                  this.node.off(PageView.EventType.SCROLL_ENG_WITH_THRESHOLD, this._dispatchPageTurningEvent, this);
                }
              };

              _proto.onLoad = function onLoad() {
                this._initPages();

                if (this.indicator) {
                  this.indicator.setPageView(this);
                }
              };

              _proto.getCurrentPageIndex = function getCurrentPageIndex() {
                return this._curPageIdx;
              };

              _proto.setCurrentPageIndex = function setCurrentPageIndex(index) {
                this.scrollToPage(index, 1);
              };

              _proto.getPages = function getPages() {
                return this._pages;
              };

              _proto.addPage = function addPage(page) {
                if (!page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                if (!page._uiProps.uiTransformComp) {
                  logID(4301);
                  return;
                }

                this.content.addChild(page);

                this._pages.push(page);

                this._updatePageView();
              };

              _proto.insertPage = function insertPage(page, index) {
                if (index < 0 || !page || this._pages.indexOf(page) !== -1 || !this.content) {
                  return;
                }

                var pageCount = this._pages.length;

                if (index >= pageCount) {
                  this.addPage(page);
                } else {
                  if (!page._uiProps.uiTransformComp) {
                    logID(4301);
                    return;
                  }

                  this._pages.splice(index, 0, page);

                  this.content.insertChild(page, index);

                  this._updatePageView();
                }
              };

              _proto.removePage = function removePage(page) {
                if (!page || !this.content) {
                  return;
                }

                var index = this._pages.indexOf(page);

                if (index === -1) {
                  warnID(4300, page.name);
                  return;
                }

                this.removePageAtIndex(index);
              };

              _proto.removePageAtIndex = function removePageAtIndex(index) {
                var pageList = this._pages;

                if (index < 0 || index >= pageList.length) {
                  return;
                }

                var page = pageList[index];

                if (!page || !this.content) {
                  return;
                }

                this.content.removeChild(page);
                pageList.splice(index, 1);

                this._updatePageView();
              };

              _proto.removeAllPages = function removeAllPages() {
                if (!this.content) {
                  return;
                }

                var locPages = this._pages;

                for (var i = 0, len = locPages.length; i < len; i++) {
                  this.content.removeChild(locPages[i]);
                }

                this._pages.length = 0;

                this._updatePageView();
              };

              _proto.scrollToPage = function scrollToPage(idx, timeInSecond) {
                if (timeInSecond === void 0) {
                  timeInSecond = 0.3;
                }

                if (idx < 0 || idx >= this._pages.length) {
                  return;
                }

                this._curPageIdx = idx;
                this.scrollToOffset(this._moveOffsetValue(idx), timeInSecond, true);

                if (this.indicator) {
                  this.indicator._changedState();
                }
              };

              _proto.getScrollEndedEventTiming = function getScrollEndedEventTiming() {
                return this.pageTurningEventTiming;
              };

              _proto._updatePageView = function _updatePageView() {
                if (!this.content) {
                  return;
                }

                var layout = this.content.getComponent(Layout);

                if (layout && layout.enabled) {
                  layout.updateLayout();
                }

                var pageCount = this._pages.length;

                if (this._curPageIdx >= pageCount) {
                  this._curPageIdx = pageCount === 0 ? 0 : pageCount - 1;
                  this._lastPageIdx = this._curPageIdx;
                }

                var contentPos = this._initContentPos;

                for (var i = 0; i < pageCount; ++i) {
                  var page = this._pages[i];
                  var pos = page.position;

                  if (this.direction === Direction$3.Horizontal) {
                    this._scrollCenterOffsetX[i] = Math.abs(contentPos.x + pos.x);
                  } else {
                    this._scrollCenterOffsetY[i] = Math.abs(contentPos.y + pos.y);
                  }
                }

                if (this.indicator) {
                  this.indicator._refresh();
                }
              };

              _proto._updateAllPagesSize = function _updateAllPagesSize() {
                var viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                if (this._sizeMode !== SizeMode$1.Unified) {
                  return;
                }

                var locPages =  this._pages;
                var selfSize = viewTrans.contentSize;

                for (var i = 0, len = locPages.length; i < len; i++) {
                  locPages[i]._uiProps.uiTransformComp.setContentSize(selfSize);
                }
              };

              _proto._handleReleaseLogic = function _handleReleaseLogic() {
                this._autoScrollToPage();

                if (this._scrolling) {
                  this._scrolling = false;

                  if (!this._autoScrolling) {
                    this._dispatchEvent(PageView.EventType.SCROLL_ENDED);
                  }
                }
              };

              _proto._onTouchBegan = function _onTouchBegan(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2);
                Vec3.set(this._touchBeganPosition, _temp_vec2.x, _temp_vec2.y, 0);

                _ScrollView.prototype._onTouchBegan.call(this, event, captureListeners);
              };

              _proto._onTouchMoved = function _onTouchMoved(event, captureListeners) {
                _ScrollView.prototype._onTouchMoved.call(this, event, captureListeners);
              };

              _proto._onTouchEnded = function _onTouchEnded(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2);
                Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0);

                _ScrollView.prototype._onTouchEnded.call(this, event, captureListeners);
              };

              _proto._onTouchCancelled = function _onTouchCancelled(event, captureListeners) {
                event.touch.getUILocation(_temp_vec2);
                Vec3.set(this._touchEndPosition, _temp_vec2.x, _temp_vec2.y, 0);

                _ScrollView.prototype._onTouchCancelled.call(this, event, captureListeners);
              };

              _proto._onMouseWheel = function _onMouseWheel() {};

              _proto._syncScrollDirection = function _syncScrollDirection() {
                this.horizontal = this.direction === Direction$3.Horizontal;
                this.vertical = this.direction === Direction$3.Vertical;
              };

              _proto._syncSizeMode = function _syncSizeMode() {
                var viewTrans = this.view;

                if (!this.content || !viewTrans) {
                  return;
                }

                var layout = this.content.getComponent(Layout);

                if (layout) {
                  if (this._sizeMode === SizeMode$1.Free && this._pages.length > 0) {
                    var firstPageTrans = this._pages[0]._uiProps.uiTransformComp;
                    var lastPageTrans = this._pages[this._pages.length - 1]._uiProps.uiTransformComp;

                    if (this.direction === Direction$3.Horizontal) {
                      layout.paddingLeft = (viewTrans.width - firstPageTrans.width) / 2;
                      layout.paddingRight = (viewTrans.width - lastPageTrans.width) / 2;
                    } else if (this.direction === Direction$3.Vertical) {
                      layout.paddingTop = (viewTrans.height - firstPageTrans.height) / 2;
                      layout.paddingBottom = (viewTrans.height - lastPageTrans.height) / 2;
                    }
                  }

                  layout.updateLayout();
                }
              };

              _proto._initPages = function _initPages() {
                if (!this.content) {
                  return;
                }

                this._initContentPos = this.content.position;
                var children = this.content.children;

                for (var i = 0; i < children.length; ++i) {
                  var page = children[i];

                  if (this._pages.indexOf(page) >= 0) {
                    continue;
                  }

                  this._pages.push(page);
                }

                this._syncScrollDirection();

                this._syncSizeMode();

                this._updatePageView();
              };

              _proto._dispatchPageTurningEvent = function _dispatchPageTurningEvent() {
                if (this._lastPageIdx === this._curPageIdx) {
                  return;
                }

                this._lastPageIdx = this._curPageIdx;
                EventHandler.emitEvents(this.pageEvents, this, EventType$5.PAGE_TURNING);
                this.node.emit(EventType$5.PAGE_TURNING, this);
              };

              _proto._isQuicklyScrollable = function _isQuicklyScrollable(touchMoveVelocity) {
                if (this.direction === Direction$3.Horizontal) {
                  if (Math.abs(touchMoveVelocity.x) > this.autoPageTurningThreshold) {
                    return true;
                  }
                } else if (this.direction === Direction$3.Vertical) {
                  if (Math.abs(touchMoveVelocity.y) > this.autoPageTurningThreshold) {
                    return true;
                  }
                }

                return false;
              };

              _proto._moveOffsetValue = function _moveOffsetValue(idx) {
                var offset = new Vec3();

                if (this._sizeMode === SizeMode$1.Free) {
                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = this._scrollCenterOffsetX[idx];
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = this._scrollCenterOffsetY[idx];
                  }
                } else {
                  var viewTrans = this.view;

                  if (!viewTrans) {
                    return offset;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    offset.x = idx * viewTrans.width;
                  } else if (this.direction === Direction$3.Vertical) {
                    offset.y = idx * viewTrans.height;
                  }
                }

                return offset;
              };

              _proto._getDragDirection = function _getDragDirection(moveOffset) {
                if (this._direction === Direction$3.Horizontal) {
                  if (moveOffset.x === 0) {
                    return 0;
                  }

                  return moveOffset.x > 0 ? 1 : -1;
                } else {
                  if (moveOffset.y === 0) {
                    return 0;
                  }

                  return moveOffset.y < 0 ? 1 : -1;
                }
              };

              _proto._isScrollable = function _isScrollable(offset, index, nextIndex) {
                if (this._sizeMode === SizeMode$1.Free) {
                  var curPageCenter = 0;
                  var nextPageCenter = 0;

                  if (this.direction === Direction$3.Horizontal) {
                    curPageCenter = this._scrollCenterOffsetX[index];
                    nextPageCenter = this._scrollCenterOffsetX[nextIndex];
                    return Math.abs(offset.x) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    curPageCenter = this._scrollCenterOffsetY[index];
                    nextPageCenter = this._scrollCenterOffsetY[nextIndex];
                    return Math.abs(offset.y) >= Math.abs(curPageCenter - nextPageCenter) * this.scrollThreshold;
                  }
                } else {
                  var viewTrans = this.view;

                  if (!viewTrans) {
                    return;
                  }

                  if (this.direction === Direction$3.Horizontal) {
                    return Math.abs(offset.x) >= viewTrans.width * this.scrollThreshold;
                  } else if (this.direction === Direction$3.Vertical) {
                    return Math.abs(offset.y) >= viewTrans.height * this.scrollThreshold;
                  }
                }
              };

              _proto._autoScrollToPage = function _autoScrollToPage() {
                var bounceBackStarted = this._startBounceBackIfNeeded();

                if (bounceBackStarted) {
                  var bounceBackAmount = this._getHowMuchOutOfBoundary();

                  bounceBackAmount = this._clampDelta(bounceBackAmount);

                  if (bounceBackAmount.x > 0 || bounceBackAmount.y < 0) {
                    this._curPageIdx = this._pages.length === 0 ? 0 : this._pages.length - 1;
                  }

                  if (bounceBackAmount.x < 0 || bounceBackAmount.y > 0) {
                    this._curPageIdx = 0;
                  }

                  if (this.indicator) {
                    this.indicator._changedState();
                  }
                } else {
                  var moveOffset = new Vec3();
                  Vec3.subtract(moveOffset, this._touchBeganPosition, this._touchEndPosition);
                  var index = this._curPageIdx;

                  var nextIndex = index + this._getDragDirection(moveOffset);

                  var timeInSecond = this.pageTurningSpeed * Math.abs(index - nextIndex);

                  if (nextIndex < this._pages.length) {
                    if (this._isScrollable(moveOffset, index, nextIndex)) {
                      this.scrollToPage(nextIndex, timeInSecond);
                      return;
                    } else {
                      var touchMoveVelocity = this._calculateTouchMoveVelocity();

                      if (this._isQuicklyScrollable(touchMoveVelocity)) {
                        this.scrollToPage(nextIndex, timeInSecond);
                        return;
                      }
                    }
                  }

                  this.scrollToPage(index, timeInSecond);
                }
              };

              _createClass(PageView, [{
                key: "sizeMode",
                get: function get() {
                  return this._sizeMode;
                },
                set: function set(value) {
                  if (this._sizeMode === value) {
                    return;
                  }

                  this._sizeMode = value;

                  this._syncSizeMode();
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) {
                    return;
                  }

                  this._direction = value;

                  this._syncScrollDirection();
                }
              }, {
                key: "scrollThreshold",
                get: function get() {
                  return this._scrollThreshold;
                },
                set: function set(value) {
                  if (this._scrollThreshold === value) {
                    return;
                  }

                  this._scrollThreshold = value;
                }
              }, {
                key: "pageTurningEventTiming",
                get: function get() {
                  return this._pageTurningEventTiming;
                },
                set: function set(value) {
                  if (this._pageTurningEventTiming === value) {
                    return;
                  }

                  this._pageTurningEventTiming = value;
                }
              }, {
                key: "indicator",
                get: function get() {
                  return this._indicator;
                },
                set: function set(value) {
                  if (this._indicator === value) {
                    return;
                  }

                  this._indicator = value;

                  if (this.indicator) {
                    this.indicator.setPageView(this);
                  }
                }
              }, {
                key: "curPageIdx",
                get: function get() {
                  return this._curPageIdx;
                }
              }, {
                key: "verticalScrollBar",
                get: function get() {
                  return _ScrollView.prototype.verticalScrollBar;
                },
                set: function set(value) {
                  this.verticalScrollBar = value;
                }
              }, {
                key: "horizontalScrollBar",
                get: function get() {
                  return _ScrollView.prototype.horizontalScrollBar;
                },
                set: function set(value) {
                  this.horizontalScrollBar = value;
                }
              }]);

              return PageView;
            }(ScrollView), _class3$h.SizeMode = SizeMode$1, _class3$h.Direction = Direction$3, _class3$h.EventType = extendsEnum(EventType$5, EventType$3), _temp$D), (_applyDecoratedDescriptor(_class2$A.prototype, "sizeMode", [_dec5$u, _dec6$t], Object.getOwnPropertyDescriptor(_class2$A.prototype, "sizeMode"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "direction", [_dec7$t, _dec8$p], Object.getOwnPropertyDescriptor(_class2$A.prototype, "direction"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "scrollThreshold", [slide, _dec9$n, _dec10$l], Object.getOwnPropertyDescriptor(_class2$A.prototype, "scrollThreshold"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "pageTurningEventTiming", [slide, _dec11$k, _dec12$i], Object.getOwnPropertyDescriptor(_class2$A.prototype, "pageTurningEventTiming"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "indicator", [_dec13$h, _dec14$d], Object.getOwnPropertyDescriptor(_class2$A.prototype, "indicator"), _class2$A.prototype), _descriptor$z = _applyDecoratedDescriptor(_class2$A.prototype, "autoPageTurningThreshold", [serializable, _dec15$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 100;
              }
            }), _applyDecoratedDescriptor(_class2$A.prototype, "verticalScrollBar", [_dec16$b, override, _dec17$a], Object.getOwnPropertyDescriptor(_class2$A.prototype, "verticalScrollBar"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "horizontalScrollBar", [_dec18$8, override, _dec19$7], Object.getOwnPropertyDescriptor(_class2$A.prototype, "horizontalScrollBar"), _class2$A.prototype), _descriptor2$v = _applyDecoratedDescriptor(_class2$A.prototype, "horizontal", [override, serializable, _dec20$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor3$r = _applyDecoratedDescriptor(_class2$A.prototype, "vertical", [override, serializable, _dec21$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor4$m = _applyDecoratedDescriptor(_class2$A.prototype, "cancelInnerEvents", [override, serializable, _dec22$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor5$h = _applyDecoratedDescriptor(_class2$A.prototype, "scrollEvents", [_dec23$6, serializable, override, _dec24$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor6$c = _applyDecoratedDescriptor(_class2$A.prototype, "pageTurningSpeed", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.3;
              }
            }), _descriptor7$b = _applyDecoratedDescriptor(_class2$A.prototype, "pageEvents", [_dec25$6, serializable, _dec26$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor8$b = _applyDecoratedDescriptor(_class2$A.prototype, "_sizeMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return SizeMode$1.Unified;
              }
            }), _descriptor9$a = _applyDecoratedDescriptor(_class2$A.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Direction$3.Horizontal;
              }
            }), _descriptor10$9 = _applyDecoratedDescriptor(_class2$A.prototype, "_scrollThreshold", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor11$8 = _applyDecoratedDescriptor(_class2$A.prototype, "_pageTurningEventTiming", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor12$6 = _applyDecoratedDescriptor(_class2$A.prototype, "_indicator", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$A)) || _class$H) || _class$H) || _class$H) || _class$H));

            var _tempPos$1 = new Vec3();

            var _defaultAnchor = new Vec2();

            var tInverseTranslate = new Vec3();
            var tInverseScale = new Vec3(1, 1, 1);

            function align(node, widget) {
              var hasTarget = widget.target;
              var target;
              var inverseTranslate = tInverseTranslate;
              var inverseScale = tInverseScale;

              if (hasTarget) {
                target = hasTarget;
                computeInverseTransForTarget(node, target, inverseTranslate, inverseScale);
              } else {
                target = node.parent;
              }

              var targetSize = getReadonlyNodeSize(target);
              var useGlobal = target instanceof Scene || !target.getComponent(UITransform);
              var targetAnchor = useGlobal ? _defaultAnchor : target.getComponent(UITransform).anchorPoint;
              var isRoot =  useGlobal;
              node.getPosition(_tempPos$1);
              var uiTrans = node._uiProps.uiTransformComp;
              var x = _tempPos$1.x;
              var y = _tempPos$1.y;
              var anchor = uiTrans.anchorPoint;
              var scale = node.getScale();

              if (widget.alignFlags & AlignFlags.HORIZONTAL) {
                var localLeft = 0;
                var localRight = 0;
                var targetWidth = targetSize.width;

                if (isRoot) {
                  localLeft = visibleRect.left.x;
                  localRight = visibleRect.right.x;
                } else {
                  localLeft = -targetAnchor.x * targetWidth;
                  localRight = localLeft + targetWidth;
                }

                localLeft += widget.isAbsoluteLeft ? widget.left : widget.left * targetWidth;
                localRight -= widget.isAbsoluteRight ? widget.right : widget.right * targetWidth;

                if (hasTarget) {
                  localLeft += inverseTranslate.x;
                  localLeft *= inverseScale.x;
                  localRight += inverseTranslate.x;
                  localRight *= inverseScale.x;
                }

                var width = 0;
                var anchorX = anchor.x;
                var scaleX = scale.x;

                if (scaleX < 0) {
                  anchorX = 1.0 - anchorX;
                  scaleX = -scaleX;
                }

                if (widget.isStretchWidth) {
                  width = localRight - localLeft;

                  if (scaleX !== 0) {
                    uiTrans.width = width / scaleX;
                  }

                  x = localLeft + anchorX * width;
                } else {
                  width = uiTrans.width * scaleX;

                  if (widget.isAlignHorizontalCenter) {
                    var localHorizontalCenter = widget.isAbsoluteHorizontalCenter ? widget.horizontalCenter : widget.horizontalCenter * targetWidth;
                    var targetCenter = (0.5 - targetAnchor.x) * targetSize.width;

                    if (hasTarget) {
                      localHorizontalCenter *= inverseScale.x;
                      targetCenter += inverseTranslate.x;
                      targetCenter *= inverseScale.x;
                    }

                    x = targetCenter + (anchorX - 0.5) * width + localHorizontalCenter;
                  } else if (widget.isAlignLeft) {
                    x = localLeft + anchorX * width;
                  } else {
                    x = localRight + (anchorX - 1) * width;
                  }
                }

                widget._lastSize.width = width;
              }

              if (widget.alignFlags & AlignFlags.VERTICAL) {
                var localTop = 0;
                var localBottom = 0;
                var targetHeight = targetSize.height;

                if (isRoot) {
                  localBottom = visibleRect.bottom.y;
                  localTop = visibleRect.top.y;
                } else {
                  localBottom = -targetAnchor.y * targetHeight;
                  localTop = localBottom + targetHeight;
                }

                localBottom += widget.isAbsoluteBottom ? widget.bottom : widget.bottom * targetHeight;
                localTop -= widget.isAbsoluteTop ? widget.top : widget.top * targetHeight;

                if (hasTarget) {
                  localBottom += inverseTranslate.y;
                  localBottom *= inverseScale.y;
                  localTop += inverseTranslate.y;
                  localTop *= inverseScale.y;
                }

                var height = 0;
                var anchorY = anchor.y;
                var scaleY = scale.y;

                if (scaleY < 0) {
                  anchorY = 1.0 - anchorY;
                  scaleY = -scaleY;
                }

                if (widget.isStretchHeight) {
                  height = localTop - localBottom;

                  if (scaleY !== 0) {
                    uiTrans.height = height / scaleY;
                  }

                  y = localBottom + anchorY * height;
                } else {
                  height = uiTrans.height * scaleY;

                  if (widget.isAlignVerticalCenter) {
                    var localVerticalCenter = widget.isAbsoluteVerticalCenter ? widget.verticalCenter : widget.verticalCenter * targetHeight;
                    var targetMiddle = (0.5 - targetAnchor.y) * targetSize.height;

                    if (hasTarget) {
                      localVerticalCenter *= inverseScale.y;
                      targetMiddle += inverseTranslate.y;
                      targetMiddle *= inverseScale.y;
                    }

                    y = targetMiddle + (anchorY - 0.5) * height + localVerticalCenter;
                  } else if (widget.isAlignBottom) {
                    y = localBottom + anchorY * height;
                  } else {
                    y = localTop + (anchorY - 1) * height;
                  }
                }

                widget._lastSize.height = height;
              }

              node.setPosition(x, y, _tempPos$1.z);
              Vec3.set(widget._lastPos, x, y, _tempPos$1.z);
            }

            function visitNode(node) {
              var widget = node.getComponent(Widget);

              if (widget) {

                align(node, widget);

                if ( widget.alignMode === AlignMode.ONCE) {
                  widget.enabled = false;
                } else {
                  if (!legacyCC.isValid(node, true)) {
                    return;
                  }

                  activeWidgets.push(widget);
                }
              }

              var children = node.children;

              for (var _iterator = _createForOfIteratorHelperLoose(children), _step; !(_step = _iterator()).done;) {
                var child = _step.value;

                if (child.active) {
                  visitNode(child);
                }
              }
            }

            function refreshScene() {
              var scene = director.getScene();

              if (scene) {
                widgetManager.isAligning = true;

                if (widgetManager._nodesOrderDirty) {
                  activeWidgets.length = 0;
                  visitNode(scene);
                  widgetManager._nodesOrderDirty = false;
                } else {
                  var widget = null;
                  var iterator = widgetManager._activeWidgetsIterator;

                  for (iterator.i = 0; iterator.i < activeWidgets.length; ++iterator.i) {
                    widget = activeWidgets[iterator.i];

                    if (widget._dirty) {
                      align(widget.node, widget);
                      widget._dirty = false;
                    }
                  }
                }

                widgetManager.isAligning = false;
              }
            }

            var activeWidgets = [];

            function updateAlignment(node) {
              var parent = node.parent;

              if (parent && Node.isNode(parent)) {
                updateAlignment(parent);
              }

              var widget = node.getComponent(Widget);

              if (widget && parent) {
                align(node, widget);
              }
            }

            var widgetManager = exports('widgetManager', legacyCC._widgetManager = {
              isAligning: false,
              _nodesOrderDirty: false,
              _activeWidgetsIterator: new array.MutableForwardIterator(activeWidgets),
              animationState:  null,
              init: function init() {
                director.on(Director.EVENT_AFTER_UPDATE, refreshScene);
                View.instance.on('design-resolution-changed', this.onResized, this);

                {
                  var thisOnResized = this.onResized.bind(this);
                  View.instance.on('canvas-resize', thisOnResized);
                  window.addEventListener('orientationchange', thisOnResized);
                }
              },
              add: function add(widget) {
                this._nodesOrderDirty = true;
              },
              remove: function remove(widget) {
                this._activeWidgetsIterator.remove(widget);
              },
              onResized: function onResized() {
                var scene = director.getScene();

                if (scene) {
                  this.refreshWidgetOnResized(scene);
                }
              },
              refreshWidgetOnResized: function refreshWidgetOnResized(node) {
                var widget = Node.isNode(node) && node.getComponent(Widget);

                if (widget && widget.enabled && (widget.alignMode === AlignMode.ON_WINDOW_RESIZE || widget.alignMode === AlignMode.ALWAYS)) {
                  widget.setDirty();
                }

                var children = node.children;

                for (var _iterator2 = _createForOfIteratorHelperLoose(children), _step2; !(_step2 = _iterator2()).done;) {
                  var child = _step2.value;
                  this.refreshWidgetOnResized(child);
                }
              },
              updateOffsetsToStayPut: function updateOffsetsToStayPut(widget, e) {
                function i(t, c) {
                  return Math.abs(t - c) > 1e-10 ? c : t;
                }

                var widgetNode = widget.node;
                var widgetParent = widgetNode.parent;

                if (widgetParent) {
                  var zero = new Vec3();
                  var one = new Vec3(1, 1, 1);

                  if (widget.target) {
                    widgetParent = widget.target;
                    computeInverseTransForTarget(widgetNode, widgetParent, zero, one);
                  }

                  if (!e) {
                    return;
                  }

                  var parentTrans = widgetParent._uiProps && widgetParent._uiProps.uiTransformComp;
                  var parentAP = parentTrans ? parentTrans.anchorPoint : _defaultAnchor;
                  var trans = widgetNode._uiProps.uiTransformComp;
                  var matchSize = getReadonlyNodeSize(widgetParent);
                  var myAP = trans.anchorPoint;
                  var pos = widgetNode.getPosition();
                  var alignFlags = AlignFlags;
                  var widgetNodeScale = widgetNode.getScale();
                  var temp = 0;

                  if (e & alignFlags.LEFT) {
                    var l = -parentAP.x * matchSize.width;
                    l += zero.x;
                    l *= one.x;
                    temp = pos.x - myAP.x * trans.width * widgetNodeScale.x - l;

                    if (!widget.isAbsoluteLeft) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.left = i(widget.left, temp);
                  }

                  if (e & alignFlags.RIGHT) {
                    var r = (1 - parentAP.x) * matchSize.width;
                    r += zero.x;
                    temp = (r *= one.x) - (pos.x + (1 - myAP.x) * trans.width * widgetNodeScale.x);

                    if (!widget.isAbsoluteRight) {
                      temp /= matchSize.width;
                    }

                    temp /= one.x;
                    widget.right = i(widget.right, temp);
                  }

                  if (e & alignFlags.TOP) {
                    var t = (1 - parentAP.y) * matchSize.height;
                    t += zero.y;
                    temp = (t *= one.y) - (pos.y + (1 - myAP.y) * trans.height * widgetNodeScale.y);

                    if (!widget.isAbsoluteTop) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.top = i(widget.top, temp);
                  }

                  if (e & alignFlags.BOT) {
                    var b = -parentAP.y * matchSize.height;
                    b += zero.y;
                    b *= one.y;
                    temp = pos.y - myAP.y * trans.height * widgetNodeScale.y - b;

                    if (!widget.isAbsoluteBottom) {
                      temp /= matchSize.height;
                    }

                    temp /= one.y;
                    widget.bottom = i(widget.bottom, temp);
                  }
                }
              },
              updateAlignment: updateAlignment,
              AlignMode: AlignMode,
              AlignFlags: AlignFlags
            });
            director.on(Director.EVENT_INIT, function () {
              widgetManager.init();
            });

            var _dec$I, _dec2$C, _dec3$A, _dec4$y, _dec5$v, _class$I;
            var SafeArea = function (v) { return exports({ SafeArea: v, SafeAreaComponent: v }), v; }((_dec$I = ccclass('cc.SafeArea'), _dec2$C = help(), _dec3$A = executionOrder(110), _dec4$y = menu(), _dec5$v = requireComponent(Widget), _dec$I(_class$I = _dec2$C(_class$I = _dec3$A(_class$I = executeInEditMode(_class$I = _dec4$y(_class$I = _dec5$v(_class$I = function (_Component) {
              _inheritsLoose(SafeArea, _Component);

              function SafeArea() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = SafeArea.prototype;

              _proto.onEnable = function onEnable() {
                this.updateArea();
                view.on('canvas-resize', this.updateArea, this);
              };

              _proto.onDisable = function onDisable() {
                view.off('canvas-resize', this.updateArea, this);
              };

              _proto.updateArea = function updateArea() {
                var widget = this.node.getComponent(Widget);
                var uiTransComp = this.node.getComponent(UITransform);

                if (!widget || !uiTransComp) {
                  return;
                }

                widget.updateAlignment();
                var lastPos = this.node.position.clone();
                var lastAnchorPoint = uiTransComp.anchorPoint.clone();
                widget.isAlignTop = widget.isAlignBottom = widget.isAlignLeft = widget.isAlignRight = true;
                var screenWidth = legacyCC.winSize.width;
                var screenHeight = legacyCC.winSize.height;
                var safeArea = sys.getSafeAreaRect();
                widget.top = screenHeight - safeArea.y - safeArea.height;
                widget.bottom = safeArea.y;
                widget.left = safeArea.x;
                widget.right = screenWidth - safeArea.x - safeArea.width;
                widget.updateAlignment();
                var curPos = this.node.position.clone();
                var anchorX = lastAnchorPoint.x - (curPos.x - lastPos.x) / uiTransComp.width;
                var anchorY = lastAnchorPoint.y - (curPos.y - lastPos.y) / uiTransComp.height;
                uiTransComp.setAnchorPoint(anchorX, anchorY);
                widgetManager.add(widget);
              };

              return SafeArea;
            }(Component)) || _class$I) || _class$I) || _class$I) || _class$I) || _class$I) || _class$I));

            var _dec$J, _dec2$D, _dec3$B, _dec4$z, _dec5$w, _dec6$u, _dec7$u, _dec8$q, _dec9$o, _dec10$m, _dec11$l, _dec12$j, _class$J, _class2$B, _descriptor$A, _descriptor2$w, _descriptor3$s, _descriptor4$n, _descriptor5$i, _temp$E;
            var UICoordinateTracker = function (v) { return exports({ UICoordinateTracker: v, UICoordinateTrackerComponent: v }), v; }((_dec$J = ccclass('cc.UICoordinateTracker'), _dec2$D = help(), _dec3$B = menu(), _dec4$z = executionOrder(110), _dec5$w = type(Node), _dec6$u = tooltip(), _dec7$u = type(Camera), _dec8$q = tooltip(), _dec9$o = tooltip(), _dec10$m = tooltip(), _dec11$l = type([EventHandler]), _dec12$j = tooltip(), _dec$J(_class$J = _dec2$D(_class$J = _dec3$B(_class$J = _dec4$z(_class$J = (_class2$B = (_temp$E = function (_Component) {
              _inheritsLoose(UICoordinateTracker, _Component);

              function UICoordinateTracker() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;

                _initializerDefineProperty(_this, "syncEvents", _descriptor$A, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_target", _descriptor2$w, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_camera", _descriptor3$s, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_useScale", _descriptor4$n, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_distance", _descriptor5$i, _assertThisInitialized(_this));

                _this._transformPos = new Vec3();
                _this._viewPos = new Vec3();
                _this._canMove = true;
                _this._lastWPos = new Vec3();
                _this._lastCameraPos = new Vec3();
                return _this;
              }

              var _proto = UICoordinateTracker.prototype;

              _proto.onEnable = function onEnable() {
                this._checkCanMove();
              };

              _proto.update = function update() {
                var wPos = this.node.worldPosition;
                var camera = this._camera;

                if (!this._canMove || !camera || !camera.camera || this._lastWPos.equals(wPos) && this._lastCameraPos.equals(camera.node.worldPosition)) {
                  return;
                }

                this._lastWPos.set(wPos);

                this._lastCameraPos.set(camera.node.worldPosition);

                camera.camera.update();
                camera.convertToUINode(wPos, this._target, this._transformPos);

                if (this._useScale) {
                  Vec3.transformMat4(this._viewPos, this.node.worldPosition, camera.camera.matView);
                }

                if (this.syncEvents.length > 0) {
                  var data = this._distance / Math.abs(this._viewPos.z);
                  EventHandler.emitEvents(this.syncEvents, this._transformPos, data);
                }
              };

              _proto._checkCanMove = function _checkCanMove() {
                this._canMove = !!(this._camera && this._target);
              };

              _createClass(UICoordinateTracker, [{
                key: "target",
                get: function get() {
                  return this._target;
                },
                set: function set(value) {
                  if (this._target === value) {
                    return;
                  }

                  this._target = value;

                  this._checkCanMove();
                }
              }, {
                key: "camera",
                get: function get() {
                  return this._camera;
                },
                set: function set(value) {
                  if (this._camera === value) {
                    return;
                  }

                  this._camera = value;

                  this._checkCanMove();
                }
              }, {
                key: "useScale",
                get: function get() {
                  return this._useScale;
                },
                set: function set(value) {
                  if (this._useScale === value) {
                    return;
                  }

                  this._useScale = value;
                }
              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                },
                set: function set(value) {
                  if (this._distance === value) {
                    return;
                  }

                  this._distance = value;
                }
              }]);

              return UICoordinateTracker;
            }(Component), _temp$E), (_applyDecoratedDescriptor(_class2$B.prototype, "target", [_dec5$w, _dec6$u], Object.getOwnPropertyDescriptor(_class2$B.prototype, "target"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "camera", [_dec7$u, _dec8$q], Object.getOwnPropertyDescriptor(_class2$B.prototype, "camera"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "useScale", [_dec9$o], Object.getOwnPropertyDescriptor(_class2$B.prototype, "useScale"), _class2$B.prototype), _applyDecoratedDescriptor(_class2$B.prototype, "distance", [_dec10$m], Object.getOwnPropertyDescriptor(_class2$B.prototype, "distance"), _class2$B.prototype), _descriptor$A = _applyDecoratedDescriptor(_class2$B.prototype, "syncEvents", [_dec11$l, serializable, _dec12$j], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$w = _applyDecoratedDescriptor(_class2$B.prototype, "_target", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$s = _applyDecoratedDescriptor(_class2$B.prototype, "_camera", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor4$n = _applyDecoratedDescriptor(_class2$B.prototype, "_useScale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor5$i = _applyDecoratedDescriptor(_class2$B.prototype, "_distance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            })), _class2$B)) || _class$J) || _class$J) || _class$J) || _class$J));

            var _dec$K, _dec2$E, _dec3$C, _class$K;
            var BlockEvents = [SystemEventType.TOUCH_START, SystemEventType.TOUCH_END, SystemEventType.TOUCH_MOVE, SystemEventType.MOUSE_DOWN, SystemEventType.MOUSE_MOVE, SystemEventType.MOUSE_UP, SystemEventType.MOUSE_ENTER, SystemEventType.MOUSE_LEAVE, SystemEventType.MOUSE_WHEEL];

            function stopPropagation(event) {
              event.propagationStopped = true;
            }

            var BlockInputEvents = function (v) { return exports({ BlockInputEvents: v, BlockInputEventsComponent: v }), v; }((_dec$K = ccclass('cc.BlockInputEvents'), _dec2$E = help(), _dec3$C = menu(), _dec$K(_class$K = _dec2$E(_class$K = _dec3$C(_class$K = function (_Component) {
              _inheritsLoose(BlockInputEvents, _Component);

              function BlockInputEvents() {
                return _Component.apply(this, arguments) || this;
              }

              var _proto = BlockInputEvents.prototype;

              _proto.onEnable = function onEnable() {
                for (var i = 0; i < BlockEvents.length; i++) {
                  this.node.on(BlockEvents[i], stopPropagation, this);
                }
              };

              _proto.onDisable = function onDisable() {
                for (var i = 0; i < BlockEvents.length; i++) {
                  this.node.off(BlockEvents[i], stopPropagation, this);
                }
              };

              return BlockInputEvents;
            }(Component)) || _class$K) || _class$K) || _class$K));

            var _dec$L, _dec2$F, _dec3$D, _dec4$A, _dec5$x, _dec6$v, _dec7$v, _class$L, _class2$C, _descriptor$B, _descriptor2$x, _temp$F;
            var SubContextView = exports('SubContextView', (_dec$L = ccclass('cc.SubContextView'), _dec2$F = help(), _dec3$D = executionOrder(110), _dec4$A = requireComponent(UITransform), _dec5$x = menu(), _dec6$v = tooltip(), _dec7$v = tooltip(), _dec$L(_class$L = _dec2$F(_class$L = _dec3$D(_class$L = _dec4$A(_class$L = _dec5$x(_class$L = (_class2$C = (_temp$F = function (_Component) {
              _inheritsLoose(SubContextView, _Component);

              _createClass(SubContextView, [{
                key: "designResolutionSize",
                get: function get() {
                  return this._designResolutionSize;
                },
                set: function set(value) {
                  {
                    return;
                  }
                }
              }, {
                key: "fps",
                get: function get() {
                  return this._fps;
                },
                set: function set(value) {
                  if (this._fps === value) {
                    return;
                  }

                  this._fps = value;
                  this._updateInterval = 1000 / value;
                }
              }]);

              function SubContextView() {
                var _this;

                _this = _Component.call(this) || this;

                _initializerDefineProperty(_this, "_fps", _descriptor$B, _assertThisInitialized(_this));

                _this._sprite = void 0;
                _this._imageAsset = void 0;
                _this._updatedTime = 0;
                _this._updateInterval = 0;
                _this._openDataContext = void 0;
                _this._content = void 0;

                _initializerDefineProperty(_this, "_designResolutionSize", _descriptor2$x, _assertThisInitialized(_this));

                _this._content = new PrivateNode('content');
                _this._sprite = null;
                _this._imageAsset = new ImageAsset();
                _this._openDataContext = null;
                _this._updatedTime = performance.now();
                return _this;
              }

              var _proto = SubContextView.prototype;

              _proto.onLoad = function onLoad() {
                if (window.__globalAdapter && __globalAdapter.getOpenDataContext) {
                  this._updateInterval = 1000 / this._fps;
                  this._openDataContext = __globalAdapter.getOpenDataContext();

                  this._initSharedCanvas();

                  this._initContentNode();

                  this._updateSubContextView();
                } else {
                  this.enabled = false;
                }
              };

              _proto.onEnable = function onEnable() {
                this._registerNodeEvent();
              };

              _proto.onDisable = function onDisable() {
                this._unregisterNodeEvent();
              };

              _proto._initSharedCanvas = function _initSharedCanvas() {
                if (this._openDataContext) {
                  var sharedCanvas = this._openDataContext.canvas;
                  sharedCanvas.width = this._designResolutionSize.width;
                  sharedCanvas.height = this._designResolutionSize.height;
                }
              };

              _proto._initContentNode = function _initContentNode() {
                if (this._openDataContext) {
                  var sharedCanvas = this._openDataContext.canvas;
                  var image = this._imageAsset;
                  image.reset(sharedCanvas);

                  image._texture.create(sharedCanvas.width, sharedCanvas.height);

                  this._sprite = this._content.getComponent(Sprite);

                  if (!this._sprite) {
                    this._sprite = this._content.addComponent(Sprite);
                  }

                  if (this._sprite.spriteFrame) {
                    this._sprite.spriteFrame.texture = this._imageAsset._texture;
                  } else {
                    var sp = new SpriteFrame();
                    sp.texture = this._imageAsset._texture;
                    this._sprite.spriteFrame = sp;
                  }

                  this._content.parent = this.node;
                }
              };

              _proto._updateSubContextView = function _updateSubContextView() {
                if (!(this._openDataContext && __globalAdapter && __globalAdapter.getSystemInfoSync)) {
                  return;
                }

                var nodeTrans = this.node.getComponent(UITransform);

                var contentTrans = this._content.getComponent(UITransform);

                var scaleX = nodeTrans.width / contentTrans.width;
                var scaleY = nodeTrans.height / contentTrans.height;
                var scale = scaleX > scaleY ? scaleY : scaleX;
                contentTrans.width *= scale;
                contentTrans.height *= scale;

                var systemInfo = __globalAdapter.getSystemInfoSync();

                var box = contentTrans.getBoundingBoxToWorld();
                var visibleSize = view.getVisibleSize();
                var x = systemInfo.screenWidth * (box.x / visibleSize.width);
                var y = systemInfo.screenHeight * (box.y / visibleSize.height);
                var width = systemInfo.screenWidth * (box.width / visibleSize.width);
                var height = systemInfo.screenHeight * (box.height / visibleSize.height);

                this._openDataContext.postMessage({
                  fromEngine: true,
                  type: 'engine',
                  event: 'viewport',
                  x: x,
                  y: y,
                  width: width,
                  height: height
                });
              };

              _proto._updateSubContextTexture = function _updateSubContextTexture() {
                var img = this._imageAsset;

                if (!img || !this._openDataContext) {
                  return;
                }

                if (img.width <= 0 || img.height <= 0) {
                  return;
                }

                var sharedCanvas = this._openDataContext.canvas;
                img.reset(sharedCanvas);

                if (sharedCanvas.width > img.width || sharedCanvas.height > img.height) {
                  this._imageAsset._texture.create(sharedCanvas.width, sharedCanvas.height);
                }

                this._imageAsset._texture.uploadData(sharedCanvas);
              };

              _proto._registerNodeEvent = function _registerNodeEvent() {
                this.node.on(Node.EventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.on(Node.EventType.SIZE_CHANGED, this._updateSubContextView, this);
              };

              _proto._unregisterNodeEvent = function _unregisterNodeEvent() {
                this.node.off(Node.EventType.TRANSFORM_CHANGED, this._updateSubContextView, this);
                this.node.off(Node.EventType.SIZE_CHANGED, this._updateSubContextView, this);
              };

              _proto.update = function update(dt) {
                var calledUpdateManually = dt === undefined;

                if (calledUpdateManually) {
                  this._updateSubContextTexture();

                  return;
                }

                var now = performance.now();
                var deltaTime = now - this._updatedTime;

                if (deltaTime >= this._updateInterval) {
                  this._updatedTime += this._updateInterval;

                  this._updateSubContextTexture();
                }
              };

              return SubContextView;
            }(Component), _temp$F), (_applyDecoratedDescriptor(_class2$C.prototype, "designResolutionSize", [_dec6$v], Object.getOwnPropertyDescriptor(_class2$C.prototype, "designResolutionSize"), _class2$C.prototype), _applyDecoratedDescriptor(_class2$C.prototype, "fps", [_dec7$v], Object.getOwnPropertyDescriptor(_class2$C.prototype, "fps"), _class2$C.prototype), _descriptor$B = _applyDecoratedDescriptor(_class2$C.prototype, "_fps", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 60;
              }
            }), _descriptor2$x = _applyDecoratedDescriptor(_class2$C.prototype, "_designResolutionSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Size(640, 960);
              }
            })), _class2$C)) || _class$L) || _class$L) || _class$L) || _class$L) || _class$L));
            legacyCC.SubContextView = SubContextView;

            var _dec$M, _class$M;
            var UIReorderComponent = exports('UIReorderComponent', (_dec$M = ccclass('cc.UIReorderComponent'), _dec$M(_class$M = function UIReorderComponent() {
              warnID(1408, 'UIReorderComponent');
            }) || _class$M));
            legacyCC.UIReorderComponent = UIReorderComponent;
            legacyCC.ButtonComponent = Button;
            js.setClassAlias(Button, 'cc.ButtonComponent');
            legacyCC.EditBoxComponent = EditBox;
            js.setClassAlias(EditBox, 'cc.EditBoxComponent');
            legacyCC.LayoutComponent = Layout;
            js.setClassAlias(Layout, 'cc.LayoutComponent');
            legacyCC.ProgressBarComponent = ProgressBar;
            js.setClassAlias(ProgressBar, 'cc.ProgressBarComponent');
            legacyCC.ScrollViewComponent = ScrollView;
            js.setClassAlias(ScrollView, 'cc.ScrollViewComponent');
            legacyCC.ScrollBarComponent = ScrollBar;
            js.setClassAlias(ScrollBar, 'cc.ScrollBarComponent');
            legacyCC.SliderComponent = Slider;
            js.setClassAlias(Slider, 'cc.SliderComponent');
            legacyCC.ToggleComponent = Toggle;
            js.setClassAlias(Toggle, 'cc.ToggleComponent');
            legacyCC.ToggleContainerComponent = ToggleContainer;
            js.setClassAlias(ToggleContainer, 'cc.ToggleContainerComponent');
            legacyCC.WidgetComponent = Widget;
            js.setClassAlias(Widget, 'cc.WidgetComponent');
            legacyCC.PageViewComponent = PageView;
            js.setClassAlias(PageView, 'cc.PageViewComponent');
            legacyCC.PageViewIndicatorComponent = PageViewIndicator;
            js.setClassAlias(PageViewIndicator, 'cc.PageViewIndicatorComponent');
            legacyCC.SafeAreaComponent = SafeArea;
            js.setClassAlias(SafeArea, 'cc.SafeAreaComponent');
            js.setClassAlias(UICoordinateTracker, 'cc.UICoordinateTrackerComponent');
            legacyCC.BlockInputEventsComponent = BlockInputEvents;
            js.setClassAlias(BlockInputEvents, 'cc.BlockInputEventsComponent');

            function select(id, wrapper) {
              legacyCC._global.CC_PHYSICS_BUILTIN = id === 'builtin';
              legacyCC._global.CC_PHYSICS_CANNON = id === 'cannon.js';
              legacyCC._global.CC_PHYSICS_AMMO = id === 'ammo.js';
              warn("[PHYSICS]: Using " + id);
              selector.id = id;
              selector.wrapper = wrapper;
              if (id != null) selector.backend[id] = wrapper;
            }

            var selector = {
              id: '',
              select: select,
              wrapper: {},
              backend: {}
            };

            function cocos2AmmoVec3(out, v) {
              out.setValue(v.x, v.y, v.z);
              return out;
            }
            function ammo2CocosVec3(out, v) {
              out.x = v.x();
              out.y = v.y();
              out.z = v.z();
              return out;
            }
            function cocos2AmmoQuat(out, q) {
              out.setValue(q.x, q.y, q.z, q.w);
              return out;
            }
            function ammo2CocosQuat(out, q) {
              out.x = q.x();
              out.y = q.y();
              out.z = q.z();
              out.w = q.w();
              return out;
            }
            function ammoDeletePtr(obj, klass) {
              var cache = Ammo$1.getCache(klass);
              var ptr = Ammo$1.getPointer(obj);
              delete cache[ptr];
            }
            function cocos2AmmoTriMesh(out, mesh) {
              var len = mesh.renderingSubMeshes.length;

              for (var i = 0; i < len; i++) {
                var subMesh = mesh.renderingSubMeshes[i];
                var geoInfo = subMesh.geometricInfo;

                if (geoInfo) {
                  var primitiveMode = subMesh.primitiveMode;
                  var vb = geoInfo.positions;
                  var ib = geoInfo.indices;
                  var v0 = new Ammo$1.btVector3();
                  var v1 = new Ammo$1.btVector3();
                  var v2 = new Ammo$1.btVector3();

                  if (primitiveMode === PrimitiveMode.TRIANGLE_LIST) {
                    var cnt = ib.length;

                    for (var j = 0; j < cnt; j += 3) {
                      var i0 = ib[j] * 3;
                      var i1 = ib[j + 1] * 3;
                      var i2 = ib[j + 2] * 3;
                      v0.setValue(vb[i0], vb[i0 + 1], vb[i0 + 2]);
                      v1.setValue(vb[i1], vb[i1 + 1], vb[i1 + 2]);
                      v2.setValue(vb[i2], vb[i2 + 1], vb[i2 + 2]);
                      out.addTriangle(v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_STRIP) {
                    var _cnt = ib.length - 2;

                    var rev = 0;

                    for (var _j = 0; _j < _cnt; _j += 1) {
                      var _i = ib[_j - rev] * 3;

                      var _i2 = ib[_j + rev + 1] * 3;

                      var _i3 = ib[_j + 2] * 3;

                      rev = ~rev;
                      v0.setValue(vb[_i], vb[_i + 1], vb[_i + 2]);
                      v1.setValue(vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                      v2.setValue(vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                      out.addTriangle(v0, v1, v2);
                    }
                  } else if (primitiveMode === PrimitiveMode.TRIANGLE_FAN) {
                    var _cnt2 = ib.length - 1;

                    var _i4 = ib[0] * 3;

                    v0.setValue(vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

                    for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                      var _i5 = ib[_j2] * 3;

                      var _i6 = ib[_j2 + 1] * 3;

                      v1.setValue(vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                      v2.setValue(vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);
                      out.addTriangle(v0, v1, v2);
                    }
                  }

                  Ammo$1.destroy(v0);
                  Ammo$1.destroy(v1);
                  Ammo$1.destroy(v2);
                }
              }

              return out;
            }

            var ERigidBodyType;

            (function (ERigidBodyType) {
              ERigidBodyType[ERigidBodyType["DYNAMIC"] = 1] = "DYNAMIC";
              ERigidBodyType[ERigidBodyType["STATIC"] = 2] = "STATIC";
              ERigidBodyType[ERigidBodyType["KINEMATIC"] = 4] = "KINEMATIC";
            })(ERigidBodyType || (ERigidBodyType = exports('ERigidBodyType', {})));

            Enum(ERigidBodyType);
            var EAxisDirection;

            (function (EAxisDirection) {
              EAxisDirection[EAxisDirection["X_AXIS"] = 0] = "X_AXIS";
              EAxisDirection[EAxisDirection["Y_AXIS"] = 1] = "Y_AXIS";
              EAxisDirection[EAxisDirection["Z_AXIS"] = 2] = "Z_AXIS";
            })(EAxisDirection || (EAxisDirection = exports('EAxisDirection', {})));

            Enum(EAxisDirection);
            var ESimplexType;

            (function (ESimplexType) {
              ESimplexType[ESimplexType["VERTEX"] = 1] = "VERTEX";
              ESimplexType[ESimplexType["LINE"] = 2] = "LINE";
              ESimplexType[ESimplexType["TRIANGLE"] = 3] = "TRIANGLE";
              ESimplexType[ESimplexType["TETRAHEDRON"] = 4] = "TETRAHEDRON";
            })(ESimplexType || (ESimplexType = {}));

            Enum(ESimplexType);
            var EColliderType;

            (function (EColliderType) {
              EColliderType[EColliderType["BOX"] = 0] = "BOX";
              EColliderType[EColliderType["SPHERE"] = 1] = "SPHERE";
              EColliderType[EColliderType["CAPSULE"] = 2] = "CAPSULE";
              EColliderType[EColliderType["CYLINDER"] = 3] = "CYLINDER";
              EColliderType[EColliderType["CONE"] = 4] = "CONE";
              EColliderType[EColliderType["MESH"] = 5] = "MESH";
              EColliderType[EColliderType["PLANE"] = 6] = "PLANE";
              EColliderType[EColliderType["SIMPLEX"] = 7] = "SIMPLEX";
              EColliderType[EColliderType["TERRAIN"] = 8] = "TERRAIN";
            })(EColliderType || (EColliderType = {}));

            Enum(EColliderType);
            var EConstraintType;

            (function (EConstraintType) {
              EConstraintType[EConstraintType["POINT_TO_POINT"] = 0] = "POINT_TO_POINT";
              EConstraintType[EConstraintType["HINGE"] = 1] = "HINGE";
              EConstraintType[EConstraintType["CONE_TWIST"] = 2] = "CONE_TWIST";
            })(EConstraintType || (EConstraintType = {}));

            Enum(EConstraintType);
            var PhysicsGroup;

            (function (PhysicsGroup) {
              PhysicsGroup[PhysicsGroup["DEFAULT"] = 1] = "DEFAULT";
            })(PhysicsGroup || (PhysicsGroup = {}));

            Enum(PhysicsGroup);

            var FUNC = function FUNC() {
              return 0;
            };

            var ENTIRE_WORLD = {
              impl: null,
              setGravity: FUNC,
              setAllowSleep: FUNC,
              setDefaultMaterial: FUNC,
              step: FUNC,
              syncAfterEvents: FUNC,
              syncSceneToPhysics: FUNC,
              raycast: FUNC,
              raycastClosest: FUNC,
              emitEvents: FUNC,
              destroy: FUNC
            };
            var ECheckType;

            (function (ECheckType) {
              ECheckType[ECheckType["World"] = 0] = "World";
              ECheckType[ECheckType["RigidBody"] = 1] = "RigidBody";
              ECheckType[ECheckType["BoxCollider"] = 2] = "BoxCollider";
              ECheckType[ECheckType["SphereCollider"] = 3] = "SphereCollider";
              ECheckType[ECheckType["CapsuleCollider"] = 4] = "CapsuleCollider";
              ECheckType[ECheckType["MeshCollider"] = 5] = "MeshCollider";
              ECheckType[ECheckType["CylinderCollider"] = 6] = "CylinderCollider";
              ECheckType[ECheckType["ConeCollider"] = 7] = "ConeCollider";
              ECheckType[ECheckType["TerrainCollider"] = 8] = "TerrainCollider";
              ECheckType[ECheckType["SimplexCollider"] = 9] = "SimplexCollider";
              ECheckType[ECheckType["PlaneCollider"] = 10] = "PlaneCollider";
              ECheckType[ECheckType["PointToPointConstraint"] = 11] = "PointToPointConstraint";
              ECheckType[ECheckType["HingeConstraint"] = 12] = "HingeConstraint";
              ECheckType[ECheckType["ConeTwistConstraint"] = 13] = "ConeTwistConstraint";
            })(ECheckType || (ECheckType = {}));

            function check(obj, type) {
              if ( !legacyCC.GAME_VIEW && obj == null) {
                if (selector.id) {
                  warn(selector.id + " physics does not support " + ECheckType[type]);
                } else {
                  errorID(9600);
                }

                return true;
              }

              return false;
            }

            function createPhysicsWorld() {
              if (check(selector.wrapper.PhysicsWorld, ECheckType.World)) {
                return ENTIRE_WORLD;
              }

              return new selector.wrapper.PhysicsWorld();
            }
            var ENTIRE_RIGID_BODY = {
              impl: null,
              rigidBody: null,
              isAwake: false,
              isSleepy: false,
              isSleeping: false,
              initialize: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setType: FUNC,
              setMass: FUNC,
              setLinearDamping: FUNC,
              setAngularDamping: FUNC,
              useGravity: FUNC,
              setLinearFactor: FUNC,
              setAngularFactor: FUNC,
              setAllowSleep: FUNC,
              wakeUp: FUNC,
              sleep: FUNC,
              clearState: FUNC,
              clearForces: FUNC,
              clearVelocity: FUNC,
              setSleepThreshold: FUNC,
              getSleepThreshold: FUNC,
              getLinearVelocity: FUNC,
              setLinearVelocity: FUNC,
              getAngularVelocity: FUNC,
              setAngularVelocity: FUNC,
              applyForce: FUNC,
              applyLocalForce: FUNC,
              applyImpulse: FUNC,
              applyLocalImpulse: FUNC,
              applyTorque: FUNC,
              applyLocalTorque: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC
            };
            function createRigidBody() {
              if (check(selector.wrapper.RigidBody, ECheckType.RigidBody)) {
                return ENTIRE_RIGID_BODY;
              }

              return new selector.wrapper.RigidBody();
            }
            var CREATE_COLLIDER_PROXY = {
              INITED: false
            };
            var ENTIRE_SHAPE = {
              impl: null,
              collider: null,
              attachedRigidBody: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setGroup: FUNC,
              getGroup: FUNC,
              addGroup: FUNC,
              removeGroup: FUNC,
              setMask: FUNC,
              getMask: FUNC,
              addMask: FUNC,
              removeMask: FUNC,
              setMaterial: FUNC,
              setAsTrigger: FUNC,
              setCenter: FUNC,
              getAABB: FUNC,
              getBoundingSphere: FUNC,
              setSize: FUNC,
              setRadius: FUNC,
              setCylinderHeight: FUNC,
              setDirection: FUNC,
              setHeight: FUNC,
              setShapeType: FUNC,
              setVertices: FUNC,
              setMesh: FUNC,
              setTerrain: FUNC,
              setNormal: FUNC,
              setConstant: FUNC,
              updateEventListener: FUNC
            };
            function createShape(type) {
              initColliderProxy();
              return CREATE_COLLIDER_PROXY[type]();
            }

            function initColliderProxy() {
              if (CREATE_COLLIDER_PROXY.INITED) return;
              CREATE_COLLIDER_PROXY.INITED = true;

              CREATE_COLLIDER_PROXY[EColliderType.BOX] = function createBoxShape() {
                if (check(selector.wrapper.BoxShape, ECheckType.BoxCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.BoxShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SPHERE] = function createSphereShape() {
                if (check(selector.wrapper.SphereShape, ECheckType.SphereCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SphereShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CAPSULE] = function createCapsuleShape() {
                if (check(selector.wrapper.CapsuleShape, ECheckType.CapsuleCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CapsuleShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CYLINDER] = function createCylinderShape() {
                if (check(selector.wrapper.CylinderShape, ECheckType.CylinderCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.CylinderShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.CONE] = function createConeShape() {
                if (check(selector.wrapper.ConeShape, ECheckType.ConeCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.ConeShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.MESH] = function createTrimeshShape() {
                if (check(selector.wrapper.TrimeshShape, ECheckType.MeshCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TrimeshShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.TERRAIN] = function createTerrainShape() {
                if (check(selector.wrapper.TerrainShape, ECheckType.TerrainCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.TerrainShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.SIMPLEX] = function createSimplexShape() {
                if (check(selector.wrapper.SimplexShape, ECheckType.SimplexCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.SimplexShape();
              };

              CREATE_COLLIDER_PROXY[EColliderType.PLANE] = function createPlaneShape() {
                if (check(selector.wrapper.PlaneShape, ECheckType.PlaneCollider)) {
                  return ENTIRE_SHAPE;
                }

                return new selector.wrapper.PlaneShape();
              };
            }

            var CREATE_CONSTRAINT_PROXY = {
              INITED: false
            };
            var ENTIRE_CONSTRAINT = {
              impl: null,
              initialize: FUNC,
              onLoad: FUNC,
              onEnable: FUNC,
              onDisable: FUNC,
              onDestroy: FUNC,
              setEnableCollision: FUNC,
              setConnectedBody: FUNC,
              setPivotA: FUNC,
              setPivotB: FUNC,
              setAxis: FUNC
            };
            function createConstraint(type) {
              initConstraintProxy();
              return CREATE_CONSTRAINT_PROXY[type]();
            }

            function initConstraintProxy() {
              if (CREATE_CONSTRAINT_PROXY.INITED) return;
              CREATE_CONSTRAINT_PROXY.INITED = true;

              CREATE_CONSTRAINT_PROXY[EConstraintType.POINT_TO_POINT] = function createPointToPointConstraint() {
                if (check(selector.wrapper.PointToPointConstraint, ECheckType.PointToPointConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.PointToPointConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.HINGE] = function createHingeConstraint() {
                if (check(selector.wrapper.HingeConstraint, ECheckType.HingeConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.HingeConstraint();
              };

              CREATE_CONSTRAINT_PROXY[EConstraintType.CONE_TWIST] = function createConeTwistConstraint() {
                if (check(selector.wrapper.ConeTwistConstraint, ECheckType.ConeTwistConstraint)) {
                  return ENTIRE_CONSTRAINT;
                }

                return new selector.wrapper.ConeTwistConstraint();
              };
            }

            var _dec$N, _class$N, _class2$D, _descriptor$C, _descriptor2$y, _descriptor3$t, _descriptor4$o, _class3$i, _temp$G;
            var PhysicsMaterial = function (v) { return exports({ PhysicsMaterial: v, PhysicMaterial: v }), v; }((_dec$N = ccclass('cc.PhysicsMaterial'), _dec$N(_class$N = (_class2$D = (_temp$G = _class3$i = function (_Asset) {
              _inheritsLoose(PhysicsMaterial, _Asset);

              _createClass(PhysicsMaterial, [{
                key: "friction",
                get: function get() {
                  return this._friction;
                },
                set: function set(value) {
                  if (!equals$1(this._friction, value)) {
                    this._friction = value;
                    this.emit('physics_material_update');
                  }
                }
              }, {
                key: "rollingFriction",
                get: function get() {
                  return this._rollingFriction;
                },
                set: function set(value) {
                  if (!equals$1(this._rollingFriction, value)) {
                    this._rollingFriction = value;
                    this.emit('physics_material_update');
                  }
                }
              }, {
                key: "spinningFriction",
                get: function get() {
                  return this._spinningFriction;
                },
                set: function set(value) {
                  if (!equals$1(this._spinningFriction, value)) {
                    this._spinningFriction = value;
                    this.emit('physics_material_update');
                  }
                }
              }, {
                key: "restitution",
                get: function get() {
                  return this._restitution;
                },
                set: function set(value) {
                  if (!equals$1(this._restitution, value)) {
                    this._restitution = value;
                    this.emit('physics_material_update');
                  }
                }
              }]);

              function PhysicsMaterial() {
                var _this;

                _this = _Asset.call(this) || this;

                _initializerDefineProperty(_this, "_friction", _descriptor$C, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_rollingFriction", _descriptor2$y, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_spinningFriction", _descriptor3$t, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_restitution", _descriptor4$o, _assertThisInitialized(_this));

                PhysicsMaterial.allMaterials.push(_assertThisInitialized(_this));

                if (!_this._uuid) {
                  _this._uuid = "pm_" + PhysicsMaterial._idCounter++;
                }

                return _this;
              }

              var _proto = PhysicsMaterial.prototype;

              _proto.clone = function clone() {
                var c = new PhysicsMaterial();
                c._friction = this._friction;
                c._restitution = this._restitution;
                c._rollingFriction = this._rollingFriction;
                c._spinningFriction = this._spinningFriction;
                return c;
              };

              _proto.destroy = function destroy() {
                if (_Asset.prototype.destroy.call(this)) {
                  var idx = PhysicsMaterial.allMaterials.indexOf(this);

                  if (idx >= 0) {
                    PhysicsMaterial.allMaterials.splice(idx, 1);
                  }

                  return true;
                }

                return false;
              };

              return PhysicsMaterial;
            }(Asset), _class3$i.allMaterials = [], _class3$i._idCounter = 0, _temp$G), (_applyDecoratedDescriptor(_class2$D.prototype, "friction", [editable], Object.getOwnPropertyDescriptor(_class2$D.prototype, "friction"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "rollingFriction", [editable], Object.getOwnPropertyDescriptor(_class2$D.prototype, "rollingFriction"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "spinningFriction", [editable], Object.getOwnPropertyDescriptor(_class2$D.prototype, "spinningFriction"), _class2$D.prototype), _applyDecoratedDescriptor(_class2$D.prototype, "restitution", [editable], Object.getOwnPropertyDescriptor(_class2$D.prototype, "restitution"), _class2$D.prototype), _descriptor$C = _applyDecoratedDescriptor(_class2$D.prototype, "_friction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.6;
              }
            }), _descriptor2$y = _applyDecoratedDescriptor(_class2$D.prototype, "_rollingFriction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor3$t = _applyDecoratedDescriptor(_class2$D.prototype, "_spinningFriction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor4$o = _applyDecoratedDescriptor(_class2$D.prototype, "_restitution", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.0;
              }
            })), _class2$D)) || _class$N));

            var PhysicsRayResult = exports('PhysicsRayResult', function () {
              function PhysicsRayResult() {
                this._hitPoint = new Vec3();
                this._hitNormal = new Vec3();
                this._distance = 0;
                this._collider = null;
              }

              var _proto = PhysicsRayResult.prototype;

              _proto._assign = function _assign(hitPoint, distance, collider, hitNormal) {
                Vec3.copy(this._hitPoint, hitPoint);
                Vec3.copy(this._hitNormal, hitNormal);
                this._distance = distance;
                this._collider = collider;
              };

              _proto.clone = function clone() {
                var c = new PhysicsRayResult();
                Vec3.copy(c._hitPoint, this._hitPoint);
                Vec3.copy(c._hitNormal, this._hitNormal);
                c._distance = this._distance;
                c._collider = this._collider;
                return c;
              };

              _createClass(PhysicsRayResult, [{
                key: "hitPoint",
                get: function get() {
                  return this._hitPoint;
                }
              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "hitNormal",
                get: function get() {
                  return this._hitNormal;
                }
              }]);

              return PhysicsRayResult;
            }());

            var CollisionMatrix = function CollisionMatrix() {
              for (var i = 0; i < 32; i++) {
                var key = 1 << i;
                this["" + key] = 0;
              }

              this['1'] = PhysicsGroup.DEFAULT;
            };

            legacyCC.internal.PhysicsGroup = PhysicsGroup;
            var PhysicsSystem = exports('PhysicsSystem', function (_System) {
              _inheritsLoose(PhysicsSystem, _System);

              _createClass(PhysicsSystem, [{
                key: "enable",
                get: function get() {
                  return this._enable;
                },
                set: function set(value) {
                  this._enable = value;
                }
              }, {
                key: "allowSleep",
                get: function get() {
                  return this._allowSleep;
                },
                set: function set(v) {
                  this._allowSleep = v;

                  {
                    this.physicsWorld.setAllowSleep(v);
                  }
                }
              }, {
                key: "maxSubSteps",
                get: function get() {
                  return this._maxSubSteps;
                },
                set: function set(value) {
                  this._maxSubSteps = value;
                }
              }, {
                key: "fixedTimeStep",
                get: function get() {
                  return this._fixedTimeStep;
                },
                set: function set(value) {
                  this._fixedTimeStep = value;
                }
              }, {
                key: "gravity",
                get: function get() {
                  return this._gravity;
                },
                set: function set(gravity) {
                  this._gravity.set(gravity);

                  {
                    this.physicsWorld.setGravity(gravity);
                  }
                }
              }, {
                key: "sleepThreshold",
                get: function get() {
                  return this._sleepThreshold;
                },
                set: function set(v) {
                  this._sleepThreshold = v;
                }
              }, {
                key: "autoSimulation",
                get: function get() {
                  return this._autoSimulation;
                },
                set: function set(value) {
                  this._autoSimulation = value;
                }
              }, {
                key: "defaultMaterial",
                get: function get() {
                  return this._material;
                }
              }], [{
                key: "PHYSICS_NONE",
                get: function get() {
                  return !selector.id;
                }
              }, {
                key: "PHYSICS_BUILTIN",
                get: function get() {
                  return selector.id === 'builtin';
                }
              }, {
                key: "PHYSICS_CANNON",
                get: function get() {
                  return selector.id === 'cannon.js';
                }
              }, {
                key: "PHYSICS_AMMO",
                get: function get() {
                  return selector.id === 'ammo.js';
                }
              }, {
                key: "PHYSICS_PHYSX",
                get: function get() {
                  return selector.id === 'physx';
                }
              }, {
                key: "PhysicsGroup",
                get: function get() {
                  return PhysicsGroup;
                }
              }, {
                key: "instance",
                get: function get() {
                  return PhysicsSystem._instance;
                }
              }]);

              function PhysicsSystem() {
                var _this;

                _this = _System.call(this) || this;
                _this.physicsWorld = void 0;
                _this.raycastClosestResult = new PhysicsRayResult();
                _this.raycastResults = [];
                _this.collisionMatrix = new CollisionMatrix();
                _this.useNodeChains = void 0;
                _this._enable = true;
                _this._allowSleep = true;
                _this._maxSubSteps = 1;
                _this._subStepCount = 0;
                _this._fixedTimeStep = 1.0 / 60.0;
                _this._autoSimulation = true;
                _this._accumulator = 0;
                _this._sleepThreshold = 0.1;
                _this._gravity = new Vec3(0, -10, 0);
                _this._material = new PhysicsMaterial();
                _this.raycastOptions = {
                  group: -1,
                  mask: -1,
                  queryTrigger: true,
                  maxDistance: 10000000
                };
                _this.raycastResultPool = new RecyclePool(function () {
                  return new PhysicsRayResult();
                }, 1);
                var config = game.config ? game.config.physics : null;

                if (config && config.physicsEngine) {
                  Vec3.copy(_this._gravity, config.gravity);
                  _this._allowSleep = config.allowSleep;
                  _this._fixedTimeStep = config.fixedTimeStep;
                  _this._maxSubSteps = config.maxSubSteps;
                  _this._sleepThreshold = config.sleepThreshold;
                  _this.autoSimulation = config.autoSimulation;
                  _this.useNodeChains = config.useNodeChains;

                  if (config.defaultMaterial) {
                    _this._material.friction = config.defaultMaterial.friction;
                    _this._material.rollingFriction = config.defaultMaterial.rollingFriction;
                    _this._material.spinningFriction = config.defaultMaterial.spinningFriction;
                    _this._material.restitution = config.defaultMaterial.restitution;
                  }

                  if (config.collisionMatrix) {
                    for (var i in config.collisionMatrix) {
                      var key = 1 << parseInt(i);
                      _this.collisionMatrix["" + key] = config.collisionMatrix[i];
                    }
                  }
                } else {
                  _this.useNodeChains = false;
                }

                _this._material.on('physics_material_update', _this._updateMaterial, _assertThisInitialized(_this));

                _this.physicsWorld = createPhysicsWorld();

                _this.physicsWorld.setGravity(_this._gravity);

                _this.physicsWorld.setAllowSleep(_this._allowSleep);

                _this.physicsWorld.setDefaultMaterial(_this._material);

                return _this;
              }

              var _proto = PhysicsSystem.prototype;

              _proto.postUpdate = function postUpdate(deltaTime) {

                if (!this._enable) {
                  this.physicsWorld.syncSceneToPhysics();
                  return;
                }

                if (this._autoSimulation) {
                  this._subStepCount = 0;
                  this._accumulator += deltaTime;
                  director.emit(Director.EVENT_BEFORE_PHYSICS);

          
                  while (this._subStepCount < this._maxSubSteps) {
                    if (this._accumulator > this._fixedTimeStep) {

                        let start = new Date().getTime();
                      
                        this.physicsWorld.syncSceneToPhysics();
                        this.physicsWorld.step(this._fixedTimeStep);
                        this._accumulator -= this._fixedTimeStep;
                        this._subStepCount++;
                        this.physicsWorld.emitEvents();
                        this.physicsWorld.syncAfterEvents();

                        let end = new Date().getTime();
                        let d= end - start;
                        window.global_var.push(d);

                    } else {
                      this.physicsWorld.syncSceneToPhysics();
                      break;
                    }
                  }

                  director.emit(Director.EVENT_AFTER_PHYSICS);
                }
              };

              _proto.resetAccumulator = function resetAccumulator(time) {
                if (time === void 0) {
                  time = 0;
                }

                this._accumulator = time;
              };

              _proto.step = function step(fixedTimeStep, deltaTime, maxSubSteps) {
                console.log(2222);
                this.physicsWorld.step(fixedTimeStep, deltaTime, maxSubSteps);
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                this.physicsWorld.syncSceneToPhysics();
              };

              _proto.emitEvents = function emitEvents() {
                this.physicsWorld.emitEvents();
              };

              _proto.raycast = function raycast(worldRay, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                this.raycastResultPool.reset();
                this.raycastResults.length = 0;
                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycast(worldRay, this.raycastOptions, this.raycastResultPool, this.raycastResults);
              };

              _proto.raycastClosest = function raycastClosest(worldRay, mask, maxDistance, queryTrigger) {
                if (mask === void 0) {
                  mask = 0xffffffff;
                }

                if (maxDistance === void 0) {
                  maxDistance = 10000000;
                }

                if (queryTrigger === void 0) {
                  queryTrigger = true;
                }

                this.raycastOptions.mask = mask >>> 0;
                this.raycastOptions.maxDistance = maxDistance;
                this.raycastOptions.queryTrigger = queryTrigger;
                return this.physicsWorld.raycastClosest(worldRay, this.raycastOptions, this.raycastClosestResult);
              };

              _proto._updateMaterial = function _updateMaterial() {
                this.physicsWorld.setDefaultMaterial(this._material);
              };

              return PhysicsSystem;
            }(System));
            PhysicsSystem.ID = 'PHYSICS';
            PhysicsSystem._instance = void 0;
            director.once(Director.EVENT_INIT, function () {
              initPhysicsSystem();
            });

            function initPhysicsSystem() {
              {
                var physics = game.config.physics;

                if (physics) {
                  var cg = physics.collisionGroups;

                  if (cg instanceof Array) {
                    cg.forEach(function (v) {
                      PhysicsGroup[v.name] = 1 << v.index;
                    });
                    Enum.update(PhysicsGroup);
                  }
                }

                var oldIns = PhysicsSystem.instance;

                if (oldIns) {
                  director.unregisterSystem(oldIns);
                  oldIns.physicsWorld.destroy();
                }

                var sys = new legacyCC.PhysicsSystem();
                legacyCC.PhysicsSystem._instance = sys;
                director.registerSystem(PhysicsSystem.ID, sys, 0);
              }
            }

            var _dec$O, _dec2$G, _dec3$E, _dec4$B, _dec5$y, _dec6$w, _dec7$w, _dec8$r, _dec9$p, _dec10$n, _dec11$m, _dec12$k, _dec13$i, _dec14$e, _dec15$d, _dec16$c, _dec17$b, _dec18$9, _dec19$8, _dec20$7, _dec21$7, _dec22$7, _dec23$7, _dec24$7, _dec25$7, _dec26$6, _dec27$5, _dec28$5, _dec29$5, _dec30$5, _dec31$5, _class$O, _class2$E, _descriptor$D, _descriptor2$z, _descriptor3$u, _descriptor4$p, _descriptor5$j, _descriptor6$d, _descriptor7$c, _descriptor8$c, _descriptor9$b, _class3$j, _temp$H;
            var RigidBody = function (v) { return exports({ RigidBody: v, RigidBodyComponent: v }), v; }((_dec$O = ccclass('cc.RigidBody'), _dec2$G = help(), _dec3$E = menu(), _dec4$B = executionOrder(-1), _dec5$y = type(PhysicsSystem.PhysicsGroup), _dec6$w = displayOrder(), _dec7$w = tooltip(), _dec8$r = type(ERigidBodyType), _dec9$p = displayOrder(), _dec10$n = tooltip(), _dec11$m = visible(), _dec12$k = displayOrder(), _dec13$i = tooltip(), _dec14$e = visible(), _dec15$d = displayOrder(), _dec16$c = tooltip(), _dec17$b = visible(), _dec18$9 = displayOrder(), _dec19$8 = tooltip(), _dec20$7 = visible(), _dec21$7 = displayOrder(), _dec22$7 = tooltip(), _dec23$7 = visible(), _dec24$7 = displayOrder(), _dec25$7 = tooltip(), _dec26$6 = visible(), _dec27$5 = displayOrder(), _dec28$5 = tooltip(), _dec29$5 = visible(), _dec30$5 = displayOrder(), _dec31$5 = tooltip(), _dec$O(_class$O = _dec2$G(_class$O = _dec3$E(_class$O = executeInEditMode(_class$O = disallowMultiple(_class$O = _dec4$B(_class$O = (_class2$E = (_temp$H = _class3$j = function (_Component) {
              _inheritsLoose(RigidBody, _Component);

              function RigidBody() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._body = null;

                _initializerDefineProperty(_this, "_group", _descriptor$D, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_type", _descriptor2$z, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_mass", _descriptor3$u, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_allowSleep", _descriptor4$p, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_linearDamping", _descriptor5$j, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_angularDamping", _descriptor6$d, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_useGravity", _descriptor7$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_linearFactor", _descriptor8$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_angularFactor", _descriptor9$b, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = RigidBody.prototype;

              _proto.onLoad = function onLoad() {
                {
                  this._body = createRigidBody();

                  this._body.initialize(this);
                }
              };

              _proto.onEnable = function onEnable() {
                if (this._body) {
                  this._body.onEnable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._body) {
                  this._body.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._body) {
                  this._body.onDestroy();
                }
              };

              _proto.applyForce = function applyForce(force, relativePoint) {
                if (this._assertOnLoadCalled) {
                  this._body.applyForce(force, relativePoint);
                }
              };

              _proto.applyLocalForce = function applyLocalForce(force, localPoint) {
                if (this._assertOnLoadCalled) {
                  this._body.applyLocalForce(force, localPoint);
                }
              };

              _proto.applyImpulse = function applyImpulse(impulse, relativePoint) {
                if (this._assertOnLoadCalled) {
                  this._body.applyImpulse(impulse, relativePoint);
                }
              };

              _proto.applyLocalImpulse = function applyLocalImpulse(impulse, localPoint) {
                if (this._assertOnLoadCalled) {
                  this._body.applyLocalImpulse(impulse, localPoint);
                }
              };

              _proto.applyTorque = function applyTorque(torque) {
                if (this._assertOnLoadCalled) {
                  this._body.applyTorque(torque);
                }
              };

              _proto.applyLocalTorque = function applyLocalTorque(torque) {
                if (this._assertOnLoadCalled) {
                  this._body.applyLocalTorque(torque);
                }
              };

              _proto.wakeUp = function wakeUp() {
                if (this._assertOnLoadCalled) {
                  this._body.wakeUp();
                }
              };

              _proto.sleep = function sleep() {
                if (this._assertOnLoadCalled) {
                  this._body.sleep();
                }
              };

              _proto.clearState = function clearState() {
                if (this._assertOnLoadCalled) {
                  this._body.clearState();
                }
              };

              _proto.clearForces = function clearForces() {
                if (this._assertOnLoadCalled) {
                  this._body.clearForces();
                }
              };

              _proto.clearVelocity = function clearVelocity() {
                if (this._assertOnLoadCalled) {
                  this._body.clearVelocity();
                }
              };

              _proto.getLinearVelocity = function getLinearVelocity(out) {
                if (this._assertOnLoadCalled) {
                  this._body.getLinearVelocity(out);
                }
              };

              _proto.setLinearVelocity = function setLinearVelocity(value) {
                if (this._assertOnLoadCalled) {
                  this._body.setLinearVelocity(value);
                }
              };

              _proto.getAngularVelocity = function getAngularVelocity(out) {
                if (this._assertOnLoadCalled) {
                  this._body.getAngularVelocity(out);
                }
              };

              _proto.setAngularVelocity = function setAngularVelocity(value) {
                if (this._assertOnLoadCalled) {
                  this._body.setAngularVelocity(value);
                }
              };

              _proto.getGroup = function getGroup() {
                if (this._assertOnLoadCalled) {
                  return this._body.getGroup();
                }

                return 0;
              };

              _proto.setGroup = function setGroup(v) {
                if (this._assertOnLoadCalled) {
                  this.group = v;
                }
              };

              _proto.addGroup = function addGroup(v) {
                if (this._assertOnLoadCalled) {
                  this._body.addGroup(v);
                }
              };

              _proto.removeGroup = function removeGroup(v) {
                if (this._assertOnLoadCalled) {
                  this._body.removeGroup(v);
                }
              };

              _proto.getMask = function getMask() {
                if (this._assertOnLoadCalled) {
                  return this._body.getMask();
                }

                return 0;
              };

              _proto.setMask = function setMask(v) {
                if (this._assertOnLoadCalled) {
                  this._body.setMask(v);
                }
              };

              _proto.addMask = function addMask(v) {
                if (this._assertOnLoadCalled) {
                  this._body.addMask(v);
                }
              };

              _proto.removeMask = function removeMask(v) {
                if (this._assertOnLoadCalled) {
                  this._body.removeMask(v);
                }
              };

              _createClass(RigidBody, [{
                key: "group",
                get: function get() {
                  return this._group;
                },
                set: function set(v) {
                  if (this._group === v) return;
                  this._group = v;

                  if (this._body) {
                    this._body.setGroup(v);
                  }
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(v) {
                  if (this._type === v) return;
                  this._type = v;

                  if (this._body) {
                    this._body.setType(v);
                  }
                }
              }, {
                key: "mass",
                get: function get() {
                  return this._mass;
                },
                set: function set(value) {
                  if (this._mass === value) return;
                  value = value <= 0 ? 0.0001 : value;
                  this._mass = value;

                  if (this._body) {
                    this._body.setMass(value);
                  }
                }
              }, {
                key: "allowSleep",
                get: function get() {
                  return this._allowSleep;
                },
                set: function set(v) {
                  this._allowSleep = v;

                  if (this._body) {
                    this._body.setAllowSleep(v);
                  }
                }
              }, {
                key: "linearDamping",
                get: function get() {
                  return this._linearDamping;
                },
                set: function set(value) {
                  this._linearDamping = value;

                  if (this._body) {
                    this._body.setLinearDamping(value);
                  }
                }
              }, {
                key: "angularDamping",
                get: function get() {
                  return this._angularDamping;
                },
                set: function set(value) {
                  this._angularDamping = value;

                  if (this._body) {
                    this._body.setAngularDamping(value);
                  }
                }
              }, {
                key: "useGravity",
                get: function get() {
                  return this._useGravity;
                },
                set: function set(value) {
                  this._useGravity = value;

                  if (this._body) {
                    this._body.useGravity(value);
                  }
                }
              }, {
                key: "linearFactor",
                get: function get() {
                  return this._linearFactor;
                },
                set: function set(value) {
                  Vec3.copy(this._linearFactor, value);

                  if (this._body) {
                    this._body.setLinearFactor(this._linearFactor);
                  }
                }
              }, {
                key: "angularFactor",
                get: function get() {
                  return this._angularFactor;
                },
                set: function set(value) {
                  Vec3.copy(this._angularFactor, value);

                  if (this._body) {
                    this._body.setAngularFactor(this._angularFactor);
                  }
                }
              }, {
                key: "sleepThreshold",
                get: function get() {
                  if (this._assertOnLoadCalled) {
                    return this._body.getSleepThreshold();
                  }

                  return 0;
                },
                set: function set(v) {
                  if (this._assertOnLoadCalled) {
                    this._body.setSleepThreshold(v);
                  }
                }
              }, {
                key: "isAwake",
                get: function get() {
                  if (this._assertOnLoadCalled) {
                    return this._body.isAwake;
                  }

                  return false;
                }
              }, {
                key: "isSleepy",
                get: function get() {
                  if (this._assertOnLoadCalled) {
                    return this._body.isSleepy;
                  }

                  return false;
                }
              }, {
                key: "isSleeping",
                get: function get() {
                  if (this._assertOnLoadCalled) {
                    return this._body.isSleeping;
                  }

                  return false;
                }
              }, {
                key: "isStatic",
                get: function get() {
                  return this._type === ERigidBodyType.STATIC;
                },
                set: function set(v) {
                  if (v && this.isStatic || !v && !this.isStatic) return;
                  this.type = v ? ERigidBodyType.STATIC : ERigidBodyType.DYNAMIC;
                }
              }, {
                key: "isDynamic",
                get: function get() {
                  return this._type === ERigidBodyType.DYNAMIC;
                },
                set: function set(v) {
                  if (v && this.isDynamic || !v && !this.isDynamic) return;
                  this.type = v ? ERigidBodyType.DYNAMIC : ERigidBodyType.KINEMATIC;
                }
              }, {
                key: "isKinematic",
                get: function get() {
                  return this._type === ERigidBodyType.KINEMATIC;
                },
                set: function set(v) {
                  if (v && this.isKinematic || !v && !this.isKinematic) return;
                  this.type = v ? ERigidBodyType.KINEMATIC : ERigidBodyType.DYNAMIC;
                }
              }, {
                key: "body",
                get: function get() {
                  return this._body;
                }
              }, {
                key: "_assertOnLoadCalled",
                get: function get() {
                  var r = this._isOnLoadCalled === 0;

                  if (r) {
                    error('[Physics]: Please make sure that the node has been added to the scene');
                  }

                  return !r;
                }
              }]);

              return RigidBody;
            }(Component), _class3$j.Type = ERigidBodyType, _temp$H), (_applyDecoratedDescriptor(_class2$E.prototype, "group", [_dec5$y, _dec6$w, _dec7$w], Object.getOwnPropertyDescriptor(_class2$E.prototype, "group"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "type", [_dec8$r, _dec9$p, _dec10$n], Object.getOwnPropertyDescriptor(_class2$E.prototype, "type"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "mass", [_dec11$m, _dec12$k, _dec13$i], Object.getOwnPropertyDescriptor(_class2$E.prototype, "mass"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "allowSleep", [_dec14$e, _dec15$d, _dec16$c], Object.getOwnPropertyDescriptor(_class2$E.prototype, "allowSleep"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "linearDamping", [_dec17$b, _dec18$9, _dec19$8], Object.getOwnPropertyDescriptor(_class2$E.prototype, "linearDamping"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "angularDamping", [_dec20$7, _dec21$7, _dec22$7], Object.getOwnPropertyDescriptor(_class2$E.prototype, "angularDamping"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "useGravity", [_dec23$7, _dec24$7, _dec25$7], Object.getOwnPropertyDescriptor(_class2$E.prototype, "useGravity"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "linearFactor", [_dec26$6, _dec27$5, _dec28$5], Object.getOwnPropertyDescriptor(_class2$E.prototype, "linearFactor"), _class2$E.prototype), _applyDecoratedDescriptor(_class2$E.prototype, "angularFactor", [_dec29$5, _dec30$5, _dec31$5], Object.getOwnPropertyDescriptor(_class2$E.prototype, "angularFactor"), _class2$E.prototype), _descriptor$D = _applyDecoratedDescriptor(_class2$E.prototype, "_group", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return PhysicsSystem.PhysicsGroup.DEFAULT;
              }
            }), _descriptor2$z = _applyDecoratedDescriptor(_class2$E.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ERigidBodyType.DYNAMIC;
              }
            }), _descriptor3$u = _applyDecoratedDescriptor(_class2$E.prototype, "_mass", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor4$p = _applyDecoratedDescriptor(_class2$E.prototype, "_allowSleep", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor5$j = _applyDecoratedDescriptor(_class2$E.prototype, "_linearDamping", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor6$d = _applyDecoratedDescriptor(_class2$E.prototype, "_angularDamping", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.1;
              }
            }), _descriptor7$c = _applyDecoratedDescriptor(_class2$E.prototype, "_useGravity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor8$c = _applyDecoratedDescriptor(_class2$E.prototype, "_linearFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor9$b = _applyDecoratedDescriptor(_class2$E.prototype, "_angularFactor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(1, 1, 1);
              }
            })), _class2$E)) || _class$O) || _class$O) || _class$O) || _class$O) || _class$O) || _class$O));

            (function (_RigidBody) {})(RigidBody || (RigidBody = function (v) { return exports({ RigidBody: v, RigidBodyComponent: v }), v; }({})));

            var _dec$P, _dec2$H, _dec3$F, _dec4$C, _dec5$z, _dec6$x, _dec7$x, _dec8$s, _dec9$q, _dec10$o, _dec11$n, _dec12$l, _dec13$j, _dec14$f, _class$P, _class2$F, _descriptor$E, _descriptor2$A, _descriptor3$v, _class3$k, _temp$I;
            var Collider = function (v) { return exports({ Collider: v, ColliderComponent: v }), v; }((_dec$P = ccclass('cc.Collider'), _dec2$H = type(RigidBody), _dec3$F = displayName(), _dec4$C = displayOrder(), _dec5$z = type(PhysicsMaterial), _dec6$x = displayName(), _dec7$x = displayOrder(), _dec8$s = tooltip(), _dec9$q = displayOrder(), _dec10$o = tooltip(), _dec11$n = type(Vec3), _dec12$l = displayOrder(), _dec13$j = tooltip(), _dec14$f = type(PhysicsMaterial), _dec$P(_class$P = (_class2$F = (_temp$I = _class3$k = function (_Eventify) {
              _inheritsLoose(Collider, _Eventify);

              _createClass(Collider, [{
                key: "attachedRigidBody",
                get: function get() {
                  return findAttachedBody(this.node);
                }
              }, {
                key: "sharedMaterial",
                get: function get() {
                  return this._material;
                },
                set: function set(value) {
                  {
                    this.material = value;
                  }
                }
              }, {
                key: "material",
                get: function get() {
                  if (this._isSharedMaterial && this._material != null) {
                    this._material.off('physics_material_update', this._updateMaterial, this);

                    this._material = this._material.clone();

                    this._material.on('physics_material_update', this._updateMaterial, this);

                    this._isSharedMaterial = false;
                  }

                  return this._material;
                },
                set: function set(value) {
                  if (this._shape) {
                    if (value != null && this._material != null) {
                      if (this._material._uuid !== value._uuid) {
                        this._material.off('physics_material_update', this._updateMaterial, this);

                        value.on('physics_material_update', this._updateMaterial, this);
                        this._isSharedMaterial = false;
                        this._material = value;
                      }
                    } else if (value != null && this._material == null) {
                      value.on('physics_material_update', this._updateMaterial, this);
                      this._material = value;
                    } else if (value == null && this._material != null) {
                      this._material.off('physics_material_update', this._updateMaterial, this);

                      this._material = value;
                    }

                    this._updateMaterial();
                  }
                }
              }, {
                key: "isTrigger",
                get: function get() {
                  return this._isTrigger;
                },
                set: function set(value) {
                  this._isTrigger = value;

                  if (this._shape) {
                    this._shape.setAsTrigger(this._isTrigger);
                  }
                }
              }, {
                key: "center",
                get: function get() {
                  return this._center;
                },
                set: function set(value) {
                  Vec3.copy(this._center, value);

                  if (this._shape) {
                    this._shape.setCenter(this._center);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }, {
                key: "worldBounds",
                get: function get() {
                  if (this._aabb == null) this._aabb = new AABB();
                  if (this._shape) this._shape.getAABB(this._aabb);
                  return this._aabb;
                }
              }, {
                key: "boundingSphere",
                get: function get() {
                  if (this._boundingSphere == null) this._boundingSphere = new Sphere();
                  if (this._shape) this._shape.getBoundingSphere(this._boundingSphere);
                  return this._boundingSphere;
                }
              }, {
                key: "needTriggerEvent",
                get: function get() {
                  return this._needTriggerEvent;
                }
              }, {
                key: "needCollisionEvent",
                get: function get() {
                  return this._needCollisionEvent;
                }
              }, {
                key: "_assertOnLoadCalled",
                get: function get() {
                  var r = this._isOnLoadCalled === 0;

                  if (r) {
                    error('[Physics]: Please make sure that the node has been added to the scene');
                  }

                  return !r;
                }
              }]);

              function Collider(type) {
                var _this;

                _this = _Eventify.call(this) || this;
                _this.TYPE = void 0;
                _this._shape = null;
                _this._aabb = null;
                _this._boundingSphere = null;
                _this._isSharedMaterial = true;
                _this._needTriggerEvent = false;
                _this._needCollisionEvent = false;

                _initializerDefineProperty(_this, "_material", _descriptor$E, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_isTrigger", _descriptor2$A, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_center", _descriptor3$v, _assertThisInitialized(_this));

                _this.TYPE = type;
                return _this;
              }

              var _proto = Collider.prototype;

              _proto.on = function on(type, callback, target, once) {
                var ret = _Eventify.prototype.on.call(this, type, callback, target, once);

                this._updateNeedEvent(type);

                return ret;
              };

              _proto.off = function off(type, callback, target) {
                _Eventify.prototype.off.call(this, type, callback, target);

                this._updateNeedEvent();
              };

              _proto.once = function once(type, callback, target) {
                var ret = _Eventify.prototype.once.call(this, type, callback, target);

                this._updateNeedEvent(type);

                return ret;
              };

              _proto.removeAll = function removeAll(typeOrTarget) {
                _Eventify.prototype.removeAll.call(this, typeOrTarget);

                this._updateNeedEvent();
              };

              _proto.getGroup = function getGroup() {
                if (this._assertOnLoadCalled) {
                  return this._shape.getGroup();
                }

                return 0;
              };

              _proto.setGroup = function setGroup(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.setGroup(v);
                }
              };

              _proto.addGroup = function addGroup(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.addGroup(v);
                }
              };

              _proto.removeGroup = function removeGroup(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.removeGroup(v);
                }
              };

              _proto.getMask = function getMask() {
                if (this._assertOnLoadCalled) {
                  return this._shape.getMask();
                }

                return 0;
              };

              _proto.setMask = function setMask(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.setMask(v);
                }
              };

              _proto.addMask = function addMask(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.addMask(v);
                }
              };

              _proto.removeMask = function removeMask(v) {
                if (this._assertOnLoadCalled) {
                  this._shape.removeMask(v);
                }
              };

              _proto.onLoad = function onLoad() {
                {
                  this._shape = createShape(this.TYPE);
                  this.sharedMaterial = this._material == null ? PhysicsSystem.instance.defaultMaterial : this._material;

                  this._shape.initialize(this);

                  this._shape.onLoad();
                }
              };

              _proto.onEnable = function onEnable() {
                if (this._shape) {
                  this._shape.onEnable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._shape) {
                  this._shape.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._shape) {
                  if (this._material) {
                    this._material.off('physics_material_update', this._updateMaterial, this);
                  }

                  this._shape.onDestroy();
                }

                if (this._boundingSphere) this._boundingSphere.destroy();
              };

              _proto._updateMaterial = function _updateMaterial() {
                if (this._shape) {
                  this._shape.setMaterial(this._material);
                }
              };

              _proto._updateNeedEvent = function _updateNeedEvent(type) {
                if (this.isValid) {
                  if (type !== undefined) {
                    if (type === 'onCollisionEnter' || type === 'onCollisionStay' || type === 'onCollisionExit') {
                      this._needCollisionEvent = true;
                    }

                    if (type === 'onTriggerEnter' || type === 'onTriggerStay' || type === 'onTriggerExit') {
                      this._needTriggerEvent = true;
                    }
                  } else {
                    if (!(this.hasEventListener('onTriggerEnter') || this.hasEventListener('onTriggerStay') || this.hasEventListener('onTriggerExit'))) {
                      this._needTriggerEvent = false;
                    }

                    if (!(this.hasEventListener('onCollisionEnter') || this.hasEventListener('onCollisionStay') || this.hasEventListener('onCollisionExit'))) {
                      this._needCollisionEvent = false;
                    }
                  }

                  if (this._shape) this._shape.updateEventListener();
                }
              };

              return Collider;
            }(Eventify(Component)), _class3$k.Type = EColliderType, _class3$k.Axis = EAxisDirection, _temp$I), (_applyDecoratedDescriptor(_class2$F.prototype, "attachedRigidBody", [_dec2$H, readOnly, _dec3$F, _dec4$C], Object.getOwnPropertyDescriptor(_class2$F.prototype, "attachedRigidBody"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "sharedMaterial", [_dec5$z, _dec6$x, _dec7$x, _dec8$s], Object.getOwnPropertyDescriptor(_class2$F.prototype, "sharedMaterial"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "isTrigger", [_dec9$q, _dec10$o], Object.getOwnPropertyDescriptor(_class2$F.prototype, "isTrigger"), _class2$F.prototype), _applyDecoratedDescriptor(_class2$F.prototype, "center", [_dec11$n, _dec12$l, _dec13$j], Object.getOwnPropertyDescriptor(_class2$F.prototype, "center"), _class2$F.prototype), _descriptor$E = _applyDecoratedDescriptor(_class2$F.prototype, "_material", [_dec14$f], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$A = _applyDecoratedDescriptor(_class2$F.prototype, "_isTrigger", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor3$v = _applyDecoratedDescriptor(_class2$F.prototype, "_center", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            })), _class2$F)) || _class$P));

            (function (_Collider) {})(Collider || (Collider = function (v) { return exports({ Collider: v, ColliderComponent: v }), v; }({})));

            function findAttachedBody(node) {
              var rb = node.getComponent(RigidBody);

              if (rb && rb.isValid) {
                return rb;
              }

              return null;
            }

            var _dec$Q, _dec2$I, _dec3$G, _dec4$D, _dec5$A, _class$Q, _class2$G, _descriptor$F, _temp$J;
            var BoxCollider = function (v) { return exports({ BoxCollider: v, BoxColliderComponent: v }), v; }((_dec$Q = ccclass('cc.BoxCollider'), _dec2$I = help(), _dec3$G = menu(), _dec4$D = type(Vec3), _dec5$A = tooltip(), _dec$Q(_class$Q = _dec2$I(_class$Q = _dec3$G(_class$Q = executeInEditMode(_class$Q = (_class2$G = (_temp$J = function (_Collider) {
              _inheritsLoose(BoxCollider, _Collider);

              _createClass(BoxCollider, [{
                key: "size",
                get: function get() {
                  return this._size;
                },
                set: function set(value) {
                  Vec3.copy(this._size, value);

                  if (this._shape) {
                    this.shape.setSize(this._size);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function BoxCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.BOX) || this;

                _initializerDefineProperty(_this, "_size", _descriptor$F, _assertThisInitialized(_this));

                return _this;
              }

              return BoxCollider;
            }(Collider), _temp$J), (_applyDecoratedDescriptor(_class2$G.prototype, "size", [_dec4$D, _dec5$A], Object.getOwnPropertyDescriptor(_class2$G.prototype, "size"), _class2$G.prototype), _descriptor$F = _applyDecoratedDescriptor(_class2$G.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(1, 1, 1);
              }
            })), _class2$G)) || _class$Q) || _class$Q) || _class$Q) || _class$Q));

            var _dec$R, _dec2$J, _dec3$H, _dec4$E, _class$R, _class2$H, _descriptor$G, _temp$K;
            var SphereCollider = function (v) { return exports({ SphereCollider: v, SphereColliderComponent: v }), v; }((_dec$R = ccclass('cc.SphereCollider'), _dec2$J = help(), _dec3$H = menu(), _dec4$E = tooltip(), _dec$R(_class$R = _dec2$J(_class$R = _dec3$H(_class$R = executeInEditMode(_class$R = (_class2$H = (_temp$K = function (_Collider) {
              _inheritsLoose(SphereCollider, _Collider);

              _createClass(SphereCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  this._radius = value;

                  {
                    this.shape.setRadius(this._radius);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function SphereCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.SPHERE) || this;

                _initializerDefineProperty(_this, "_radius", _descriptor$G, _assertThisInitialized(_this));

                return _this;
              }

              return SphereCollider;
            }(Collider), _temp$K), (_applyDecoratedDescriptor(_class2$H.prototype, "radius", [_dec4$E], Object.getOwnPropertyDescriptor(_class2$H.prototype, "radius"), _class2$H.prototype), _descriptor$G = _applyDecoratedDescriptor(_class2$H.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            })), _class2$H)) || _class$R) || _class$R) || _class$R) || _class$R));

            var _dec$S, _dec2$K, _dec3$I, _dec4$F, _dec5$B, _dec6$y, _dec7$y, _class$S, _class2$I, _descriptor$H, _descriptor2$B, _descriptor3$w, _temp$L;
            var CapsuleCollider = function (v) { return exports({ CapsuleCollider: v, CapsuleColliderComponent: v }), v; }((_dec$S = ccclass('cc.CapsuleCollider'), _dec2$K = help(), _dec3$I = menu(), _dec4$F = tooltip(), _dec5$B = tooltip(), _dec6$y = type(EAxisDirection), _dec7$y = tooltip(), _dec$S(_class$S = _dec2$K(_class$S = _dec3$I(_class$S = executeInEditMode(_class$S = (_class2$I = (_temp$L = function (_Collider) {
              _inheritsLoose(CapsuleCollider, _Collider);

              _createClass(CapsuleCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (value < 0) value = 0;
                  this._radius = value;

                  {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "cylinderHeight",
                get: function get() {
                  return this._cylinderHeight;
                },
                set: function set(value) {
                  if (value < 0) value = 0;
                  this._cylinderHeight = value;

                  {
                    this.shape.setCylinderHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  value = Math.floor(value);
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  this._direction = value;

                  {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._radius * 2 + this._cylinderHeight;
                },
                set: function set(value) {
                  var ch = value - this._radius * 2;
                  if (ch < 0) ch = 0;
                  this.cylinderHeight = ch;
                }
              }, {
                key: "worldHeight",
                get: function get() {
                  return this._radius * 2 * this._getRadiusScale() + this._cylinderHeight * this._getHeightScale();
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function CapsuleCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CAPSULE) || this;

                _initializerDefineProperty(_this, "_radius", _descriptor$H, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_cylinderHeight", _descriptor2$B, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$w, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = CapsuleCollider.prototype;

              _proto._getRadiusScale = function _getRadiusScale() {
                if (this.node == null) return 1;
                var ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(absMax(ws.x, ws.z));
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(absMax(ws.y, ws.z));
                return Math.abs(absMax(ws.x, ws.y));
              };

              _proto._getHeightScale = function _getHeightScale() {
                if (this.node == null) return 1;
                var ws = this.node.worldScale;
                if (this._direction === EAxisDirection.Y_AXIS) return Math.abs(ws.y);
                if (this._direction === EAxisDirection.X_AXIS) return Math.abs(ws.x);
                return Math.abs(ws.z);
              };

              return CapsuleCollider;
            }(Collider), _temp$L), (_applyDecoratedDescriptor(_class2$I.prototype, "radius", [_dec4$F], Object.getOwnPropertyDescriptor(_class2$I.prototype, "radius"), _class2$I.prototype), _applyDecoratedDescriptor(_class2$I.prototype, "cylinderHeight", [_dec5$B], Object.getOwnPropertyDescriptor(_class2$I.prototype, "cylinderHeight"), _class2$I.prototype), _applyDecoratedDescriptor(_class2$I.prototype, "direction", [_dec6$y, _dec7$y], Object.getOwnPropertyDescriptor(_class2$I.prototype, "direction"), _class2$I.prototype), _descriptor$H = _applyDecoratedDescriptor(_class2$I.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor2$B = _applyDecoratedDescriptor(_class2$I.prototype, "_cylinderHeight", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor3$w = _applyDecoratedDescriptor(_class2$I.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$I)) || _class$S) || _class$S) || _class$S) || _class$S));

            var _dec$T, _dec2$L, _dec3$J, _dec4$G, _dec5$C, _dec6$z, _class$T, _class2$J, _descriptor$I, _descriptor2$C, _descriptor3$x, _temp$M;
            var CylinderCollider = function (v) { return exports({ CylinderCollider: v, CylinderColliderComponent: v }), v; }((_dec$T = ccclass('cc.CylinderCollider'), _dec2$L = help(), _dec3$J = menu(), _dec4$G = tooltip(), _dec5$C = tooltip(), _dec6$z = type(EAxisDirection), _dec$T(_class$T = _dec2$L(_class$T = _dec3$J(_class$T = executeInEditMode(_class$T = (_class2$J = (_temp$M = function (_Collider) {
              _inheritsLoose(CylinderCollider, _Collider);

              _createClass(CylinderCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  if (value < 0) value = 0;
                  this._radius = value;

                  {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                },
                set: function set(value) {
                  if (this._height === value) return;
                  if (value < 0) value = 0;
                  this._height = value;

                  {
                    this.shape.setHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) return;
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  this._direction = value;

                  {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function CylinderCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CYLINDER) || this;

                _initializerDefineProperty(_this, "_radius", _descriptor$I, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_height", _descriptor2$C, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$x, _assertThisInitialized(_this));

                return _this;
              }

              return CylinderCollider;
            }(Collider), _temp$M), (_applyDecoratedDescriptor(_class2$J.prototype, "radius", [_dec4$G], Object.getOwnPropertyDescriptor(_class2$J.prototype, "radius"), _class2$J.prototype), _applyDecoratedDescriptor(_class2$J.prototype, "height", [_dec5$C], Object.getOwnPropertyDescriptor(_class2$J.prototype, "height"), _class2$J.prototype), _applyDecoratedDescriptor(_class2$J.prototype, "direction", [_dec6$z], Object.getOwnPropertyDescriptor(_class2$J.prototype, "direction"), _class2$J.prototype), _descriptor$I = _applyDecoratedDescriptor(_class2$J.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor2$C = _applyDecoratedDescriptor(_class2$J.prototype, "_height", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 2;
              }
            }), _descriptor3$x = _applyDecoratedDescriptor(_class2$J.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$J)) || _class$T) || _class$T) || _class$T) || _class$T));

            var _dec$U, _dec2$M, _dec3$K, _dec4$H, _dec5$D, _dec6$A, _class$U, _class2$K, _descriptor$J, _descriptor2$D, _descriptor3$y, _temp$N;
            var ConeCollider = exports('ConeCollider', (_dec$U = ccclass('cc.ConeCollider'), _dec2$M = help(), _dec3$K = menu(), _dec4$H = tooltip(), _dec5$D = tooltip(), _dec6$A = type(EAxisDirection), _dec$U(_class$U = _dec2$M(_class$U = _dec3$K(_class$U = executeInEditMode(_class$U = (_class2$K = (_temp$N = function (_Collider) {
              _inheritsLoose(ConeCollider, _Collider);

              _createClass(ConeCollider, [{
                key: "radius",
                get: function get() {
                  return this._radius;
                },
                set: function set(value) {
                  if (this._radius === value) return;
                  if (value < 0) value = 0;
                  this._radius = value;

                  {
                    this.shape.setRadius(value);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                },
                set: function set(value) {
                  if (this._height === value) return;
                  if (value < 0) value = 0;
                  this._height = value;

                  {
                    this.shape.setHeight(value);
                  }
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._direction;
                },
                set: function set(value) {
                  if (this._direction === value) return;
                  if (value < EAxisDirection.X_AXIS || value > EAxisDirection.Z_AXIS) return;
                  this._direction = value;

                  {
                    this.shape.setDirection(value);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function ConeCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.CONE) || this;

                _initializerDefineProperty(_this, "_radius", _descriptor$J, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_height", _descriptor2$D, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_direction", _descriptor3$y, _assertThisInitialized(_this));

                return _this;
              }

              return ConeCollider;
            }(Collider), _temp$N), (_applyDecoratedDescriptor(_class2$K.prototype, "radius", [_dec4$H], Object.getOwnPropertyDescriptor(_class2$K.prototype, "radius"), _class2$K.prototype), _applyDecoratedDescriptor(_class2$K.prototype, "height", [_dec5$D], Object.getOwnPropertyDescriptor(_class2$K.prototype, "height"), _class2$K.prototype), _applyDecoratedDescriptor(_class2$K.prototype, "direction", [_dec6$A], Object.getOwnPropertyDescriptor(_class2$K.prototype, "direction"), _class2$K.prototype), _descriptor$J = _applyDecoratedDescriptor(_class2$K.prototype, "_radius", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor2$D = _applyDecoratedDescriptor(_class2$K.prototype, "_height", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor3$y = _applyDecoratedDescriptor(_class2$K.prototype, "_direction", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return EAxisDirection.Y_AXIS;
              }
            })), _class2$K)) || _class$U) || _class$U) || _class$U) || _class$U));

            var _dec$V, _dec2$N, _dec3$L, _dec4$I, _class$V, _class2$L, _descriptor$K, _descriptor2$E, _temp$O;
            var MeshCollider = function (v) { return exports({ MeshCollider: v, MeshColliderComponent: v }), v; }((_dec$V = ccclass('cc.MeshCollider'), _dec2$N = help(), _dec3$L = menu(), _dec4$I = type(Mesh), _dec$V(_class$V = _dec2$N(_class$V = _dec3$L(_class$V = executeInEditMode(_class$V = (_class2$L = (_temp$O = function (_Collider) {
              _inheritsLoose(MeshCollider, _Collider);

              _createClass(MeshCollider, [{
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(value) {
                  this._mesh = value;
                  this.shape.setMesh(this._mesh);
                }
              }, {
                key: "convex",
                get: function get() {
                  return this._convex;
                },
                set: function set(value) {
                  this._convex = value;
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function MeshCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.MESH) || this;

                _initializerDefineProperty(_this, "_mesh", _descriptor$K, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_convex", _descriptor2$E, _assertThisInitialized(_this));

                return _this;
              }

              return MeshCollider;
            }(Collider), _temp$O), (_applyDecoratedDescriptor(_class2$L.prototype, "mesh", [_dec4$I], Object.getOwnPropertyDescriptor(_class2$L.prototype, "mesh"), _class2$L.prototype), _applyDecoratedDescriptor(_class2$L.prototype, "convex", [editable], Object.getOwnPropertyDescriptor(_class2$L.prototype, "convex"), _class2$L.prototype), _descriptor$K = _applyDecoratedDescriptor(_class2$L.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$E = _applyDecoratedDescriptor(_class2$L.prototype, "_convex", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            })), _class2$L)) || _class$V) || _class$V) || _class$V) || _class$V));

            var _dec$W, _dec2$O, _dec3$M, _dec4$J, _dec5$E, _dec6$B, _dec7$z, _dec8$t, _dec9$r, _dec10$p, _dec11$o, _dec12$m, _class$W, _class2$M, _descriptor$L, _descriptor2$F, _descriptor3$z, _descriptor4$q, _temp$P;
            var ConstantForce = exports('ConstantForce', (_dec$W = ccclass('cc.ConstantForce'), _dec2$O = help(), _dec3$M = requireComponent(RigidBody), _dec4$J = menu(), _dec5$E = displayOrder(), _dec6$B = tooltip(), _dec7$z = displayOrder(), _dec8$t = tooltip(), _dec9$r = displayOrder(), _dec10$p = tooltip(), _dec11$o = displayOrder(), _dec12$m = tooltip(), _dec$W(_class$W = _dec2$O(_class$W = _dec3$M(_class$W = _dec4$J(_class$W = disallowMultiple(_class$W = executeInEditMode(_class$W = (_class2$M = (_temp$P = function (_Component) {
              _inheritsLoose(ConstantForce, _Component);

              function ConstantForce() {
                var _this;

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _Component.call.apply(_Component, [this].concat(args)) || this;
                _this._rigidBody = null;

                _initializerDefineProperty(_this, "_force", _descriptor$L, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_localForce", _descriptor2$F, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_torque", _descriptor3$z, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_localTorque", _descriptor4$q, _assertThisInitialized(_this));

                _this._mask = 0;
                return _this;
              }

              var _proto = ConstantForce.prototype;

              _proto.onLoad = function onLoad() {
                this._rigidBody = this.node.getComponent(RigidBody);

                this._maskUpdate(this._force, 1);

                this._maskUpdate(this._localForce, 2);

                this._maskUpdate(this._torque, 4);

                this._maskUpdate(this._localTorque, 8);
              };

              _proto.lateUpdate = function lateUpdate(dt) {
                {
                  if (this._rigidBody != null && this._mask !== 0) {
                    if (this._mask & 1) this._rigidBody.applyForce(this._force);
                    if (this._mask & 2) this._rigidBody.applyLocalForce(this.localForce);
                    if (this._mask & 4) this._rigidBody.applyTorque(this._torque);
                    if (this._mask & 8) this._rigidBody.applyLocalTorque(this._localTorque);
                  }
                }
              };

              _proto._maskUpdate = function _maskUpdate(t, m) {
                if (t.strictEquals(Vec3.ZERO)) {
                  this._mask &= ~m;
                } else {
                  this._mask |= m;
                }
              };

              _createClass(ConstantForce, [{
                key: "force",
                get: function get() {
                  return this._force;
                },
                set: function set(value) {
                  Vec3.copy(this._force, value);

                  this._maskUpdate(this._force, 1);
                }
              }, {
                key: "localForce",
                get: function get() {
                  return this._localForce;
                },
                set: function set(value) {
                  Vec3.copy(this._localForce, value);

                  this._maskUpdate(this.localForce, 2);
                }
              }, {
                key: "torque",
                get: function get() {
                  return this._torque;
                },
                set: function set(value) {
                  Vec3.copy(this._torque, value);

                  this._maskUpdate(this._torque, 4);
                }
              }, {
                key: "localTorque",
                get: function get() {
                  return this._localTorque;
                },
                set: function set(value) {
                  Vec3.copy(this._localTorque, value);

                  this._maskUpdate(this._localTorque, 8);
                }
              }]);

              return ConstantForce;
            }(Component), _temp$P), (_descriptor$L = _applyDecoratedDescriptor(_class2$M.prototype, "_force", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor2$F = _applyDecoratedDescriptor(_class2$M.prototype, "_localForce", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor3$z = _applyDecoratedDescriptor(_class2$M.prototype, "_torque", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor4$q = _applyDecoratedDescriptor(_class2$M.prototype, "_localTorque", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _applyDecoratedDescriptor(_class2$M.prototype, "force", [_dec5$E, _dec6$B], Object.getOwnPropertyDescriptor(_class2$M.prototype, "force"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "localForce", [_dec7$z, _dec8$t], Object.getOwnPropertyDescriptor(_class2$M.prototype, "localForce"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "torque", [_dec9$r, _dec10$p], Object.getOwnPropertyDescriptor(_class2$M.prototype, "torque"), _class2$M.prototype), _applyDecoratedDescriptor(_class2$M.prototype, "localTorque", [_dec11$o, _dec12$m], Object.getOwnPropertyDescriptor(_class2$M.prototype, "localTorque"), _class2$M.prototype)), _class2$M)) || _class$W) || _class$W) || _class$W) || _class$W) || _class$W) || _class$W));

            var _dec$X, _class$X, _temp$Q;
            var TERRAIN_BLOCK_TILE_COMPLEXITY = 32;
            var TERRAIN_HEIGHT_BASE = 32768;
            var TERRAIN_HEIGHT_FACTORY = 1.0 / 512.0;
            var TERRAIN_DATA_VERSION = 0x01010001;
            var TERRAIN_DATA_VERSION2 = 0x01010002;
            var TERRAIN_DATA_VERSION3 = 0x01010003;
            var TERRAIN_DATA_VERSION4 = 0x01010004;
            var TERRAIN_DATA_VERSION_DEFAULT = 0x01010111;

            var TerrainBuffer = function () {
              function TerrainBuffer() {
                this.length = 0;
                this.buffer = new Uint8Array(2048);
                this._buffView = new DataView(this.buffer.buffer);
                this._seekPos = 0;
              }

              var _proto = TerrainBuffer.prototype;

              _proto.reserve = function reserve(size) {
                if (this.buffer.byteLength > size) {
                  return;
                }

                var capacity = this.buffer.byteLength;

                while (capacity < size) {
                  capacity += capacity;
                }

                var temp = new Uint8Array(capacity);

                for (var i = 0; i < this.length; ++i) {
                  temp[i] = this.buffer[i];
                }

                this.buffer = temp;
                this._buffView = new DataView(this.buffer.buffer);
              };

              _proto.assign = function assign(buff) {
                this.buffer = buff;
                this.length = buff.length;
                this._seekPos = buff.byteOffset;
                this._buffView = new DataView(buff.buffer);
              };

              _proto.writeInt8 = function writeInt8(value) {
                this.reserve(this.length + 1);

                this._buffView.setInt8(this.length, value);

                this.length += 1;
              };

              _proto.writeInt16 = function writeInt16(value) {
                this.reserve(this.length + 2);

                this._buffView.setInt16(this.length, value, true);

                this.length += 2;
              };

              _proto.writeInt32 = function writeInt32(value) {
                this.reserve(this.length + 4);

                this._buffView.setInt32(this.length, value, true);

                this.length += 4;
              };

              _proto.writeIntArray = function writeIntArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setInt32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              };

              _proto.writeFloat = function writeFloat(value) {
                this.reserve(this.length + 4);

                this._buffView.setFloat32(this.length, value, true);

                this.length += 4;
              };

              _proto.writeFloatArray = function writeFloatArray(value) {
                this.reserve(this.length + 4 * value.length);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setFloat32(this.length + i * 4, value[i], true);
                }

                this.length += 4 * value.length;
              };

              _proto.writeString = function writeString(value) {
                this.reserve(this.length + value.length + 4);

                this._buffView.setInt32(this.length, value.length, true);

                for (var i = 0; i < value.length; ++i) {
                  this._buffView.setInt8(this.length + 4 + i, value.charCodeAt(i));
                }

                this.length += value.length + 4;
              };

              _proto.readInt8 = function readInt8() {
                var value = this._buffView.getInt8(this._seekPos);

                this._seekPos += 1;
                return value;
              };

              _proto.readInt16 = function readInt16() {
                var value = this._buffView.getInt16(this._seekPos, true);

                this._seekPos += 2;
                return value;
              };

              _proto.readInt = function readInt() {
                var value = this._buffView.getInt32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              };

              _proto.readIntArray = function readIntArray(value) {
                for (var i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getInt32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              };

              _proto.readFloat = function readFloat() {
                var value = this._buffView.getFloat32(this._seekPos, true);

                this._seekPos += 4;
                return value;
              };

              _proto.readFloatArray = function readFloatArray(value) {
                for (var i = 0; i < value.length; ++i) {
                  value[i] = this._buffView.getFloat32(this._seekPos + i * 4, true);
                }

                this._seekPos += 4 * value.length;
                return value;
              };

              _proto.readString = function readString() {
                var length = this.readInt();
                var value = '';

                for (var i = 0; i < length; ++i) {
                  value += String.fromCharCode(this.readInt8());
                }

                return value;
              };

              return TerrainBuffer;
            }();

            var TerrainLayerInfo = function TerrainLayerInfo() {
              this.slot = 0;
              this.tileSize = 1;
              this.detailMap = '';
              this.normalMap = '';
              this.roughness = 1;
              this.metallic = 0;
            };
            var TerrainAsset = (_dec$X = ccclass('cc.TerrainAsset'), _dec$X(_class$X = (_temp$Q = function (_Asset) {
              _inheritsLoose(TerrainAsset, _Asset);

              function TerrainAsset() {
                var _this;

                _this = _Asset.call(this) || this;
                _this._data = null;
                _this._tileSize = 1;
                _this._blockCount = [1, 1];
                _this._weightMapSize = 128;
                _this._lightMapSize = 128;
                _this._heights = new Uint16Array();
                _this._weights = new Uint8Array();
                _this._layerBuffer = [-1, -1, -1, -1];
                _this._layerInfos = [];
                _this.loaded = false;
                return _this;
              }

              var _proto2 = TerrainAsset.prototype;

              _proto2.getLayer = function getLayer(xBlock, yBlock, layerId) {
                var blockId = yBlock * this.blockCount[0] + xBlock;
                var index = blockId * 4 + layerId;

                if (xBlock < this.blockCount[0] && yBlock < this.blockCount[1] && index < this._layerBuffer.length) {
                  return this._layerBuffer[index];
                }

                return -1;
              };

              _proto2.getHeight = function getHeight(i, j) {
                var vertexCountX = this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
                return (this._heights[j * vertexCountX + i] - TERRAIN_HEIGHT_BASE) * TERRAIN_HEIGHT_FACTORY;
              };

              _proto2.getVertexCountI = function getVertexCountI() {
                if (this._blockCount.length < 1) return 0;
                return this._blockCount[0] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              };

              _proto2.getVertexCountJ = function getVertexCountJ() {
                if (this._blockCount.length < 2) return 0;
                return this._blockCount[1] * TERRAIN_BLOCK_TILE_COMPLEXITY + 1;
              };

              _proto2._setNativeData = function _setNativeData(_nativeData) {
                this._data = _nativeData;
              };

              _proto2._loadNativeData = function _loadNativeData(_nativeData) {
                var stream = new TerrainBuffer();
                stream.assign(_nativeData);
                var version = stream.readInt();

                if (version === TERRAIN_DATA_VERSION_DEFAULT) {
                  return true;
                }

                if (version !== TERRAIN_DATA_VERSION && version !== TERRAIN_DATA_VERSION2 && version !== TERRAIN_DATA_VERSION3 && version !== TERRAIN_DATA_VERSION4) {
                  return false;
                }

                this.tileSize = stream.readFloat();
                stream.readIntArray(this._blockCount);
                this.weightMapSize = stream.readInt16();
                this.lightMapSize = stream.readInt16();
                var heightBufferSize = stream.readInt();
                this.heights = new Uint16Array(heightBufferSize);

                for (var i = 0; i < this.heights.length; ++i) {
                  this.heights[i] = stream.readInt16();
                }

                var WeightBufferSize = stream.readInt();
                this.weights = new Uint8Array(WeightBufferSize);

                for (var _i = 0; _i < this.weights.length; ++_i) {
                  this.weights[_i] = stream.readInt8();
                }

                if (version >= TERRAIN_DATA_VERSION2) {
                  var layerBufferSize = stream.readInt();
                  this.layerBuffer = new Array(layerBufferSize);

                  for (var _i2 = 0; _i2 < this.layerBuffer.length; ++_i2) {
                    this.layerBuffer[_i2] = stream.readInt16();
                  }
                }

                if (version >= TERRAIN_DATA_VERSION3) {
                  var layerInfoSize = stream.readInt();
                  this.layerInfos = new Array(layerInfoSize);

                  for (var _i3 = 0; _i3 < this.layerInfos.length; ++_i3) {
                    this.layerInfos[_i3] = new TerrainLayerInfo();
                    this.layerInfos[_i3].slot = stream.readInt();
                    this.layerInfos[_i3].tileSize = stream.readFloat();
                    this.layerInfos[_i3].detailMap = stream.readString();

                    if (version >= TERRAIN_DATA_VERSION4) {
                      this.layerInfos[_i3].normalMap = stream.readString();
                      this.layerInfos[_i3].roughness = stream.readFloat();
                      this.layerInfos[_i3].metallic = stream.readFloat();
                    }
                  }
                }

                return true;
              };

              _proto2._exportNativeData = function _exportNativeData() {
                var stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION4);
                stream.writeFloat(this.tileSize);
                stream.writeIntArray(this._blockCount);
                stream.writeInt16(this.weightMapSize);
                stream.writeInt16(this.lightMapSize);
                stream.writeInt32(this.heights.length);

                for (var i = 0; i < this.heights.length; ++i) {
                  stream.writeInt16(this.heights[i]);
                }

                stream.writeInt32(this.weights.length);

                for (var _i4 = 0; _i4 < this.weights.length; ++_i4) {
                  stream.writeInt8(this.weights[_i4]);
                }

                stream.writeInt32(this.layerBuffer.length);

                for (var _i5 = 0; _i5 < this.layerBuffer.length; ++_i5) {
                  stream.writeInt16(this.layerBuffer[_i5]);
                }

                stream.writeInt32(this.layerInfos.length);

                for (var _i6 = 0; _i6 < this.layerInfos.length; ++_i6) {
                  stream.writeInt32(this.layerInfos[_i6].slot);
                  stream.writeFloat(this.layerInfos[_i6].tileSize);
                  stream.writeString(this.layerInfos[_i6].detailMap);
                  stream.writeString(this.layerInfos[_i6].normalMap);
                  stream.writeFloat(this.layerInfos[_i6].roughness);
                  stream.writeFloat(this.layerInfos[_i6].metallic);
                }

                return stream.buffer;
              };

              _proto2._exportDefaultNativeData = function _exportDefaultNativeData() {
                var stream = new TerrainBuffer();
                stream.writeInt32(TERRAIN_DATA_VERSION_DEFAULT);
                return stream.buffer;
              };

              _createClass(TerrainAsset, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._data.buffer;
                },
                set: function set(value) {
                  if (this._data && this._data.byteLength === value.byteLength) {
                    this._data.set(new Uint8Array(value));
                  } else {
                    this._data = new Uint8Array(value);
                  }

                  this._loadNativeData(this._data);

                  this.loaded = true;
                  this.emit('load');
                }
              }, {
                key: "tileSize",
                set: function set(value) {
                  this._tileSize = value;
                },
                get: function get() {
                  return this._tileSize;
                }
              }, {
                key: "blockCount",
                set: function set(value) {
                  this._blockCount = value;
                },
                get: function get() {
                  return this._blockCount;
                }
              }, {
                key: "lightMapSize",
                set: function set(value) {
                  this._lightMapSize = value;
                },
                get: function get() {
                  return this._lightMapSize;
                }
              }, {
                key: "weightMapSize",
                set: function set(value) {
                  this._weightMapSize = value;
                },
                get: function get() {
                  return this._weightMapSize;
                }
              }, {
                key: "heights",
                set: function set(value) {
                  this._heights = value;
                },
                get: function get() {
                  return this._heights;
                }
              }, {
                key: "weights",
                set: function set(value) {
                  this._weights = value;
                },
                get: function get() {
                  return this._weights;
                }
              }, {
                key: "layerBuffer",
                set: function set(value) {
                  this._layerBuffer = value;
                },
                get: function get() {
                  return this._layerBuffer;
                }
              }, {
                key: "layerInfos",
                set: function set(value) {
                  this._layerInfos = value;
                },
                get: function get() {
                  return this._layerInfos;
                }
              }]);

              return TerrainAsset;
            }(Asset), _temp$Q)) || _class$X);

            var _dec$Y, _dec2$P, _dec3$N, _dec4$K, _class$Y, _class2$N, _descriptor$M, _temp$R;
            var TerrainCollider = exports('TerrainCollider', (_dec$Y = ccclass('cc.TerrainCollider'), _dec2$P = help(), _dec3$N = menu(), _dec4$K = type(TerrainAsset), _dec$Y(_class$Y = _dec2$P(_class$Y = _dec3$N(_class$Y = executeInEditMode(_class$Y = (_class2$N = (_temp$R = function (_Collider) {
              _inheritsLoose(TerrainCollider, _Collider);

              _createClass(TerrainCollider, [{
                key: "terrain",
                get: function get() {
                  return this._terrain;
                },
                set: function set(value) {
                  this._terrain = value;
                  this.shape.setTerrain(this._terrain);
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function TerrainCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.TERRAIN) || this;

                _initializerDefineProperty(_this, "_terrain", _descriptor$M, _assertThisInitialized(_this));

                return _this;
              }

              return TerrainCollider;
            }(Collider), _temp$R), (_applyDecoratedDescriptor(_class2$N.prototype, "terrain", [_dec4$K], Object.getOwnPropertyDescriptor(_class2$N.prototype, "terrain"), _class2$N.prototype), _descriptor$M = _applyDecoratedDescriptor(_class2$N.prototype, "_terrain", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$N)) || _class$Y) || _class$Y) || _class$Y) || _class$Y));

            var _dec$Z, _dec2$Q, _dec3$O, _dec4$L, _dec5$F, _dec6$C, _dec7$A, _class$Z, _class2$O, _descriptor$N, _descriptor2$G, _class3$l, _temp$S;
            var SimplexCollider = exports('SimplexCollider', (_dec$Z = ccclass('cc.SimplexCollider'), _dec2$Q = help(), _dec3$O = menu(), _dec4$L = type(ESimplexType), _dec5$F = visible(), _dec6$C = visible(), _dec7$A = visible(), _dec$Z(_class$Z = _dec2$Q(_class$Z = _dec3$O(_class$Z = executeInEditMode(_class$Z = (_class2$O = (_temp$S = _class3$l = function (_Collider) {
              _inheritsLoose(SimplexCollider, _Collider);

              _createClass(SimplexCollider, [{
                key: "shapeType",
                get: function get() {
                  return this._shapeType;
                },
                set: function set(v) {
                  this._shapeType = v;

                  {
                    this.shape.setShapeType(v);
                  }
                }
              }, {
                key: "vertex0",
                get: function get() {
                  return this._vertices[0];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[0], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex1",
                get: function get() {
                  return this._vertices[1];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[1], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex2",
                get: function get() {
                  return this._vertices[2];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[2], v);
                  this.updateVertices();
                }
              }, {
                key: "vertex3",
                get: function get() {
                  return this._vertices[3];
                },
                set: function set(v) {
                  Vec3.copy(this._vertices[3], v);
                  this.updateVertices();
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }, {
                key: "vertices",
                get: function get() {
                  return this._vertices;
                }
              }]);

              function SimplexCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.SIMPLEX) || this;

                _initializerDefineProperty(_this, "_shapeType", _descriptor$N, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_vertices", _descriptor2$G, _assertThisInitialized(_this));

                return _this;
              }

              var _proto = SimplexCollider.prototype;

              _proto.updateVertices = function updateVertices() {
                {
                  this.shape.setVertices(this._vertices);
                }
              };

              return SimplexCollider;
            }(Collider), _class3$l.ESimplexType = ESimplexType, _temp$S), (_applyDecoratedDescriptor(_class2$O.prototype, "shapeType", [_dec4$L], Object.getOwnPropertyDescriptor(_class2$O.prototype, "shapeType"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "vertex0", [editable], Object.getOwnPropertyDescriptor(_class2$O.prototype, "vertex0"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "vertex1", [_dec5$F], Object.getOwnPropertyDescriptor(_class2$O.prototype, "vertex1"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "vertex2", [_dec6$C], Object.getOwnPropertyDescriptor(_class2$O.prototype, "vertex2"), _class2$O.prototype), _applyDecoratedDescriptor(_class2$O.prototype, "vertex3", [_dec7$A], Object.getOwnPropertyDescriptor(_class2$O.prototype, "vertex3"), _class2$O.prototype), _descriptor$N = _applyDecoratedDescriptor(_class2$O.prototype, "_shapeType", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ESimplexType.TETRAHEDRON;
              }
            }), _descriptor2$G = _applyDecoratedDescriptor(_class2$O.prototype, "_vertices", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [new Vec3(0, 0, 0), new Vec3(0, 0, 1), new Vec3(1, 0, 0), new Vec3(0, 1, 0)];
              }
            })), _class2$O)) || _class$Z) || _class$Z) || _class$Z) || _class$Z));

            (function (_SimplexCollider) {})(SimplexCollider || (SimplexCollider = exports('SimplexCollider', {})));

            var _dec$_, _dec2$R, _dec3$P, _dec4$M, _dec5$G, _class$_, _class2$P, _descriptor$O, _descriptor2$H, _temp$T;
            var PlaneCollider = exports('PlaneCollider', (_dec$_ = ccclass('cc.PlaneCollider'), _dec2$R = help(), _dec3$P = menu(), _dec4$M = type(Vec3), _dec5$G = tooltip(), _dec$_(_class$_ = _dec2$R(_class$_ = _dec3$P(_class$_ = executeInEditMode(_class$_ = (_class2$P = (_temp$T = function (_Collider) {
              _inheritsLoose(PlaneCollider, _Collider);

              _createClass(PlaneCollider, [{
                key: "normal",
                get: function get() {
                  return this._normal;
                },
                set: function set(value) {
                  Vec3.copy(this._normal, value);

                  {
                    this.shape.setNormal(this._normal);
                  }
                }
              }, {
                key: "constant",
                get: function get() {
                  return this._constant;
                },
                set: function set(v) {
                  this._constant = v;

                  {
                    this.shape.setConstant(this._constant);
                  }
                }
              }, {
                key: "shape",
                get: function get() {
                  return this._shape;
                }
              }]);

              function PlaneCollider() {
                var _this;

                _this = _Collider.call(this, EColliderType.PLANE) || this;

                _initializerDefineProperty(_this, "_normal", _descriptor$O, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_constant", _descriptor2$H, _assertThisInitialized(_this));

                return _this;
              }

              return PlaneCollider;
            }(Collider), _temp$T), (_applyDecoratedDescriptor(_class2$P.prototype, "normal", [_dec4$M, _dec5$G], Object.getOwnPropertyDescriptor(_class2$P.prototype, "normal"), _class2$P.prototype), _applyDecoratedDescriptor(_class2$P.prototype, "constant", [editable], Object.getOwnPropertyDescriptor(_class2$P.prototype, "constant"), _class2$P.prototype), _descriptor$O = _applyDecoratedDescriptor(_class2$P.prototype, "_normal", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(0, 1, 0);
              }
            }), _descriptor2$H = _applyDecoratedDescriptor(_class2$P.prototype, "_constant", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$P)) || _class$_) || _class$_) || _class$_) || _class$_));

            var _dec$$, _dec2$S, _dec3$Q, _dec4$N, _dec5$H, _dec6$D, _dec7$B, _dec8$u, _class$$, _class2$Q, _descriptor$P, _descriptor2$I, _class3$m, _temp$U;
            var Constraint$1 = exports('Constraint', (_dec$$ = ccclass('cc.Constraint'), _dec2$S = requireComponent(RigidBody), _dec3$Q = type(RigidBody), _dec4$N = displayOrder(), _dec5$H = type(RigidBody), _dec6$D = displayOrder(), _dec7$B = displayOrder(), _dec8$u = type(RigidBody), _dec$$(_class$$ = _dec2$S(_class$$ = (_class2$Q = (_temp$U = _class3$m = function (_Eventify) {
              _inheritsLoose(Constraint, _Eventify);

              _createClass(Constraint, [{
                key: "attachedBody",
                get: function get() {
                  return this.getComponent(RigidBody);
                }
              }, {
                key: "connectedBody",
                get: function get() {
                  return this._connectedBody;
                },
                set: function set(v) {
                  this._connectedBody = v;

                  {
                    if (this._constraint) this._constraint.setConnectedBody(v);
                  }
                }
              }, {
                key: "enableCollision",
                get: function get() {
                  return this._enableCollision;
                },
                set: function set(v) {
                  this._enableCollision = v;

                  {
                    if (this._constraint) this._constraint.setEnableCollision(v);
                  }
                }
              }]);

              function Constraint(type) {
                var _this;

                _this = _Eventify.call(this) || this;
                _this.TYPE = void 0;

                _initializerDefineProperty(_this, "_enableCollision", _descriptor$P, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_connectedBody", _descriptor2$I, _assertThisInitialized(_this));

                _this._constraint = null;
                _this.TYPE = type;
                return _this;
              }

              var _proto = Constraint.prototype;

              _proto.onLoad = function onLoad() {
                {
                  this._constraint = createConstraint(this.TYPE);

                  this._constraint.initialize(this);
                }
              };

              _proto.onEnable = function onEnable() {
                if (this._constraint) {
                  this._constraint.onEnable();
                }
              };

              _proto.onDisable = function onDisable() {
                if (this._constraint) {
                  this._constraint.onDisable();
                }
              };

              _proto.onDestroy = function onDestroy() {
                if (this._constraint) {
                  this._constraint.onDestroy();
                }
              };

              return Constraint;
            }(Eventify(Component)), _class3$m.Type = EConstraintType, _temp$U), (_applyDecoratedDescriptor(_class2$Q.prototype, "attachedBody", [_dec3$Q, readOnly, _dec4$N], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "attachedBody"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "connectedBody", [_dec5$H, _dec6$D], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "connectedBody"), _class2$Q.prototype), _applyDecoratedDescriptor(_class2$Q.prototype, "enableCollision", [_dec7$B], Object.getOwnPropertyDescriptor(_class2$Q.prototype, "enableCollision"), _class2$Q.prototype), _descriptor$P = _applyDecoratedDescriptor(_class2$Q.prototype, "_enableCollision", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor2$I = _applyDecoratedDescriptor(_class2$Q.prototype, "_connectedBody", [_dec8$u], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$Q)) || _class$$) || _class$$));

            (function (_Constraint) {})(Constraint$1 || (Constraint$1 = exports('Constraint', {})));

            var _dec$10, _dec2$T, _dec3$R, _dec4$O, _dec5$I, _dec6$E, _dec7$C, _dec8$v, _dec9$s, _class$10, _class2$R, _descriptor$Q, _descriptor2$J, _descriptor3$A, _temp$V;
            var HingeConstraint = exports('HingeConstraint', (_dec$10 = ccclass('cc.HingeConstraint'), _dec2$T = help(), _dec3$R = menu(), _dec4$O = type(Vec3), _dec5$I = type(Vec3), _dec6$E = type(Vec3), _dec7$C = formerlySerializedAs('axisA'), _dec8$v = formerlySerializedAs('pivotA'), _dec9$s = formerlySerializedAs('pivotB'), _dec$10(_class$10 = _dec2$T(_class$10 = _dec3$R(_class$10 = (_class2$R = (_temp$V = function (_Constraint) {
              _inheritsLoose(HingeConstraint, _Constraint);

              _createClass(HingeConstraint, [{
                key: "pivotA",
                get: function get() {
                  return this._pivotA;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotA, v);

                  {
                    this.constraint.setPivotA(this._pivotA);
                  }
                }
              }, {
                key: "pivotB",
                get: function get() {
                  return this._pivotB;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotB, v);

                  {
                    this.constraint.setPivotB(this._pivotB);
                  }
                }
              }, {
                key: "axis",
                get: function get() {
                  return this._axis;
                },
                set: function set(v) {
                  Vec3.copy(this._axis, v);

                  {
                    this.constraint.setAxis(this._axis);
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                }
              }]);

              function HingeConstraint() {
                var _this;

                _this = _Constraint.call(this, EConstraintType.HINGE) || this;

                _initializerDefineProperty(_this, "_axis", _descriptor$Q, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pivotA", _descriptor2$J, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pivotB", _descriptor3$A, _assertThisInitialized(_this));

                return _this;
              }

              return HingeConstraint;
            }(Constraint$1), _temp$V), (_applyDecoratedDescriptor(_class2$R.prototype, "pivotA", [_dec4$O], Object.getOwnPropertyDescriptor(_class2$R.prototype, "pivotA"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "pivotB", [_dec5$I], Object.getOwnPropertyDescriptor(_class2$R.prototype, "pivotB"), _class2$R.prototype), _applyDecoratedDescriptor(_class2$R.prototype, "axis", [_dec6$E], Object.getOwnPropertyDescriptor(_class2$R.prototype, "axis"), _class2$R.prototype), _descriptor$Q = _applyDecoratedDescriptor(_class2$R.prototype, "_axis", [serializable, _dec7$C], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor2$J = _applyDecoratedDescriptor(_class2$R.prototype, "_pivotA", [serializable, _dec8$v], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor3$A = _applyDecoratedDescriptor(_class2$R.prototype, "_pivotB", [serializable, _dec9$s], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            })), _class2$R)) || _class$10) || _class$10) || _class$10));

            var _dec$11, _dec2$U, _dec3$S, _dec4$P, _dec5$J, _class$11, _class2$S, _descriptor$R, _descriptor2$K, _temp$W;
            var PointToPointConstraint = exports('PointToPointConstraint', (_dec$11 = ccclass('cc.PointToPointConstraint'), _dec2$U = help(), _dec3$S = menu(), _dec4$P = type(Vec3), _dec5$J = type(Vec3), _dec$11(_class$11 = _dec2$U(_class$11 = _dec3$S(_class$11 = (_class2$S = (_temp$W = function (_Constraint) {
              _inheritsLoose(PointToPointConstraint, _Constraint);

              _createClass(PointToPointConstraint, [{
                key: "pivotA",
                get: function get() {
                  return this._pivotA;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotA, v);

                  {
                    this.constraint.setPivotA(this._pivotA);
                  }
                }
              }, {
                key: "pivotB",
                get: function get() {
                  return this._pivotB;
                },
                set: function set(v) {
                  Vec3.copy(this._pivotB, v);

                  {
                    this.constraint.setPivotB(this._pivotB);
                  }
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._constraint;
                }
              }]);

              function PointToPointConstraint() {
                var _this;

                _this = _Constraint.call(this, EConstraintType.POINT_TO_POINT) || this;

                _initializerDefineProperty(_this, "_pivotA", _descriptor$R, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_pivotB", _descriptor2$K, _assertThisInitialized(_this));

                return _this;
              }

              return PointToPointConstraint;
            }(Constraint$1), _temp$W), (_applyDecoratedDescriptor(_class2$S.prototype, "pivotA", [_dec4$P], Object.getOwnPropertyDescriptor(_class2$S.prototype, "pivotA"), _class2$S.prototype), _applyDecoratedDescriptor(_class2$S.prototype, "pivotB", [_dec5$J], Object.getOwnPropertyDescriptor(_class2$S.prototype, "pivotB"), _class2$S.prototype), _descriptor$R = _applyDecoratedDescriptor(_class2$S.prototype, "_pivotA", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor2$K = _applyDecoratedDescriptor(_class2$S.prototype, "_pivotB", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            })), _class2$S)) || _class$11) || _class$11) || _class$11));

            legacyCC.PhysicsSystem = PhysicsSystem;
            legacyCC.PhysicsMaterial = PhysicsMaterial;
            legacyCC.PhysicsRayResult = PhysicsRayResult;
            legacyCC.ConstantForce = ConstantForce;

            var physics = /*#__PURE__*/Object.freeze({
                __proto__: null,
                PhysicsSystem: PhysicsSystem,
                PhysicsRayResult: PhysicsRayResult,
                get Collider () { return Collider; },
                BoxCollider: BoxCollider,
                SphereCollider: SphereCollider,
                CapsuleCollider: CapsuleCollider,
                MeshCollider: MeshCollider,
                CylinderCollider: CylinderCollider,
                ConeCollider: ConeCollider,
                TerrainCollider: TerrainCollider,
                get SimplexCollider () { return SimplexCollider; },
                PlaneCollider: PlaneCollider,
                get Constraint () { return Constraint$1; },
                HingeConstraint: HingeConstraint,
                PointToPointConstraint: PointToPointConstraint,
                get RigidBody () { return RigidBody; },
                PhysicsMaterial: PhysicsMaterial,
                ConstantForce: ConstantForce,
                selector: selector,
                get ERigidBodyType () { return ERigidBodyType; },
                get EAxisDirection () { return EAxisDirection; },
                get ESimplexType () { return ESimplexType; },
                get EColliderType () { return EColliderType; },
                get EConstraintType () { return EConstraintType; },
                get PhysicsGroup () { return PhysicsGroup; }
            });
            exports('physics', physics);

            replaceProperty(PhysicsSystem, 'PhysicsSystem', [{
              name: 'ins',
              newName: 'instance'
            }]);
            replaceProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
              name: 'deltaTime',
              newName: 'fixedTimeStep'
            }, {
              name: 'maxSubStep',
              newName: 'maxSubSteps'
            }]);
            removeProperty(PhysicsSystem.prototype, 'PhysicsSystem.prototype', [{
              name: 'useFixedTime'
            }, {
              name: 'useCollisionMatrix'
            }, {
              name: 'updateCollisionMatrix'
            }, {
              name: 'resetCollisionMatrix'
            }, {
              name: 'isCollisionGroup'
            }, {
              name: 'setCollisionGroup'
            }]);
            replaceProperty(Collider.prototype, 'Collider.prototype', [{
              name: 'attachedRigidbody',
              newName: 'attachedRigidBody'
            }]);
            replaceProperty(Collider, 'Collider', [{
              name: 'EColliderType',
              newName: 'Type'
            }, {
              name: 'EAxisDirection',
              newName: 'Axis'
            }]);
            replaceProperty(Constraint$1, 'Constraint', [{
              name: 'EConstraintType',
              newName: 'Type'
            }]);
            replaceProperty(BoxCollider.prototype, 'BoxCollider.prototype', [{
              name: 'boxShape',
              newName: 'shape'
            }]);
            replaceProperty(SphereCollider.prototype, 'SphereCollider.prototype', [{
              name: 'sphereShape',
              newName: 'shape'
            }]);
            replaceProperty(CapsuleCollider.prototype, 'CapsuleCollider.prototype', [{
              name: 'capsuleShape',
              newName: 'shape'
            }]);
            replaceProperty(RigidBody.prototype, 'RigidBody.prototype', [{
              name: 'rigidBody',
              newName: 'body'
            }]);
            replaceProperty(RigidBody, 'RigidBody', [{
              name: 'ERigidBodyType',
              newName: 'Type'
            }]);
            removeProperty(RigidBody.prototype, 'RigidBody.prototype', [{
              name: 'fixedRotation'
            }]);
            legacyCC.RigidBodyComponent = RigidBody;
            js.setClassAlias(RigidBody, 'cc.RigidBodyComponent');
            legacyCC.ColliderComponent = Collider;
            js.setClassAlias(Collider, 'cc.ColliderComponent');
            legacyCC.BoxColliderComponent = BoxCollider;
            js.setClassAlias(BoxCollider, 'cc.BoxColliderComponent');
            legacyCC.SphereColliderComponent = SphereCollider;
            js.setClassAlias(SphereCollider, 'cc.SphereColliderComponent');
            js.setClassAlias(CapsuleCollider, 'cc.CapsuleColliderComponent');
            js.setClassAlias(MeshCollider, 'cc.MeshColliderComponent');
            js.setClassAlias(CylinderCollider, 'cc.CylinderColliderComponent');
            legacyCC.PhysicMaterial = PhysicsMaterial;
            js.setClassAlias(PhysicsMaterial, 'cc.PhysicMaterial');

            legacyCC.physics = physics;

            var EAmmoSharedBodyDirty;

            (function (EAmmoSharedBodyDirty) {
              EAmmoSharedBodyDirty[EAmmoSharedBodyDirty["BODY_RE_ADD"] = 1] = "BODY_RE_ADD";
              EAmmoSharedBodyDirty[EAmmoSharedBodyDirty["GHOST_RE_ADD"] = 2] = "GHOST_RE_ADD";
            })(EAmmoSharedBodyDirty || (EAmmoSharedBodyDirty = {}));

            var AmmoCollisionFlags;

            (function (AmmoCollisionFlags) {
              AmmoCollisionFlags[AmmoCollisionFlags["CF_STATIC_OBJECT"] = 1] = "CF_STATIC_OBJECT";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_KINEMATIC_OBJECT"] = 2] = "CF_KINEMATIC_OBJECT";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_NO_CONTACT_RESPONSE"] = 4] = "CF_NO_CONTACT_RESPONSE";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_CUSTOM_MATERIAL_CALLBACK"] = 8] = "CF_CUSTOM_MATERIAL_CALLBACK";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_CHARACTER_OBJECT"] = 16] = "CF_CHARACTER_OBJECT";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_DISABLE_VISUALIZE_OBJECT"] = 32] = "CF_DISABLE_VISUALIZE_OBJECT";
              AmmoCollisionFlags[AmmoCollisionFlags["CF_DISABLE_SPU_COLLISION_PROCESSING"] = 64] = "CF_DISABLE_SPU_COLLISION_PROCESSING";
            })(AmmoCollisionFlags || (AmmoCollisionFlags = {}));

            Ammo$1.AmmoCollisionFlags = AmmoCollisionFlags;
            var AmmoCollisionObjectTypes;

            (function (AmmoCollisionObjectTypes) {
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_COLLISION_OBJECT"] = 1] = "CO_COLLISION_OBJECT";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_RIGID_BODY"] = 2] = "CO_RIGID_BODY";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_GHOST_OBJECT"] = 4] = "CO_GHOST_OBJECT";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_SOFT_BODY"] = 8] = "CO_SOFT_BODY";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_HF_FLUID"] = 16] = "CO_HF_FLUID";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_USER_TYPE"] = 32] = "CO_USER_TYPE";
              AmmoCollisionObjectTypes[AmmoCollisionObjectTypes["CO_FEATHERSTONE_LINK"] = 64] = "CO_FEATHERSTONE_LINK";
            })(AmmoCollisionObjectTypes || (AmmoCollisionObjectTypes = {}));

            Ammo$1.AmmoCollisionObjectTypes = AmmoCollisionObjectTypes;
            var AmmoCollisionObjectStates;

            (function (AmmoCollisionObjectStates) {
              AmmoCollisionObjectStates[AmmoCollisionObjectStates["ACTIVE_TAG"] = 1] = "ACTIVE_TAG";
              AmmoCollisionObjectStates[AmmoCollisionObjectStates["ISLAND_SLEEPING"] = 2] = "ISLAND_SLEEPING";
              AmmoCollisionObjectStates[AmmoCollisionObjectStates["WANTS_DEACTIVATION"] = 3] = "WANTS_DEACTIVATION";
              AmmoCollisionObjectStates[AmmoCollisionObjectStates["DISABLE_DEACTIVATION"] = 4] = "DISABLE_DEACTIVATION";
              AmmoCollisionObjectStates[AmmoCollisionObjectStates["DISABLE_SIMULATION"] = 5] = "DISABLE_SIMULATION";
            })(AmmoCollisionObjectStates || (AmmoCollisionObjectStates = {}));

            var AmmoAnisotropicFrictionFlags;

            (function (AmmoAnisotropicFrictionFlags) {
              AmmoAnisotropicFrictionFlags[AmmoAnisotropicFrictionFlags["CF_ANISOTROPIC_FRICTION_DISABLED"] = 0] = "CF_ANISOTROPIC_FRICTION_DISABLED";
              AmmoAnisotropicFrictionFlags[AmmoAnisotropicFrictionFlags["CF_ANISOTROPIC_FRICTION"] = 1] = "CF_ANISOTROPIC_FRICTION";
              AmmoAnisotropicFrictionFlags[AmmoAnisotropicFrictionFlags["CF_ANISOTROPIC_ROLLING_FRICTION"] = 2] = "CF_ANISOTROPIC_ROLLING_FRICTION";
            })(AmmoAnisotropicFrictionFlags || (AmmoAnisotropicFrictionFlags = {}));

            Ammo$1.AmmoAnisotropicFrictionFlags = AmmoAnisotropicFrictionFlags;
            var AmmoRigidBodyFlags;

            (function (AmmoRigidBodyFlags) {
              AmmoRigidBodyFlags[AmmoRigidBodyFlags["BT_DISABLE_WORLD_GRAVITY"] = 1] = "BT_DISABLE_WORLD_GRAVITY";
              AmmoRigidBodyFlags[AmmoRigidBodyFlags["BT_ENABLE_GYROPSCOPIC_FORCE"] = 2] = "BT_ENABLE_GYROPSCOPIC_FORCE";
            })(AmmoRigidBodyFlags || (AmmoRigidBodyFlags = {}));

            Ammo$1.AmmoRigidBodyFlags = AmmoRigidBodyFlags;
            var AmmoBroadphaseNativeTypes;

            (function (AmmoBroadphaseNativeTypes) {
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["BOX_SHAPE_PROXYTYPE"] = 0] = "BOX_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["TRIANGLE_SHAPE_PROXYTYPE"] = 1] = "TRIANGLE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["TETRAHEDRAL_SHAPE_PROXYTYPE"] = 2] = "TETRAHEDRAL_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE"] = 3] = "CONVEX_TRIANGLEMESH_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONVEX_HULL_SHAPE_PROXYTYPE"] = 4] = "CONVEX_HULL_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE"] = 5] = "CONVEX_POINT_CLOUD_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CUSTOM_POLYHEDRAL_SHAPE_TYPE"] = 6] = "CUSTOM_POLYHEDRAL_SHAPE_TYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["IMPLICIT_CONVEX_SHAPES_START_HERE"] = 7] = "IMPLICIT_CONVEX_SHAPES_START_HERE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["SPHERE_SHAPE_PROXYTYPE"] = 8] = "SPHERE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["MULTI_SPHERE_SHAPE_PROXYTYPE"] = 9] = "MULTI_SPHERE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CAPSULE_SHAPE_PROXYTYPE"] = 10] = "CAPSULE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONE_SHAPE_PROXYTYPE"] = 11] = "CONE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONVEX_SHAPE_PROXYTYPE"] = 12] = "CONVEX_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CYLINDER_SHAPE_PROXYTYPE"] = 13] = "CYLINDER_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["UNIFORM_SCALING_SHAPE_PROXYTYPE"] = 14] = "UNIFORM_SCALING_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["MINKOWSKI_SUM_SHAPE_PROXYTYPE"] = 15] = "MINKOWSKI_SUM_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE"] = 16] = "MINKOWSKI_DIFFERENCE_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["BOX_2D_SHAPE_PROXYTYPE"] = 17] = "BOX_2D_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONVEX_2D_SHAPE_PROXYTYPE"] = 18] = "CONVEX_2D_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CUSTOM_CONVEX_SHAPE_TYPE"] = 19] = "CUSTOM_CONVEX_SHAPE_TYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONCAVE_SHAPES_START_HERE"] = 20] = "CONCAVE_SHAPES_START_HERE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["TRIANGLE_MESH_SHAPE_PROXYTYPE"] = 21] = "TRIANGLE_MESH_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE"] = 22] = "SCALED_TRIANGLE_MESH_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["FAST_CONCAVE_MESH_PROXYTYPE"] = 23] = "FAST_CONCAVE_MESH_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["TERRAIN_SHAPE_PROXYTYPE"] = 24] = "TERRAIN_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["GIMPACT_SHAPE_PROXYTYPE"] = 25] = "GIMPACT_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE"] = 26] = "MULTIMATERIAL_TRIANGLE_MESH_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["EMPTY_SHAPE_PROXYTYPE"] = 27] = "EMPTY_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["STATIC_PLANE_PROXYTYPE"] = 28] = "STATIC_PLANE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CUSTOM_CONCAVE_SHAPE_TYPE"] = 29] = "CUSTOM_CONCAVE_SHAPE_TYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["CONCAVE_SHAPES_END_HERE"] = 30] = "CONCAVE_SHAPES_END_HERE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["COMPOUND_SHAPE_PROXYTYPE"] = 31] = "COMPOUND_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["SOFTBODY_SHAPE_PROXYTYPE"] = 32] = "SOFTBODY_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["HFFLUID_SHAPE_PROXYTYPE"] = 33] = "HFFLUID_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE"] = 34] = "HFFLUID_BUOYANT_CONVEX_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["INVALID_SHAPE_PROXYTYPE"] = 35] = "INVALID_SHAPE_PROXYTYPE";
              AmmoBroadphaseNativeTypes[AmmoBroadphaseNativeTypes["MAX_BROADPHASE_COLLISION_TYPES"] = 36] = "MAX_BROADPHASE_COLLISION_TYPES";
            })(AmmoBroadphaseNativeTypes || (AmmoBroadphaseNativeTypes = {}));

            Ammo$1.AmmoBroadphaseNativeTypes = AmmoBroadphaseNativeTypes;
            var AmmoCollisionFilterGroups;

            (function (AmmoCollisionFilterGroups) {
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["DefaultFilter"] = 1] = "DefaultFilter";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["StaticFilter"] = 2] = "StaticFilter";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["KinematicFilter"] = 4] = "KinematicFilter";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["DebrisFilter"] = 8] = "DebrisFilter";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["SensorTrigger"] = 16] = "SensorTrigger";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["CharacterFilter"] = 32] = "CharacterFilter";
              AmmoCollisionFilterGroups[AmmoCollisionFilterGroups["AllFilter"] = -1] = "AllFilter";
            })(AmmoCollisionFilterGroups || (AmmoCollisionFilterGroups = {}));

            Ammo$1.AmmoCollisionFilterGroups = AmmoCollisionFilterGroups;
            var AmmoDispatcherFlags;

            (function (AmmoDispatcherFlags) {
              AmmoDispatcherFlags[AmmoDispatcherFlags["CD_STATIC_STATIC_REPORTED"] = 1] = "CD_STATIC_STATIC_REPORTED";
              AmmoDispatcherFlags[AmmoDispatcherFlags["CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD"] = 2] = "CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD";
              AmmoDispatcherFlags[AmmoDispatcherFlags["CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION"] = 4] = "CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION";
            })(AmmoDispatcherFlags || (AmmoDispatcherFlags = {}));

            Ammo$1.AmmoDispatcherFlags = AmmoDispatcherFlags;

            var TriggerEventObject = {
              type: 'onTriggerEnter',
              selfCollider: null,
              otherCollider: null,
              impl: null
            };
            var CollisionEventObject = {
              type: 'onCollisionEnter',
              selfCollider: null,
              otherCollider: null,
              contacts: [],
              impl: null
            };
            var AmmoConstant = function () {
              function AmmoConstant() {
                this.EMPTY_SHAPE = new Ammo$1.btEmptyShape();
                this.TRANSFORM = new Ammo$1.btTransform();
                this.TRANSFORM_1 = new Ammo$1.btTransform();
                this.VECTOR3_0 = new Ammo$1.btVector3();
                this.VECTOR3_1 = new Ammo$1.btVector3();
                this.QUAT_0 = new Ammo$1.btQuaternion();
              }

              _createClass(AmmoConstant, null, [{
                key: "instance",
                get: function get() {
                  if (AmmoConstant._instance == null) AmmoConstant._instance = new AmmoConstant();
                  return AmmoConstant._instance;
                }
              }]);

              return AmmoConstant;
            }();
            AmmoConstant._instance = void 0;
            var CC_V3_0 = new Vec3();
            var CC_V3_1 = new Vec3();
            var CC_QUAT_0 = new Quat();

            var v3_0 = CC_V3_0;
            var v3_1$5 = CC_V3_1;
            var AmmoRigidBody = function () {
              var _proto = AmmoRigidBody.prototype;

              _proto.setMass = function setMass(value) {
                if (!this._rigidBody.isDynamic) return;
                var localInertia = AmmoConstant.instance.VECTOR3_0;
                localInertia.setValue(1.6666666269302368, 1.6666666269302368, 1.6666666269302368);
                var shape = this.impl.getCollisionShape();

                if (shape.isCompound()) {
                  if (this._sharedBody.bodyCompoundShape.getNumChildShapes() > 0) {
                    shape.calculateLocalInertia(this._rigidBody.mass, localInertia);
                  }
                } else {
                  shape.calculateLocalInertia(this._rigidBody.mass, localInertia);
                }

                this.impl.setMassProps(value, localInertia);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
              };

              _proto.setType = function setType(v) {
                var m_bcf = this.impl.getCollisionFlags();

                var m_gcf = this._sharedBody.ghost.getCollisionFlags();

                var localInertia = AmmoConstant.instance.VECTOR3_0;

                switch (v) {
                  case ERigidBodyType.DYNAMIC:
                    m_bcf &= ~AmmoCollisionFlags.CF_KINEMATIC_OBJECT;
                    m_bcf &= ~AmmoCollisionFlags.CF_STATIC_OBJECT;
                    this.impl.setCollisionFlags(m_bcf);
                    this.setMass(this._rigidBody.mass);
                    this.useGravity(this._rigidBody.useGravity);
                    this.setAllowSleep(this._rigidBody.allowSleep);
                    m_gcf &= ~AmmoCollisionFlags.CF_STATIC_OBJECT;
                    m_gcf |= AmmoCollisionFlags.CF_KINEMATIC_OBJECT;

                    this._sharedBody.ghost.setCollisionFlags(m_gcf);

                    break;

                  case ERigidBodyType.KINEMATIC:
                    localInertia.setValue(0, 0, 0);
                    this.impl.setMassProps(0, localInertia);
                    m_bcf |= AmmoCollisionFlags.CF_KINEMATIC_OBJECT;
                    m_bcf &= ~AmmoCollisionFlags.CF_STATIC_OBJECT;
                    this.impl.setCollisionFlags(m_bcf);
                    this.impl.forceActivationState(AmmoCollisionObjectStates.DISABLE_DEACTIVATION);
                    m_gcf |= AmmoCollisionFlags.CF_KINEMATIC_OBJECT;
                    m_gcf &= ~AmmoCollisionFlags.CF_STATIC_OBJECT;

                    this._sharedBody.ghost.setCollisionFlags(m_gcf);

                    break;

                  case ERigidBodyType.STATIC:
                  default:
                    localInertia.setValue(0, 0, 0);
                    this.impl.setMassProps(0, localInertia);
                    m_bcf |= AmmoCollisionFlags.CF_STATIC_OBJECT;
                    m_bcf &= ~AmmoCollisionFlags.CF_KINEMATIC_OBJECT;
                    this.impl.setCollisionFlags(m_bcf);
                    this.impl.forceActivationState(AmmoCollisionObjectStates.DISABLE_DEACTIVATION);
                    m_gcf &= ~AmmoCollisionFlags.CF_KINEMATIC_OBJECT;
                    m_gcf |= AmmoCollisionFlags.CF_STATIC_OBJECT;

                    this._sharedBody.ghost.setCollisionFlags(m_gcf);

                    break;
                }

                this._sharedBody.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
                this._sharedBody.dirty |= EAmmoSharedBodyDirty.GHOST_RE_ADD;
              };

              _proto.setLinearDamping = function setLinearDamping(value) {
                this.impl.setDamping(this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              };

              _proto.setAngularDamping = function setAngularDamping(value) {
                this.impl.setDamping(this._rigidBody.linearDamping, this._rigidBody.angularDamping);
              };

              _proto.useGravity = function useGravity(value) {
                if (!this._rigidBody.isDynamic) return;
                var m_rigidBodyFlag = this.impl.getFlags();

                if (value) {
                  m_rigidBodyFlag &= ~AmmoRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                } else {
                  this.impl.setGravity(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, Vec3.ZERO));
                  m_rigidBodyFlag |= AmmoRigidBodyFlags.BT_DISABLE_WORLD_GRAVITY;
                }

                this.impl.setFlags(m_rigidBodyFlag);

                this._wakeUpIfSleep();

                this._sharedBody.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
              };

              _proto.setLinearFactor = function setLinearFactor(value) {
                this.impl.setLinearFactor(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, value));

                this._wakeUpIfSleep();
              };

              _proto.setAngularFactor = function setAngularFactor(value) {
                this.impl.setAngularFactor(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, value));

                this._wakeUpIfSleep();
              };

              _proto.setAllowSleep = function setAllowSleep(v) {
                if (!this._rigidBody.isDynamic) return;

                if (v) {
                  this.impl.forceActivationState(AmmoCollisionObjectStates.ACTIVE_TAG);
                } else {
                  this.impl.forceActivationState(AmmoCollisionObjectStates.DISABLE_DEACTIVATION);
                }

                this._wakeUpIfSleep();
              };

              _createClass(AmmoRigidBody, [{
                key: "isAwake",
                get: function get() {
                  var state = this.impl.getActivationState();
                  return state === AmmoCollisionObjectStates.ACTIVE_TAG || state === AmmoCollisionObjectStates.DISABLE_DEACTIVATION;
                }
              }, {
                key: "isSleepy",
                get: function get() {
                  var state = this.impl.getActivationState();
                  return state === AmmoCollisionObjectStates.WANTS_DEACTIVATION;
                }
              }, {
                key: "isSleeping",
                get: function get() {
                  var state = this.impl.getActivationState();
                  return state === AmmoCollisionObjectStates.ISLAND_SLEEPING;
                }
              }, {
                key: "isEnabled",
                get: function get() {
                  return this._isEnabled;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._sharedBody.body;
                }
              }, {
                key: "rigidBody",
                get: function get() {
                  return this._rigidBody;
                }
              }, {
                key: "sharedBody",
                get: function get() {
                  return this._sharedBody;
                }
              }]);

              function AmmoRigidBody() {
                this.id = void 0;
                this._isEnabled = false;
                this.id = AmmoRigidBody.idCounter++;
              }

              _proto.clearState = function clearState() {
                this.impl.clearState();
              };

              _proto.clearVelocity = function clearVelocity() {
                this.setLinearVelocity(Vec3.ZERO);
                this.setAngularVelocity(Vec3.ZERO);
              };

              _proto.clearForces = function clearForces() {
                this.impl.clearForces();
              };

              _proto.initialize = function initialize(com) {
                this._rigidBody = com;
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._rigidBody.node, this);
                this._sharedBody.reference = true;
              };

              _proto.onEnable = function onEnable() {
                this._isEnabled = true;
                this.setMass(this._rigidBody.mass);
                this.setType(this._rigidBody.type);
                this.setAllowSleep(this._rigidBody.allowSleep);
                this.setLinearDamping(this._rigidBody.linearDamping);
                this.setAngularDamping(this._rigidBody.angularDamping);
                this.setLinearFactor(this._rigidBody.linearFactor);
                this.setAngularFactor(this._rigidBody.angularFactor);
                this.useGravity(this._rigidBody.useGravity);
                this._sharedBody.bodyEnabled = true;
              };

              _proto.onDisable = function onDisable() {
                this._isEnabled = false;
                this._sharedBody.bodyEnabled = false;
              };

              _proto.onDestroy = function onDestroy() {
                this._sharedBody.reference = false;
                this._rigidBody = null;
                this._sharedBody = null;
              };

              _proto.wakeUp = function wakeUp(force) {
                if (force === void 0) {
                  force = true;
                }

                this.impl.activate(force);
              };

              _proto.sleep = function sleep() {
                return this.impl.wantsSleeping();
              };

              _proto.setSleepThreshold = function setSleepThreshold(v) {
                this._wakeUpIfSleep();

                this.impl.setSleepingThresholds(v, v);
              };

              _proto.getSleepThreshold = function getSleepThreshold() {
                return this.impl.getLinearSleepingThreshold();
              };

              _proto.getLinearVelocity = function getLinearVelocity(out) {
                return ammo2CocosVec3(out, this.impl.getLinearVelocity());
              };

              _proto.setLinearVelocity = function setLinearVelocity(value) {
                this._wakeUpIfSleep();

                cocos2AmmoVec3(this.impl.getLinearVelocity(), value);
              };

              _proto.getAngularVelocity = function getAngularVelocity(out) {
                return ammo2CocosVec3(out, this.impl.getAngularVelocity());
              };

              _proto.setAngularVelocity = function setAngularVelocity(value) {
                this._wakeUpIfSleep();

                cocos2AmmoVec3(this.impl.getAngularVelocity(), value);
              };

              _proto.applyLocalForce = function applyLocalForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var quat = this._sharedBody.node.worldRotation;
                var v = Vec3.transformQuat(v3_0, force, quat);
                var rp = rel_pos ? Vec3.transformQuat(v3_1$5, rel_pos, quat) : Vec3.ZERO;
                this.impl.applyForce(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, v), cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_1, rp));
              };

              _proto.applyLocalTorque = function applyLocalTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                Vec3.transformQuat(v3_0, torque, this._sharedBody.node.worldRotation);
                this.impl.applyTorque(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, v3_0));
              };

              _proto.applyLocalImpulse = function applyLocalImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var quat = this._sharedBody.node.worldRotation;
                var v = Vec3.transformQuat(v3_0, impulse, quat);
                var rp = rel_pos ? Vec3.transformQuat(v3_1$5, rel_pos, quat) : Vec3.ZERO;
                this.impl.applyImpulse(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, v), cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_1, rp));
              };

              _proto.applyForce = function applyForce(force, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var rp = rel_pos || Vec3.ZERO;
                this.impl.applyForce(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, force), cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_1, rp));
              };

              _proto.applyTorque = function applyTorque(torque) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                this.impl.applyTorque(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, torque));
              };

              _proto.applyImpulse = function applyImpulse(impulse, rel_pos) {
                this._sharedBody.syncSceneToPhysics();

                this._wakeUpIfSleep();

                var rp = rel_pos || Vec3.ZERO;
                this.impl.applyImpulse(cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_0, impulse), cocos2AmmoVec3(AmmoConstant.instance.VECTOR3_1, rp));
              };

              _proto.getGroup = function getGroup() {
                return this._sharedBody.collisionFilterGroup;
              };

              _proto.setGroup = function setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              };

              _proto.addGroup = function addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              };

              _proto.removeGroup = function removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              };

              _proto.getMask = function getMask() {
                return this._sharedBody.collisionFilterMask;
              };

              _proto.setMask = function setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              };

              _proto.addMask = function addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              };

              _proto.removeMask = function removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              };

              _proto._wakeUpIfSleep = function _wakeUpIfSleep() {
                if (!this.isAwake) this.impl.activate(true);
              };

              return AmmoRigidBody;
            }();
            AmmoRigidBody.idCounter = 0;

            var AmmoInstance = function () {
              function AmmoInstance() {}

              _createClass(AmmoInstance, null, [{
                key: "bodyStructs",
                get: function get() {
                  return this.bodyAndGhosts;
                }
              }, {
                key: "ghostStructs",
                get: function get() {
                  return this.bodyAndGhosts;
                }
              }]);

              return AmmoInstance;
            }();
            AmmoInstance.bodyAndGhosts = {};

            var v3_0$1 = CC_V3_0;
            var quat_0 = CC_QUAT_0;
            var sharedIDCounter = 0;
            var AmmoSharedBody = function () {
              AmmoSharedBody.getSharedBody = function getSharedBody(node, wrappedWorld, wrappedBody) {
                var key = node.uuid;
                var newSB;

                if (AmmoSharedBody.sharedBodesMap.has(key)) {
                  newSB = AmmoSharedBody.sharedBodesMap.get(key);
                } else {
                  newSB = new AmmoSharedBody(node, wrappedWorld);
                  var g = PhysicsGroup.DEFAULT;
                  var m = PhysicsSystem.instance.collisionMatrix[g];
                  newSB._collisionFilterGroup = g;
                  newSB._collisionFilterMask = m;
                  AmmoSharedBody.sharedBodesMap.set(node.uuid, newSB);
                }

                if (wrappedBody) {
                  newSB._wrappedBody = wrappedBody;
                  var _g = wrappedBody.rigidBody.group;
                  var _m = PhysicsSystem.instance.collisionMatrix[_g];
                  newSB._collisionFilterGroup = _g;
                  newSB._collisionFilterMask = _m;
                }

                return newSB;
              };

              _createClass(AmmoSharedBody, [{
                key: "wrappedBody",
                get: function get() {
                  return this._wrappedBody;
                }
              }, {
                key: "bodyCompoundShape",
                get: function get() {
                  return this.bodyStruct.shape;
                }
              }, {
                key: "ghostCompoundShape",
                get: function get() {
                  return this.ghostStruct.shape;
                }
              }, {
                key: "body",
                get: function get() {
                  return this.bodyStruct.body;
                }
              }, {
                key: "ghost",
                get: function get() {
                  return this.ghostStruct.ghost;
                }
              }, {
                key: "collisionFilterGroup",
                get: function get() {
                  return this._collisionFilterGroup;
                },
                set: function set(v) {
                  if (v !== this._collisionFilterGroup) {
                    this._collisionFilterGroup = v;
                    this.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
                    this.dirty |= EAmmoSharedBodyDirty.GHOST_RE_ADD;
                  }
                }
              }, {
                key: "collisionFilterMask",
                get: function get() {
                  return this._collisionFilterMask;
                },
                set: function set(v) {
                  if (v !== this._collisionFilterMask) {
                    this._collisionFilterMask = v;
                    this.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
                    this.dirty |= EAmmoSharedBodyDirty.GHOST_RE_ADD;
                  }
                }
              }, {
                key: "bodyStruct",
                get: function get() {
                  this._instantiateBodyStruct();

                  return this._bodyStruct;
                }
              }, {
                key: "ghostStruct",
                get: function get() {
                  this._instantiateGhostStruct();

                  return this._ghostStruct;
                }
              }, {
                key: "bodyEnabled",
                set: function set(v) {
                  if (v) {
                    if (this.bodyIndex < 0) {
                      this.bodyIndex = this.wrappedWorld.bodies.length;
                      this.body.clearState();
                      this.wrappedWorld.addSharedBody(this);
                      this.syncInitialBody();
                    }
                  } else if (this.bodyIndex >= 0) {
                    var isRemoveBody = this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody == null || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.isEnabled || this.bodyStruct.wrappedShapes.length === 0 && this.wrappedBody != null && !this.wrappedBody.rigidBody.enabledInHierarchy;

                    if (isRemoveBody) {
                      this.body.clearState();
                      this.bodyIndex = -1;
                      this.wrappedWorld.removeSharedBody(this);
                    }
                  }
                }
              }, {
                key: "ghostEnabled",
                set: function set(v) {
                  if (v) {
                    if (this.ghostIndex < 0 && this.ghostStruct.wrappedShapes.length > 0) {
                      this.ghostIndex = 1;
                      this.wrappedWorld.addGhostObject(this);
                      this.syncInitialGhost();
                    }
                  } else if (this.ghostIndex >= 0) {
                    var isRemoveGhost = this.ghostStruct.wrappedShapes.length === 0 && this.ghost;

                    if (isRemoveGhost) {
                      this.ghostIndex = -1;
                      this.wrappedWorld.removeGhostObject(this);
                    }
                  }
                }
              }, {
                key: "reference",
                set: function set(v) {
                  v ? this.ref++ : this.ref--;

                  if (this.ref === 0) {
                    this.destroy();
                  }
                }
              }]);

              function AmmoSharedBody(node, wrappedWorld) {
                this.id = void 0;
                this.node = void 0;
                this.wrappedWorld = void 0;
                this.wrappedJoints0 = [];
                this.wrappedJoints1 = [];
                this.dirty = 0;
                this._collisionFilterGroup = PhysicsSystem.PhysicsGroup.DEFAULT;
                this._collisionFilterMask = -1;
                this.ref = 0;
                this.bodyIndex = -1;
                this.ghostIndex = -1;
                this._wrappedBody = null;
                this.id = AmmoSharedBody.idCounter++;
                this.wrappedWorld = wrappedWorld;
                this.node = node;
              }

              var _proto = AmmoSharedBody.prototype;

              _proto._instantiateBodyStruct = function _instantiateBodyStruct() {
                if (this._bodyStruct) return;
                var st = new Ammo$1.btTransform();
                st.setIdentity();
                cocos2AmmoVec3(st.getOrigin(), this.node.worldPosition);
                var bodyQuat = new Ammo$1.btQuaternion();
                cocos2AmmoQuat(bodyQuat, this.node.worldRotation);
                st.setRotation(bodyQuat);
                var motionState = new Ammo$1.btDefaultMotionState(st);
                var localInertia = new Ammo$1.btVector3(1.6666666269302368, 1.6666666269302368, 1.6666666269302368);
                var bodyShape = new Ammo$1.btCompoundShape();
                var mass = 0;
                if (this._wrappedBody && this._wrappedBody.rigidBody.isDynamic) mass = this._wrappedBody.rigidBody.mass;
                if (mass === 0) localInertia.setValue(0, 0, 0);
                var rbInfo = new Ammo$1.btRigidBodyConstructionInfo(mass, motionState, AmmoConstant.instance.EMPTY_SHAPE, localInertia);
                var body = new Ammo$1.btRigidBody(rbInfo);
                var sleepTd = PhysicsSystem.instance.sleepThreshold;
                body.setSleepingThresholds(sleepTd, sleepTd);
                this._bodyStruct = {
                  id: sharedIDCounter++,
                  body: body,
                  localInertia: localInertia,
                  motionState: motionState,
                  startTransform: st,
                  shape: bodyShape,
                  rbInfo: rbInfo,
                  worldQuat: bodyQuat,
                  wrappedShapes: [],
                  useCompound: false
                };
                AmmoInstance.bodyStructs["KEY" + this._bodyStruct.id] = this._bodyStruct;
                this.body.setUserIndex2(2);
                this.body.setUserIndex(this._bodyStruct.id);
                if (mass === 0) this.body.setActivationState(AmmoCollisionObjectStates.DISABLE_DEACTIVATION);
                if (Ammo$1.CC_CONFIG.ignoreSelfBody && this._ghostStruct) this.ghost.setIgnoreCollisionCheck(this.body, true);
              };

              _proto._instantiateGhostStruct = function _instantiateGhostStruct() {
                if (this._ghostStruct) return;
                var ghost = new Ammo$1.btCollisionObject();
                var ghostShape = new Ammo$1.btCompoundShape();
                ghost.setCollisionShape(ghostShape);
                ghost.setCollisionFlags(AmmoCollisionFlags.CF_STATIC_OBJECT | AmmoCollisionFlags.CF_NO_CONTACT_RESPONSE);
                this._ghostStruct = {
                  id: sharedIDCounter++,
                  ghost: ghost,
                  shape: ghostShape,
                  worldQuat: new Ammo$1.btQuaternion(),
                  wrappedShapes: []
                };
                AmmoInstance.ghostStructs["KEY" + this._ghostStruct.id] = this._ghostStruct;
                this.ghost.setUserIndex2(2);
                this.ghost.setUserIndex(this._ghostStruct.id);
                this.ghost.setActivationState(AmmoCollisionObjectStates.DISABLE_DEACTIVATION);
                if (Ammo$1.CC_CONFIG.ignoreSelfBody && this._bodyStruct) this.ghost.setIgnoreCollisionCheck(this.body, true);
              };

              _proto.addShape = function addShape(v, isTrigger) {
                function switchShape(that, shape) {
                  that.body.setCollisionShape(shape);
                  that.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;

                  if (that._wrappedBody && that._wrappedBody.isEnabled) {
                    that._wrappedBody.setMass(that._wrappedBody.rigidBody.mass);
                  }
                }

                if (isTrigger) {
                  var index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index < 0) {
                    this.ghostStruct.wrappedShapes.push(v);
                    v.setCompound(this.ghostCompoundShape);
                    this.ghostEnabled = true;
                  }
                } else {
                  var _index = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (_index < 0) {
                    this.bodyStruct.wrappedShapes.push(v);

                    if (this.bodyStruct.useCompound) {
                      v.setCompound(this.bodyCompoundShape);
                    } else {
                      var l = this.bodyStruct.wrappedShapes.length;

                      if (l === 1 && !v.needCompound()) {
                        switchShape(this, v.impl);
                      } else {
                        this.bodyStruct.useCompound = true;

                        for (var i = 0; i < l; i++) {
                          var childShape = this.bodyStruct.wrappedShapes[i];
                          childShape.setCompound(this.bodyCompoundShape);
                        }

                        switchShape(this, this.bodyStruct.shape);
                      }
                    }

                    this.bodyEnabled = true;
                  }
                }
              };

              _proto.removeShape = function removeShape(v, isTrigger) {
                if (isTrigger) {
                  var index = this.ghostStruct.wrappedShapes.indexOf(v);

                  if (index >= 0) {
                    fastRemoveAt(this.ghostStruct.wrappedShapes, index);
                    v.setCompound(null);
                    this.ghostEnabled = false;
                  }
                } else {
                  var _index2 = this.bodyStruct.wrappedShapes.indexOf(v);

                  if (_index2 >= 0) {
                    if (this.bodyStruct.useCompound) {
                      v.setCompound(null);
                    } else {
                      this.body.setCollisionShape(AmmoConstant.instance.EMPTY_SHAPE);
                    }

                    this.body.activate(true);
                    this.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
                    fastRemoveAt(this.bodyStruct.wrappedShapes, _index2);
                    this.bodyEnabled = false;
                  }
                }
              };

              _proto.addJoint = function addJoint(v, type) {
                if (type) {
                  var i = this.wrappedJoints1.indexOf(v);
                  if (i < 0) this.wrappedJoints1.push(v);
                } else {
                  var _i = this.wrappedJoints0.indexOf(v);

                  if (_i < 0) this.wrappedJoints0.push(v);
                }
              };

              _proto.removeJoint = function removeJoint(v, type) {
                if (type) {
                  var i = this.wrappedJoints1.indexOf(v);
                  if (i >= 0) fastRemoveAt(this.wrappedJoints1, i);
                } else {
                  var _i2 = this.wrappedJoints0.indexOf(v);

                  if (_i2 >= 0) fastRemoveAt(this.wrappedJoints0, _i2);
                }
              };

              _proto.updateDirty = function updateDirty() {
                if (this.dirty) {
                  if (this.bodyIndex >= 0 && this.dirty & EAmmoSharedBodyDirty.BODY_RE_ADD) this.updateBodyByReAdd();
                  if (this.ghostIndex >= 0 && this.dirty & EAmmoSharedBodyDirty.GHOST_RE_ADD) this.updateGhostByReAdd();
                  this.dirty = 0;
                }
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                if (this.node.hasChangedFlags) {
                  var wt = this.body.getWorldTransform();
                  cocos2AmmoVec3(wt.getOrigin(), this.node.worldPosition);
                  cocos2AmmoQuat(this.bodyStruct.worldQuat, this.node.worldRotation);
                  wt.setRotation(this.bodyStruct.worldQuat);

                  if (this.node.hasChangedFlags & TransformBit.SCALE) {
                    this.syncBodyScale();
                  }

                  if (this.body.isKinematicObject()) {
                    var ms = this.body.getMotionState();
                    if (ms) ms.setWorldTransform(wt);
                  } else if (this.isBodySleeping()) this.body.activate();
                }
              };

              _proto.syncPhysicsToScene = function syncPhysicsToScene() {
                if (this.body.isStaticOrKinematicObject() || this.isBodySleeping()) {
                  return;
                }

                var wt0 = this.bodyStruct.startTransform;
                this.body.getMotionState().getWorldTransform(wt0);
                this.node.worldPosition = ammo2CocosVec3(v3_0$1, wt0.getOrigin());
                wt0.getBasis().getRotation(this.bodyStruct.worldQuat);
                this.node.worldRotation = ammo2CocosQuat(quat_0, this.bodyStruct.worldQuat);
                var wt1 = this.ghost.getWorldTransform();
                cocos2AmmoVec3(wt1.getOrigin(), this.node.worldPosition);
                cocos2AmmoQuat(this.ghostStruct.worldQuat, this.node.worldRotation);
                wt1.setRotation(this.ghostStruct.worldQuat);
              };

              _proto.syncSceneToGhost = function syncSceneToGhost() {
                if (this.node.hasChangedFlags) {
                  var wt1 = this.ghost.getWorldTransform();
                  cocos2AmmoVec3(wt1.getOrigin(), this.node.worldPosition);
                  cocos2AmmoQuat(this.ghostStruct.worldQuat, this.node.worldRotation);
                  wt1.setRotation(this.ghostStruct.worldQuat);
                  if (this.node.hasChangedFlags & TransformBit.SCALE) this.syncGhostScale();
                  this.ghost.activate();
                }
              };

              _proto.syncInitialBody = function syncInitialBody() {
                var wt = this.body.getWorldTransform();
                cocos2AmmoVec3(wt.getOrigin(), this.node.worldPosition);
                cocos2AmmoQuat(this.bodyStruct.worldQuat, this.node.worldRotation);
                wt.setRotation(this.bodyStruct.worldQuat);
                this.syncBodyScale();
                this.body.activate();
              };

              _proto.syncInitialGhost = function syncInitialGhost() {
                var wt1 = this.ghost.getWorldTransform();
                cocos2AmmoVec3(wt1.getOrigin(), this.node.worldPosition);
                cocos2AmmoQuat(this.ghostStruct.worldQuat, this.node.worldRotation);
                wt1.setRotation(this.ghostStruct.worldQuat);
                this.syncGhostScale();
                this.ghost.activate();
              };

              _proto.syncBodyScale = function syncBodyScale() {
                for (var i = 0; i < this.bodyStruct.wrappedShapes.length; i++) {
                  this.bodyStruct.wrappedShapes[i].setScale();
                }

                for (var _i3 = 0; _i3 < this.wrappedJoints0.length; _i3++) {
                  this.wrappedJoints0[_i3].updateScale0();
                }

                for (var _i4 = 0; _i4 < this.wrappedJoints1.length; _i4++) {
                  this.wrappedJoints1[_i4].updateScale1();
                }
              };

              _proto.syncGhostScale = function syncGhostScale() {
                for (var i = 0; i < this.ghostStruct.wrappedShapes.length; i++) {
                  this.ghostStruct.wrappedShapes[i].setScale();
                }
              };

              _proto.updateBodyByReAdd = function updateBodyByReAdd() {
                if (this.bodyIndex >= 0) {
                  this.wrappedWorld.removeSharedBody(this);
                  this.bodyIndex = this.wrappedWorld.bodies.length;
                  this.wrappedWorld.addSharedBody(this);
                }
              };

              _proto.updateGhostByReAdd = function updateGhostByReAdd() {
                if (this.ghostIndex >= 0) {
                  this.wrappedWorld.removeGhostObject(this);
                  this.ghostIndex = this.wrappedWorld.ghosts.length;
                  this.wrappedWorld.addGhostObject(this);
                }
              };

              _proto.destroy = function destroy() {
                AmmoSharedBody.sharedBodesMap["delete"](this.node.uuid);
                this.node = null;
                this.wrappedWorld = null;

                if (this._bodyStruct) {
                  var bodyStruct = this._bodyStruct;
                  Ammo$1.destroy(bodyStruct.localInertia);
                  Ammo$1.destroy(bodyStruct.worldQuat);
                  Ammo$1.destroy(bodyStruct.startTransform);
                  Ammo$1.destroy(bodyStruct.motionState);
                  Ammo$1.destroy(bodyStruct.rbInfo);
                  Ammo$1.destroy(bodyStruct.shape);
                  ammoDeletePtr(bodyStruct.shape, Ammo$1.btCollisionShape);
                  var body = Ammo$1.castObject(bodyStruct.body, Ammo$1.btRigidBody);
                  body.wrapped = null;
                  ammoDeletePtr(bodyStruct.body, Ammo$1.btRigidBody);
                  ammoDeletePtr(bodyStruct.body, Ammo$1.btCollisionObject);
                  var key0 = "KEY" + bodyStruct.id;
                  delete AmmoInstance.bodyStructs[key0];
                  this._bodyStruct = null;
                }

                if (this._ghostStruct) {
                  var ghostStruct = this._ghostStruct;
                  Ammo$1.destroy(ghostStruct.worldQuat);
                  Ammo$1.destroy(ghostStruct.shape);
                  ammoDeletePtr(ghostStruct.shape, Ammo$1.btCollisionShape);
                  Ammo$1.destroy(ghostStruct.ghost);
                  var key1 = "KEY" + ghostStruct.id;
                  delete AmmoInstance.bodyStructs[key1];
                  this._ghostStruct = null;
                }
              };

              _proto.isBodySleeping = function isBodySleeping() {
                var state = this.body.getActivationState();
                return state === AmmoCollisionObjectStates.ISLAND_SLEEPING;
              };

              return AmmoSharedBody;
            }();
            AmmoSharedBody.idCounter = 0;
            AmmoSharedBody.sharedBodesMap = new Map();

            var ArrayCollisionMatrix = function () {
              function ArrayCollisionMatrix() {
                this.matrix = [];
              }

              var _proto = ArrayCollisionMatrix.prototype;

              _proto.get = function get(i, j) {
                if (j > i) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                return this.matrix[(i * (i + 1) >> 1) + j - 1];
              };

              _proto.set = function set(i, j, value) {
                if (j > i) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                this.matrix[(i * (i + 1) >> 1) + j - 1] = value ? 1 : 0;
              };

              _proto.reset = function reset() {
                this.matrix.length = 0;
              };

              _proto.setNumObjects = function setNumObjects(n) {
                this.matrix.length = n * (n - 1) >> 1;
              };

              return ArrayCollisionMatrix;
            }();

            var TupleDictionary = function () {
              function TupleDictionary() {
                this.data = void 0;
                this.data = {
                  keys: []
                };
              }

              var _proto = TupleDictionary.prototype;

              _proto.get = function get(i, j) {
                if (i > j) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                return this.data[i + "-" + j];
              };

              _proto.set = function set(i, j, value) {
                if (i > j) {
                  var temp = j;
                  j = i;
                  i = temp;
                }

                var key = i + "-" + j;

                if (value == null) {
                  var idx = this.data.keys.indexOf(key);

                  if (idx !== -1) {
                    this.data.keys.splice(idx, 1);
                    delete this.data[key];
                    return value;
                  }
                }

                if (!this.get(i, j)) {
                  this.data.keys.push(key);
                }

                this.data[key] = value;
                return this.data[key];
              };

              _proto.reset = function reset() {
                this.data = {
                  keys: []
                };
              };

              _proto.getLength = function getLength() {
                return this.data.keys.length;
              };

              _proto.getKeyByIndex = function getKeyByIndex(index) {
                return this.data.keys[index];
              };

              _proto.getDataByKey = function getDataByKey(Key) {
                return this.data[Key];
              };

              return TupleDictionary;
            }();

            var AmmoContactEquation = function () {
              _createClass(AmmoContactEquation, [{
                key: "isBodyA",
                get: function get() {
                  var sb = this.event.selfCollider.shape.sharedBody.body;
                  var b0 = this.event.impl.getBody0();
                  return Ammo.compare(b0, sb);
                }
              }]);

              function AmmoContactEquation(event) {
                this.impl = null;
                this.event = void 0;
                this.event = event;
              }

              var _proto = AmmoContactEquation.prototype;

              _proto.getLocalPointOnA = function getLocalPointOnA(out) {
                if (this.impl) ammo2CocosVec3(out, this.impl.m_localPointA);
              };

              _proto.getLocalPointOnB = function getLocalPointOnB(out) {
                if (this.impl) ammo2CocosVec3(out, this.impl.m_localPointB);
              };

              _proto.getWorldPointOnA = function getWorldPointOnA(out) {
                if (this.impl) ammo2CocosVec3(out, this.impl.m_positionWorldOnA);
              };

              _proto.getWorldPointOnB = function getWorldPointOnB(out) {
                if (this.impl) ammo2CocosVec3(out, this.impl.m_positionWorldOnB);
              };

              _proto.getLocalNormalOnA = function getLocalNormalOnA(out) {
                if (this.impl) {
                  ammo2CocosVec3(out, this.impl.m_normalWorldOnB);
                  if (!this.isBodyA) Vec3.negate(out, out);
                  var inv_rot = CC_QUAT_0;
                  var bt_rot = AmmoConstant.instance.QUAT_0;
                  var body = this.event.impl.getBody0();
                  body.getWorldTransform().getBasis().getRotation(bt_rot);
                  ammo2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  Vec3.transformQuat(out, out, inv_rot);
                }
              };

              _proto.getLocalNormalOnB = function getLocalNormalOnB(out) {
                if (this.impl) {
                  var inv_rot = CC_QUAT_0;
                  var bt_rot = AmmoConstant.instance.QUAT_0;
                  var body = this.event.impl.getBody1();
                  body.getWorldTransform().getBasis().getRotation(bt_rot);
                  ammo2CocosQuat(inv_rot, bt_rot);
                  Quat.conjugate(inv_rot, inv_rot);
                  ammo2CocosVec3(out, this.impl.m_normalWorldOnB);
                  Vec3.transformQuat(out, out, inv_rot);
                }
              };

              _proto.getWorldNormalOnA = function getWorldNormalOnA(out) {
                if (this.impl) {
                  ammo2CocosVec3(out, this.impl.m_normalWorldOnB);
                  if (!this.isBodyA) Vec3.negate(out, out);
                }
              };

              _proto.getWorldNormalOnB = function getWorldNormalOnB(out) {
                if (this.impl) ammo2CocosVec3(out, this.impl.m_normalWorldOnB);
              };

              return AmmoContactEquation;
            }();

            var contactsPool = [];
            var v3_0$2 = CC_V3_0;
            var v3_1$6 = CC_V3_1;
            var AmmoWorld = function () {
              var _proto = AmmoWorld.prototype;

              _proto.setAllowSleep = function setAllowSleep(v) {};

              _proto.setDefaultMaterial = function setDefaultMaterial(v) {};

              _proto.setGravity = function setGravity(gravity) {
                var TMP = AmmoConstant.instance.VECTOR3_0;
                cocos2AmmoVec3(TMP, gravity);

                this._btWorld.setGravity(TMP);
              };

              _createClass(AmmoWorld, [{
                key: "impl",
                get: function get() {
                  return this._btWorld;
                }
              }]);

              function AmmoWorld(options) {
                this._btWorld = void 0;
                this._btBroadphase = void 0;
                this._btSolver = void 0;
                this._btDispatcher = void 0;
                this._btCollisionConfiguration = void 0;
                this.bodies = [];
                this.ghosts = [];
                this.constraints = [];
                this.triggerArrayMat = new ArrayCollisionMatrix();
                this.collisionArrayMat = new ArrayCollisionMatrix();
                this.contactsDic = new TupleDictionary();
                this.oldContactsDic = new TupleDictionary();
                this._btCollisionConfiguration = new Ammo$1.btDefaultCollisionConfiguration();
                this._btDispatcher = new Ammo$1.btCollisionDispatcher(this._btCollisionConfiguration);
                this._btBroadphase = new Ammo$1.btDbvtBroadphase();
                this._btSolver = new Ammo$1.btSequentialImpulseConstraintSolver();
                this._btWorld = new Ammo$1.btDiscreteDynamicsWorld(this._btDispatcher, this._btBroadphase, this._btSolver, this._btCollisionConfiguration);

                this._btWorld.getPairCache().setOverlapFilterCallback(new Ammo$1.ccOverlapFilterCallback());

                var TMP = AmmoConstant.instance.VECTOR3_0;
                TMP.setValue(0, -10, 0);

                this._btWorld.setGravity(TMP);

                if (!AmmoWorld.closeHitCB) AmmoWorld.closeHitCB = new Ammo$1.ClosestRayResultCallback(TMP, TMP);
                if (!AmmoWorld.allHitsCB) AmmoWorld.allHitsCB = new Ammo$1.AllHitsRayResultCallback(TMP, TMP);
                AmmoWorld.closeHitCB.setUseCC(true);
                AmmoWorld.allHitsCB.setUseCC(true);
              }

              _proto.destroy = function destroy() {
                if (this.constraints.length || this.bodies.length) error('You should destroy all physics component first.');
                Ammo$1.destroy(this._btWorld);
                Ammo$1.destroy(this._btSolver);
                Ammo$1.destroy(this._btBroadphase);
                Ammo$1.destroy(this._btDispatcher);
                Ammo$1.destroy(this._btCollisionConfiguration);
                this._btCollisionConfiguration = null;
                this._btDispatcher = null;
                this._btBroadphase = null;
                this._btSolver = null;
                this._btWorld = null;
                this.bodies = null;
                this.ghosts = null;
                this.constraints = null;
                this.triggerArrayMat = null;
                this.collisionArrayMat = null;
                this.contactsDic = null;
                this.oldContactsDic = null;
                contactsPool.length = 0;
              };

              _proto.step = function step(deltaTime, timeSinceLastCalled, maxSubStep) {
                if (maxSubStep === void 0) {
                  maxSubStep = 0;
                }

                if (this.bodies.length === 0 && this.ghosts.length === 0) return;
                if (timeSinceLastCalled === undefined) timeSinceLastCalled = deltaTime;

                this._btWorld.stepSimulation(timeSinceLastCalled, maxSubStep, deltaTime);

                for (var i = 0; i < this.bodies.length; i++) {
                  this.bodies[i].syncPhysicsToScene();
                }
              };

              _proto.syncSceneToPhysics = function syncSceneToPhysics() {
                for (var i = 0; i < this.ghosts.length; i++) {
                  this.ghosts[i].updateDirty();
                  this.ghosts[i].syncSceneToGhost();
                }

                for (var _i = 0; _i < this.bodies.length; _i++) {
                  this.bodies[_i].updateDirty();

                  this.bodies[_i].syncSceneToPhysics();
                }
              };

              _proto.syncAfterEvents = function syncAfterEvents() {
                this.syncSceneToPhysics();
              };

              _proto.raycast = function raycast(worldRay, options, pool, results) {
                var allHitsCB = AmmoWorld.allHitsCB;
                var from = cocos2AmmoVec3(allHitsCB.m_rayFromWorld, worldRay.o);
                worldRay.computeHit(v3_0$2, options.maxDistance);
                var to = cocos2AmmoVec3(allHitsCB.m_rayToWorld, v3_0$2);
                allHitsCB.m_collisionFilterGroup = -1;
                allHitsCB.m_collisionFilterMask = options.mask;
                allHitsCB.m_closestHitFraction = 1;
                allHitsCB.m_shapePart = -1;
                allHitsCB.m_collisionObject = null;
                allHitsCB.m_shapeParts.clear();
                allHitsCB.m_hitFractions.clear();
                allHitsCB.m_collisionObjects.clear();
                var hp = allHitsCB.m_hitPointWorld;
                var hn = allHitsCB.m_hitNormalWorld;
                hp.clear();
                hn.clear();

                this._btWorld.rayTest(from, to, allHitsCB);

                if (allHitsCB.hasHit()) {
                  for (var i = 0, n = allHitsCB.m_collisionObjects.size(); i < n; i++) {
                    var btObj = allHitsCB.m_collisionObjects.at(i);
                    var btCs = btObj.getCollisionShape();
                    var shape = void 0;

                    if (btCs.isCompound()) {
                      var shapeIndex = allHitsCB.m_shapeParts.at(i);
                      var index = btObj.getUserIndex();
                      var shared = AmmoInstance.bodyAndGhosts["KEY" + index];
                      shape = shared.wrappedShapes[shapeIndex];
                    } else {
                      shape = btCs.wrapped;
                    }

                    ammo2CocosVec3(v3_0$2, hp.at(i));
                    ammo2CocosVec3(v3_1$6, hn.at(i));
                    var distance = Vec3.distance(worldRay.o, v3_0$2);
                    var r = pool.add();

                    r._assign(v3_0$2, distance, shape.collider, v3_1$6);

                    results.push(r);
                  }

                  return true;
                }

                return false;
              };

              _proto.raycastClosest = function raycastClosest(worldRay, options, result) {
                var closeHitCB = AmmoWorld.closeHitCB;
                var from = cocos2AmmoVec3(closeHitCB.m_rayFromWorld, worldRay.o);
                worldRay.computeHit(v3_0$2, options.maxDistance);
                var to = cocos2AmmoVec3(closeHitCB.m_rayToWorld, v3_0$2);
                closeHitCB.m_collisionFilterGroup = -1;
                closeHitCB.m_collisionFilterMask = options.mask;
                closeHitCB.m_closestHitFraction = 1;
                closeHitCB.m_collisionObject = null;

                this._btWorld.rayTest(from, to, closeHitCB);

                if (closeHitCB.hasHit()) {
                  var btObj = closeHitCB.m_collisionObject;
                  var btCs = btObj.getCollisionShape();
                  var shape;

                  if (btCs.isCompound()) {
                    var index = btObj.getUserIndex();
                    var shared = AmmoInstance.bodyAndGhosts["KEY" + index];
                    var shapeIndex = closeHitCB.m_shapePart;
                    shape = shared.wrappedShapes[shapeIndex];
                  } else {
                    shape = btCs.wrapped;
                  }

                  ammo2CocosVec3(v3_0$2, closeHitCB.m_hitPointWorld);
                  ammo2CocosVec3(v3_1$6, closeHitCB.m_hitNormalWorld);
                  var distance = Vec3.distance(worldRay.o, v3_0$2);

                  result._assign(v3_0$2, distance, shape.collider, v3_1$6);

                  return true;
                }

                return false;
              };

              _proto.getSharedBody = function getSharedBody(node, wrappedBody) {
                return AmmoSharedBody.getSharedBody(node, this, wrappedBody);
              };

              _proto.addSharedBody = function addSharedBody(sharedBody) {
                var i = this.bodies.indexOf(sharedBody);

                if (i < 0) {
                  this.bodies.push(sharedBody);

                  this._btWorld.addRigidBody(sharedBody.body, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              };

              _proto.removeSharedBody = function removeSharedBody(sharedBody) {
                var i = this.bodies.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.bodies, i);

                  this._btWorld.removeRigidBody(sharedBody.body);
                }
              };

              _proto.addGhostObject = function addGhostObject(sharedBody) {
                var i = this.ghosts.indexOf(sharedBody);

                if (i < 0) {
                  this.ghosts.push(sharedBody);

                  this._btWorld.addCollisionObject(sharedBody.ghost, sharedBody.collisionFilterGroup, sharedBody.collisionFilterMask);
                }
              };

              _proto.removeGhostObject = function removeGhostObject(sharedBody) {
                var i = this.ghosts.indexOf(sharedBody);

                if (i >= 0) {
                  fastRemoveAt(this.ghosts, i);

                  this._btWorld.removeCollisionObject(sharedBody.ghost);
                }
              };

              _proto.addConstraint = function addConstraint(constraint) {
                var i = this.constraints.indexOf(constraint);

                if (i < 0) {
                  this.constraints.push(constraint);

                  this._btWorld.addConstraint(constraint.impl, !constraint.constraint.enableCollision);

                  constraint.index = i;
                }
              };

              _proto.removeConstraint = function removeConstraint(constraint) {
                var i = this.constraints.indexOf(constraint);

                if (i >= 0) {
                  this.constraints.splice(i, 1);

                  this._btWorld.removeConstraint(constraint.impl);

                  constraint.index = -1;
                }
              };

              _proto.emitEvents = function emitEvents() {
                var numManifolds = this._btDispatcher.getNumManifolds();

                for (var i = 0; i < numManifolds; i++) {
                  var manifold = this._btDispatcher.getManifoldByIndexInternal(i);

                  var body0 = manifold.getBody0();
                  var body1 = manifold.getBody1();

                  if (body0.useCharacter || body1.useCharacter) {
                    continue;
                  }

                  var isUseCCD = body0.useCCD || body1.useCCD;
                  var numContacts = manifold.getNumContacts();

                  for (var j = 0; j < numContacts; j++) {
                    var manifoldPoint = manifold.getContactPoint(j);
                    var s0 = manifoldPoint.getShape0();
                    var s1 = manifoldPoint.getShape1();
                    var shape0 = void 0;
                    var shape1 = void 0;

                    if (isUseCCD) {
                      if (body0.useCCD) {
                        var asb = body0.wrapped.sharedBody;
                        if (!asb) continue;
                        shape0 = asb.bodyStruct.wrappedShapes[0];
                      } else {
                        var btShape0 = body0.getCollisionShape();

                        if (btShape0.isCompound()) {
                          continue;
                        } else {
                          shape0 = btShape0.wrapped;
                        }
                      }

                      if (body1.useCCD) {
                        var _asb = body1.wrapped.sharedBody;
                        if (!_asb) continue;
                        shape1 = _asb.bodyStruct.wrappedShapes[0];
                      } else {
                        var btShape1 = body1.getCollisionShape();

                        if (btShape1.isCompound()) {
                          continue;
                        } else {
                          shape1 = btShape1.wrapped;
                        }
                      }
                    } else {
                      if (s0.isCompound()) {
                        var com = Ammo$1.castObject(s0, Ammo$1.btCompoundShape);
                        shape0 = com.getChildShape(manifoldPoint.m_index0).wrapped;
                      } else {
                        shape0 = s0.wrapped;
                      }

                      if (s1.isCompound()) {
                        var _com = Ammo$1.castObject(s1, Ammo$1.btCompoundShape);

                        shape1 = _com.getChildShape(manifoldPoint.m_index1).wrapped;
                      } else {
                        shape1 = s1.wrapped;
                      }
                    }

                    if (shape0.collider.needTriggerEvent || shape1.collider.needTriggerEvent || shape0.collider.needCollisionEvent || shape1.collider.needCollisionEvent) {
                      var item = this.contactsDic.get(shape0.id, shape1.id);

                      if (item == null) {
                        item = this.contactsDic.set(shape0.id, shape1.id, {
                          shape0: shape0,
                          shape1: shape1,
                          contacts: [],
                          impl: manifold
                        });
                      }

                      item.contacts.push(manifoldPoint);
                    }
                  }
                }

                var dicL = this.contactsDic.getLength();

                while (dicL--) {
                  contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                  CollisionEventObject.contacts.length = 0;
                  var key = this.contactsDic.getKeyByIndex(dicL);
                  var data = this.contactsDic.getDataByKey(key);
                  var _shape = data.shape0;
                  var _shape2 = data.shape1;
                  this.oldContactsDic.set(_shape.id, _shape2.id, data);
                  var collider0 = _shape.collider;
                  var collider1 = _shape2.collider;

                  if (collider0 && collider1) {
                    var isTrigger = collider0.isTrigger || collider1.isTrigger;

                    if (isTrigger) {
                      if (this.triggerArrayMat.get(_shape.id, _shape2.id)) {
                        TriggerEventObject.type = 'onTriggerStay';
                      } else {
                        TriggerEventObject.type = 'onTriggerEnter';
                        this.triggerArrayMat.set(_shape.id, _shape2.id, true);
                      }

                      TriggerEventObject.impl = data.impl;
                      TriggerEventObject.selfCollider = collider0;
                      TriggerEventObject.otherCollider = collider1;
                      collider0.emit(TriggerEventObject.type, TriggerEventObject);
                      TriggerEventObject.selfCollider = collider1;
                      TriggerEventObject.otherCollider = collider0;
                      collider1.emit(TriggerEventObject.type, TriggerEventObject);
                    } else {
                      var _body = collider0.attachedRigidBody;
                      var _body2 = collider1.attachedRigidBody;

                      if (_body && _body2) {
                        if (_body.isSleeping && _body2.isSleeping) continue;
                      } else if (_body == null && _body2) {
                        if (_body2.isSleeping) continue;
                      } else if (_body2 == null && _body) {
                        if (_body.isSleeping) continue;
                      }

                      if (this.collisionArrayMat.get(_shape.id, _shape2.id)) {
                        CollisionEventObject.type = 'onCollisionStay';
                      } else {
                        CollisionEventObject.type = 'onCollisionEnter';
                        this.collisionArrayMat.set(_shape.id, _shape2.id, true);
                      }

                      for (var _i2 = 0; _i2 < data.contacts.length; _i2++) {
                        var cq = data.contacts[_i2];

                        if (contactsPool.length > 0) {
                          var c = contactsPool.pop();
                          c.impl = cq;
                          CollisionEventObject.contacts.push(c);
                        } else {
                          var _c = new AmmoContactEquation(CollisionEventObject);

                          _c.impl = cq;
                          CollisionEventObject.contacts.push(_c);
                        }
                      }

                      CollisionEventObject.impl = data.impl;
                      CollisionEventObject.selfCollider = collider0;
                      CollisionEventObject.otherCollider = collider1;
                      collider0.emit(CollisionEventObject.type, CollisionEventObject);
                      CollisionEventObject.selfCollider = collider1;
                      CollisionEventObject.otherCollider = collider0;
                      collider1.emit(CollisionEventObject.type, CollisionEventObject);
                    }

                    if (this.oldContactsDic.get(_shape.id, _shape2.id) == null) {
                      this.oldContactsDic.set(_shape.id, _shape2.id, data);
                    }
                  }
                }

                var oldDicL = this.oldContactsDic.getLength();

                while (oldDicL--) {
                  var _key = this.oldContactsDic.getKeyByIndex(oldDicL);

                  var _data = this.oldContactsDic.getDataByKey(_key);

                  var _shape3 = _data.shape0;
                  var _shape4 = _data.shape1;
                  var _collider = _shape3.collider;
                  var _collider2 = _shape4.collider;

                  if (_collider && _collider2) {
                    var _isTrigger = _collider.isTrigger || _collider2.isTrigger;

                    if (this.contactsDic.getDataByKey(_key) == null) {
                      if (_isTrigger) {
                        if (this.triggerArrayMat.get(_shape3.id, _shape4.id)) {
                          TriggerEventObject.type = 'onTriggerExit';
                          TriggerEventObject.selfCollider = _collider;
                          TriggerEventObject.otherCollider = _collider2;

                          _collider.emit(TriggerEventObject.type, TriggerEventObject);

                          TriggerEventObject.selfCollider = _collider2;
                          TriggerEventObject.otherCollider = _collider;

                          _collider2.emit(TriggerEventObject.type, TriggerEventObject);

                          this.triggerArrayMat.set(_shape3.id, _shape4.id, false);
                          this.oldContactsDic.set(_shape3.id, _shape4.id, null);
                        }
                      } else if (this.collisionArrayMat.get(_shape3.id, _shape4.id)) {
                        contactsPool.push.apply(contactsPool, CollisionEventObject.contacts);
                        CollisionEventObject.contacts.length = 0;
                        CollisionEventObject.type = 'onCollisionExit';
                        CollisionEventObject.selfCollider = _collider;
                        CollisionEventObject.otherCollider = _collider2;

                        _collider.emit(CollisionEventObject.type, CollisionEventObject);

                        CollisionEventObject.selfCollider = _collider2;
                        CollisionEventObject.otherCollider = _collider;

                        _collider2.emit(CollisionEventObject.type, CollisionEventObject);

                        this.collisionArrayMat.set(_shape3.id, _shape4.id, false);
                        this.oldContactsDic.set(_shape3.id, _shape4.id, null);
                      }
                    }
                  }
                }

                this.contactsDic.reset();
              };

              return AmmoWorld;
            }();
            AmmoWorld.closeHitCB = void 0;
            AmmoWorld.allHitsCB = void 0;

            var v3_0$3 = CC_V3_0;
            var AmmoShape = function () {
              var _proto = AmmoShape.prototype;

              _proto.updateEventListener = function updateEventListener() {};

              _proto.setMaterial = function setMaterial(v) {
                if (!this._isTrigger && this._isEnabled && v) {
                  if (this._btCompound) {
                    this._btCompound.setMaterial(this._index, v.friction, v.restitution, v.rollingFriction, v.spinningFriction, 2);
                  } else {
                    this._sharedBody.body.setFriction(v.friction);

                    this._sharedBody.body.setRestitution(v.restitution);

                    this._sharedBody.body.setRollingFriction(v.rollingFriction);

                    this._sharedBody.body.setSpinningFriction(v.spinningFriction);

                    this._sharedBody.body.setUserIndex2(2);
                  }
                }
              };

              _proto.setCenter = function setCenter(v) {
                Vec3.copy(v3_0$3, v);
                v3_0$3.multiply(this._collider.node.worldScale);
                cocos2AmmoVec3(this.transform.getOrigin(), v3_0$3);
                this.updateCompoundTransform();
              };

              _proto.setAsTrigger = function setAsTrigger(v) {
                if (this._isTrigger === v) {
                  return;
                }

                if (this._isEnabled) {
                  this._sharedBody.removeShape(this, !v);

                  this._sharedBody.addShape(this, v);
                }

                this._isTrigger = v;
              };

              _createClass(AmmoShape, [{
                key: "attachedRigidBody",
                get: function get() {
                  if (this._sharedBody.wrappedBody) {
                    return this._sharedBody.wrappedBody.rigidBody;
                  }

                  return null;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "sharedBody",
                get: function get() {
                  return this._sharedBody;
                }
              }, {
                key: "index",
                get: function get() {
                  return this._index;
                }
              }]);

              function AmmoShape(type) {
                this.id = void 0;
                this.type = void 0;
                this._index = -1;
                this._isEnabled = false;
                this._isBinding = false;
                this._isTrigger = false;
                this._btCompound = null;
                this.transform = void 0;
                this.quat = void 0;
                this.scale = void 0;
                this.type = type;
                this.id = AmmoShape.idCounter++;
                this.quat = new Ammo$1.btQuaternion();
                this.transform = new Ammo$1.btTransform();
                this.transform.setIdentity();
                this.scale = new Ammo$1.btVector3(1, 1, 1);
              }

              _proto.getAABB = function getAABB(v) {
                var TRANS = AmmoConstant.instance.TRANSFORM;
                TRANS.setIdentity();
                TRANS.setRotation(cocos2AmmoQuat(AmmoConstant.instance.QUAT_0, this._collider.node.worldRotation));
                var MIN = AmmoConstant.instance.VECTOR3_0;
                var MAX = AmmoConstant.instance.VECTOR3_1;

                this._btShape.getAabb(TRANS, MIN, MAX);

                v.halfExtents.set((MAX.x() - MIN.x()) / 2, (MAX.y() - MIN.y()) / 2, (MAX.z() - MIN.z()) / 2);
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              };

              _proto.getBoundingSphere = function getBoundingSphere(v) {
                v.radius = this._btShape.getLocalBoundingSphere();
                Vec3.add(v.center, this._collider.node.worldPosition, this._collider.center);
              };

              _proto.initialize = function initialize(com) {
                this._collider = com;
                this._isBinding = true;
                this.onComponentSet();
                this.setWrapper();
                this._sharedBody = PhysicsSystem.instance.physicsWorld.getSharedBody(this._collider.node);
                this._sharedBody.reference = true;
              };

              _proto.onComponentSet = function onComponentSet() {};

              _proto.onLoad = function onLoad() {
                this.setCenter(this._collider.center);
                this.setAsTrigger(this._collider.isTrigger);
              };

              _proto.onEnable = function onEnable() {
                this._isEnabled = true;

                this._sharedBody.addShape(this, this._isTrigger);

                this.setMaterial(this.collider.sharedMaterial);
              };

              _proto.onDisable = function onDisable() {
                this._isEnabled = false;

                this._sharedBody.removeShape(this, this._isTrigger);
              };

              _proto.onDestroy = function onDestroy() {
                this._sharedBody.reference = false;
                this._btCompound = null;
                this._collider = null;
                var shape = Ammo$1.castObject(this._btShape, Ammo$1.btCollisionShape);
                shape.wrapped = null;
                Ammo$1.destroy(this.quat);
                Ammo$1.destroy(this.scale);
                Ammo$1.destroy(this.transform);

                if (this._btShape !== AmmoConstant.instance.EMPTY_SHAPE) {
                  Ammo$1.destroy(this._btShape);
                  ammoDeletePtr(this._btShape, Ammo$1.btCollisionShape);
                }

                this._btShape = null;
                this.transform = null;
                this.quat = null;
                this.scale = null;
              };

              _proto.getGroup = function getGroup() {
                return this._sharedBody.collisionFilterGroup;
              };

              _proto.setGroup = function setGroup(v) {
                this._sharedBody.collisionFilterGroup = v;
              };

              _proto.addGroup = function addGroup(v) {
                this._sharedBody.collisionFilterGroup |= v;
              };

              _proto.removeGroup = function removeGroup(v) {
                this._sharedBody.collisionFilterGroup &= ~v;
              };

              _proto.getMask = function getMask() {
                return this._sharedBody.collisionFilterMask;
              };

              _proto.setMask = function setMask(v) {
                this._sharedBody.collisionFilterMask = v;
              };

              _proto.addMask = function addMask(v) {
                this._sharedBody.collisionFilterMask |= v;
              };

              _proto.removeMask = function removeMask(v) {
                this._sharedBody.collisionFilterMask &= ~v;
              };

              _proto.setCompound = function setCompound(compound) {
                if (this._btCompound) {
                  this._btCompound.removeChildShape(this._btShape);

                  this._index = -1;
                }

                if (compound) {
                  this._index = compound.getNumChildShapes();
                  compound.addChildShape(this.transform, this._btShape);
                }

                this._btCompound = compound;
              };

              _proto.setWrapper = function setWrapper() {
                var shape = Ammo$1.castObject(this._btShape, Ammo$1.btCollisionShape);
                shape.wrapped = this;
              };

              _proto.setScale = function setScale() {
                this.setCenter(this._collider.center);
              };

              _proto.updateCompoundTransform = function updateCompoundTransform() {
                if (this._btCompound) {
                  this._btCompound.updateChildTransform(this.index, this.transform, true);
                } else if (this._isEnabled && !this._isTrigger) {
                  if (this._sharedBody && !this._sharedBody.bodyStruct.useCompound) {
                    this._sharedBody.dirty |= EAmmoSharedBodyDirty.BODY_RE_ADD;
                  }
                }
              };

              _proto.needCompound = function needCompound() {
                if (this.type === AmmoBroadphaseNativeTypes.TERRAIN_SHAPE_PROXYTYPE) {
                  return true;
                }

                if (this._collider.center.equals(Vec3.ZERO)) {
                  return false;
                }

                return true;
              };

              _proto.debugTransform = function debugTransform(n) {
                if (AmmoShape._debugTransform == null) {
                  AmmoShape._debugTransform = new Ammo$1.btTransform();
                }

                var wt;

                if (this._isTrigger) {
                  wt = this._sharedBody.ghost.getWorldTransform();
                } else {
                  wt = this._sharedBody.body.getWorldTransform();
                }

                var lt = this.transform;

                AmmoShape._debugTransform.setIdentity();

                AmmoShape._debugTransform.op_mul(wt).op_mul(lt);

                var origin = AmmoShape._debugTransform.getOrigin();

                n.worldPosition = new Vec3(origin.x(), origin.y(), origin.z());

                var rotation = AmmoShape._debugTransform.getRotation();

                n.worldRotation = new Quat(rotation.x(), rotation.y(), rotation.z(), rotation.w());
                var scale = this.impl.getLocalScaling();
                n.scale = new Vec3(scale.x(), scale.y(), scale.z());
              };

              return AmmoShape;
            }();
            AmmoShape.idCounter = 0;
            AmmoShape._debugTransform = void 0;

            var AmmoBoxShape = function (_AmmoShape) {
              _inheritsLoose(AmmoBoxShape, _AmmoShape);

              var _proto = AmmoBoxShape.prototype;

              _proto.setSize = function setSize(size) {
                var v3_0 = CC_V3_0;
                Vec3.multiplyScalar(v3_0, size, 0.5);
                var hf = AmmoConstant.instance.VECTOR3_0;
                cocos2AmmoVec3(hf, v3_0);
                this.impl.setUnscaledHalfExtents(hf);
                this.updateCompoundTransform();
              };

              _createClass(AmmoBoxShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoBoxShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.BOX_SHAPE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                var s = this.collider.size;
                var hf = AmmoConstant.instance.VECTOR3_0;
                hf.setValue(s.x / 2, s.y / 2, s.z / 2);
                this._btShape = new Ammo$1.btBoxShape(hf);
                this.setScale();
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);

                this.updateCompoundTransform();
              };

              return AmmoBoxShape;
            }(AmmoShape);

            var AmmoSphereShape = function (_AmmoShape) {
              _inheritsLoose(AmmoSphereShape, _AmmoShape);

              var _proto = AmmoSphereShape.prototype;

              _proto.setRadius = function setRadius(radius) {
                this.impl.setUnscaledRadius(radius);
                this.updateCompoundTransform();
              };

              _createClass(AmmoSphereShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoSphereShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.SPHERE_SHAPE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this._btShape = new Ammo$1.btSphereShape(this.collider.radius);
                this.setScale();
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                var v3_0 = CC_V3_0;
                var ws = this._collider.node.worldScale;
                var absX = Math.abs(ws.x);
                var absY = Math.abs(ws.y);
                var absZ = Math.abs(ws.z);
                var max_sp = Math.max(Math.max(absX, absY), absZ);
                v3_0.set(max_sp, max_sp, max_sp);
                cocos2AmmoVec3(this.scale, v3_0);

                this._btShape.setLocalScaling(this.scale);

                this.updateCompoundTransform();
              };

              return AmmoSphereShape;
            }(AmmoShape);

            var AmmoCapsuleShape = function (_AmmoShape) {
              _inheritsLoose(AmmoCapsuleShape, _AmmoShape);

              var _proto = AmmoCapsuleShape.prototype;

              _proto.setCylinderHeight = function setCylinderHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.cylinderHeight, this.collider.direction, this._collider.node.worldScale);
              };

              _createClass(AmmoCapsuleShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoCapsuleShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.CAPSULE_SHAPE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this._btShape = new Ammo$1.btCapsuleShape(0.5, 1);
                this.setRadius(this.collider.radius);
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;

                if (upAxis === 1) {
                  var wr = radius * Math.abs(absMax(ws.x, ws.z));
                  var halfH = height / 2 * Math.abs(ws.y);
                  this.impl.updateProp(wr, halfH, upAxis);
                } else if (upAxis === 0) {
                  var _wr = radius * Math.abs(absMax(ws.y, ws.z));

                  var _halfH = height / 2 * Math.abs(ws.x);

                  this.impl.updateProp(_wr, _halfH, upAxis);
                } else {
                  var _wr2 = radius * Math.abs(absMax(ws.x, ws.y));

                  var _halfH2 = height / 2 * Math.abs(ws.z);

                  this.impl.updateProp(_wr2, _halfH2, upAxis);
                }

                this.updateCompoundTransform();
              };

              return AmmoCapsuleShape;
            }(AmmoShape);

            var AmmoTrimeshShape = function (_AmmoShape) {
              _inheritsLoose(AmmoTrimeshShape, _AmmoShape);

              var _proto = AmmoTrimeshShape.prototype;

              _proto.setMesh = function setMesh(v) {
                if (!this._isBinding) return;

                if (this._btShape != null && this._btShape !== AmmoConstant.instance.EMPTY_SHAPE) {
                  warnID(9620);
                } else {
                  var mesh = v;

                  if (mesh && mesh.renderingSubMeshes.length > 0) {
                    var _btTriangleMesh = this._getBtTriangleMesh(mesh);

                    if (this.collider.convex) {
                      this._btShape = new Ammo$1.btConvexTriangleMeshShape(_btTriangleMesh, true);
                    } else {
                      this._btShape = new Ammo$1.btBvhTriangleMeshShape(_btTriangleMesh, true, true);
                    }

                    cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                    this._btShape.setMargin(0.01);

                    this._btShape.setLocalScaling(this.scale);

                    this.setWrapper();
                    this.setCompound(this._btCompound);
                  } else {
                    this._btShape = AmmoConstant.instance.EMPTY_SHAPE;
                  }
                }
              };

              _createClass(AmmoTrimeshShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }]);

              function AmmoTrimeshShape() {
                var _this;

                _this = _AmmoShape.call(this, AmmoBroadphaseNativeTypes.TRIANGLE_MESH_SHAPE_PROXYTYPE) || this;
                _this.refBtTriangleMesh = null;
                return _this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this.setMesh(this.collider.mesh);
              };

              _proto.onDestroy = function onDestroy() {
                if (this.refBtTriangleMesh) {
                  Ammo$1.destroy(this.refBtTriangleMesh);
                }

                _AmmoShape.prototype.onDestroy.call(this);
              };

              _proto.setCompound = function setCompound(compound) {
                _AmmoShape.prototype.setCompound.call(this, compound);

                this.impl.setUserIndex(this._index);
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);

                this.updateCompoundTransform();
              };

              _proto._getBtTriangleMesh = function _getBtTriangleMesh(mesh) {
                var btTriangleMesh;
                var cache = Ammo$1.CC_CACHE;

                if (cache.btTriangleMesh.enable) {
                  if (cache.btTriangleMesh[mesh._uuid] == null) {
                    var btm = new Ammo$1.btTriangleMesh();
                    cache.btTriangleMesh[mesh._uuid] = btm;
                    cocos2AmmoTriMesh(btm, mesh);
                  }

                  btTriangleMesh = cache.btTriangleMesh[mesh._uuid];
                } else {
                  this.refBtTriangleMesh = btTriangleMesh = new Ammo$1.btTriangleMesh();
                  cocos2AmmoTriMesh(btTriangleMesh, mesh);
                }

                return btTriangleMesh;
              };

              return AmmoTrimeshShape;
            }(AmmoShape);

            var AmmoCylinderShape = function (_AmmoShape) {
              _inheritsLoose(AmmoCylinderShape, _AmmoShape);

              var _proto = AmmoCylinderShape.prototype;

              _proto.setHeight = function setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _createClass(AmmoCylinderShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoCylinderShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.CYLINDER_SHAPE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                var hf = AmmoConstant.instance.VECTOR3_0;
                hf.setValue(0.5, 1, 0.5);
                this._btShape = new Ammo$1.btCylinderShape(hf);
                this.setRadius(this.collider.radius);
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;

                if (upAxis === 1) {
                  var wh = height * Math.abs(ws.y);
                  var wr = radius * Math.abs(absMax(ws.x, ws.z));
                  var halfH = wh / 2;
                  this.impl.updateProp(wr, halfH, upAxis);
                } else if (upAxis === 0) {
                  var _wh = height * Math.abs(ws.x);

                  var _wr = radius * Math.abs(absMax(ws.y, ws.z));

                  var _halfH = _wh / 2;

                  this.impl.updateProp(_wr, _halfH, upAxis);
                } else {
                  var _wh2 = height * Math.abs(ws.z);

                  var _wr2 = radius * Math.abs(absMax(ws.x, ws.y));

                  var _halfH2 = _wh2 / 2;

                  this.impl.updateProp(_wr2, _halfH2, upAxis);
                }

                this.updateCompoundTransform();
              };

              return AmmoCylinderShape;
            }(AmmoShape);

            var AmmoConeShape = function (_AmmoShape) {
              _inheritsLoose(AmmoConeShape, _AmmoShape);

              var _proto = AmmoConeShape.prototype;

              _proto.setHeight = function setHeight(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setDirection = function setDirection(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _proto.setRadius = function setRadius(v) {
                this.updateProperties(this.collider.radius, this.collider.height, this.collider.direction, this._collider.node.worldScale);
              };

              _createClass(AmmoConeShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoConeShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.CONE_SHAPE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this._btShape = new Ammo$1.btConeShape(0.5, 1);
                this.setRadius(this.collider.radius);
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                this.setRadius(this.collider.radius);
              };

              _proto.updateProperties = function updateProperties(radius, height, direction, scale) {
                var ws = scale;
                var upAxis = direction;

                if (upAxis === 1) {
                  var wh = height * Math.abs(ws.y);
                  var wr = radius * Math.abs(absMax(ws.x, ws.z));
                  this.impl.setRadius(wr);
                  this.impl.setHeight(wh);
                } else if (upAxis === 0) {
                  var _wh = height * Math.abs(ws.x);

                  var _wr = radius * Math.abs(absMax(ws.y, ws.z));

                  this.impl.setRadius(_wr);
                  this.impl.setHeight(_wh);
                } else {
                  var _wh2 = height * Math.abs(ws.z);

                  var _wr2 = radius * Math.abs(absMax(ws.x, ws.y));

                  this.impl.setRadius(_wr2);
                  this.impl.setHeight(_wh2);
                }

                this.impl.setConeUpIndex(upAxis);
                this.scale.setValue(1, 1, 1);
                this.impl.setLocalScaling(this.scale);
                this.updateCompoundTransform();
              };

              return AmmoConeShape;
            }(AmmoShape);

            var AmmoTerrainShape = function (_AmmoShape) {
              _inheritsLoose(AmmoTerrainShape, _AmmoShape);

              var _proto = AmmoTerrainShape.prototype;

              _proto.setTerrain = function setTerrain(v) {
                if (!this._isBinding) return;

                if (this._btShape != null && this._btShape !== AmmoConstant.instance.EMPTY_SHAPE) {
                  warn('[Physics] Ammo change the terrain asset after initialization is not support.');
                } else {
                  var terrain = v;

                  if (terrain) {
                    this._terrainID = terrain._uuid;
                    this._tileSize = terrain.tileSize;
                    var sizeI = terrain.getVertexCountI();
                    var sizeJ = terrain.getVertexCountJ();
                    this._buffPtr = Ammo$1._malloc(4 * sizeI * sizeJ);
                    var offset = 0;
                    var maxHeight = Number.MIN_VALUE;
                    var minHeight = Number.MAX_VALUE;

                    for (var j = 0; j < sizeJ; j++) {
                      for (var i = 0; i < sizeI; i++) {
                        var _v = terrain.getHeight(i, j);

                        Ammo$1.HEAPF32[this._buffPtr + offset >> 2] = _v;
                        maxHeight = maxHeight < _v ? _v : maxHeight;
                        minHeight = minHeight > _v ? _v : minHeight;
                        offset += 4;
                      }
                    }

                    maxHeight += 0.1;
                    minHeight -= 0.1;

                    this._localOffset.set((sizeI - 1) / 2 * this._tileSize, (maxHeight + minHeight) / 2, (sizeJ - 1) / 2 * this._tileSize);

                    var heightScale = 1;
                    var hdt = 'PHY_FLOAT';
                    var upAxis = 1;
                    var flipQuadEdges = false;
                    this._btShape = new Ammo$1.btHeightfieldTerrainShape(sizeI, sizeJ, this._buffPtr, heightScale, minHeight, maxHeight, upAxis, hdt, flipQuadEdges);
                    this.scale.setValue(this._tileSize, 1, this._tileSize);

                    this._btShape.setLocalScaling(this.scale);
                  } else {
                    this._btShape = AmmoConstant.instance.EMPTY_SHAPE;
                  }
                }
              };

              _createClass(AmmoTerrainShape, [{
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }, {
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }]);

              function AmmoTerrainShape() {
                var _this;

                _this = _AmmoShape.call(this, AmmoBroadphaseNativeTypes.TERRAIN_SHAPE_PROXYTYPE) || this;
                _this._terrainID = void 0;
                _this._buffPtr = void 0;
                _this._tileSize = void 0;
                _this._localOffset = void 0;
                _this._terrainID = '';
                _this._buffPtr = 0;
                _this._tileSize = 0;
                _this._localOffset = new Vec3();
                return _this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this.setTerrain(this.collider.terrain);
              };

              _proto.onDestroy = function onDestroy() {
                if (this._buffPtr) Ammo$1._free(this._buffPtr);

                _AmmoShape.prototype.onDestroy.call(this);
              };

              _proto.setCompound = function setCompound(compound) {
                _AmmoShape.prototype.setCompound.call(this, compound);

                this.impl.setUserIndex(this._index);
              };

              _proto.setCenter = function setCenter(v) {
                Vec3.copy(CC_V3_0, v);
                CC_V3_0.add(this._localOffset);
                cocos2AmmoVec3(this.transform.getOrigin(), CC_V3_0);
                this.updateCompoundTransform();
              };

              return AmmoTerrainShape;
            }(AmmoShape);

            var AmmoSimplexShape = function (_AmmoShape) {
              _inheritsLoose(AmmoSimplexShape, _AmmoShape);

              var _proto = AmmoSimplexShape.prototype;

              _proto.setShapeType = function setShapeType(v) {
                if (this._isBinding) ;
              };

              _proto.setVertices = function setVertices(v) {
                var length = this.VERTICES.length;

                for (var i = 0; i < length; i++) {
                  cocos2AmmoVec3(this.VERTICES[i], v[i]);
                }

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);

                if (this._btCompound) {
                  this._btCompound.updateChildTransform(this.index, this.transform, true);
                }
              };

              _createClass(AmmoSimplexShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoSimplexShape() {
                var _this;

                _this = _AmmoShape.call(this, AmmoBroadphaseNativeTypes.TETRAHEDRAL_SHAPE_PROXYTYPE) || this;
                _this.VERTICES = [];
                return _this;
              }

              _proto.onComponentSet = function onComponentSet() {
                this._btShape = new Ammo$1.btBU_Simplex1to4();
                var length = this.collider.shapeType;
                var vertices = this.collider.vertices;

                for (var i = 0; i < length; i++) {
                  this.VERTICES[i] = new Ammo$1.btVector3();
                  cocos2AmmoVec3(this.VERTICES[i], vertices[i]);
                  this.impl.addVertex(this.VERTICES[i]);
                }

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);
              };

              _proto.onLoad = function onLoad() {
                _AmmoShape.prototype.onLoad.call(this);

                this.collider.updateVertices();
              };

              _proto.onDestroy = function onDestroy() {
                var length = this.VERTICES.length;

                for (var i = 0; i < length; i++) {
                  Ammo$1.destroy(this.VERTICES[i]);
                }

                this.VERTICES = null;

                _AmmoShape.prototype.onDestroy.call(this);
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);

                if (this._btCompound) {
                  this._btCompound.updateChildTransform(this.index, this.transform, true);
                }
              };

              return AmmoSimplexShape;
            }(AmmoShape);

            var AmmoPlaneShape = function (_AmmoShape) {
              _inheritsLoose(AmmoPlaneShape, _AmmoShape);

              var _proto = AmmoPlaneShape.prototype;

              _proto.setNormal = function setNormal(v) {
                cocos2AmmoVec3(this.impl.getPlaneNormal(), v);
                this.updateCompoundTransform();
              };

              _proto.setConstant = function setConstant(v) {
                this.impl.setPlaneConstant(v);
                this.updateCompoundTransform();
              };

              _proto.setScale = function setScale() {
                _AmmoShape.prototype.setScale.call(this);

                cocos2AmmoVec3(this.scale, this._collider.node.worldScale);

                this._btShape.setLocalScaling(this.scale);

                this.updateCompoundTransform();
              };

              _createClass(AmmoPlaneShape, [{
                key: "impl",
                get: function get() {
                  return this._btShape;
                }
              }, {
                key: "collider",
                get: function get() {
                  return this._collider;
                }
              }]);

              function AmmoPlaneShape() {
                return _AmmoShape.call(this, AmmoBroadphaseNativeTypes.STATIC_PLANE_PROXYTYPE) || this;
              }

              _proto.onComponentSet = function onComponentSet() {
                var normal = AmmoConstant.instance.VECTOR3_0;
                cocos2AmmoVec3(normal, this.collider.normal);
                this._btShape = new Ammo$1.btStaticPlaneShape(normal, this.collider.constant);
                this.setScale();
              };

              return AmmoPlaneShape;
            }(AmmoShape);

            var AmmoConstraint = function () {
              function AmmoConstraint() {
                this.dirty = 0;
                this.index = -1;
                this._collided = false;
              }

              var _proto = AmmoConstraint.prototype;

              _proto.setConnectedBody = function setConnectedBody(v) {};

              _proto.setEnableCollision = function setEnableCollision(v) {
                if (this._collided !== v) {
                  this._collided = v;
                  this.updateByReAdd();
                }
              };

              _proto.updateByReAdd = function updateByReAdd() {
                if (this._rigidBody && this.index >= 0) {
                  var sb = this._rigidBody.body.sharedBody;
                  sb.wrappedWorld.removeConstraint(this);
                  sb.wrappedWorld.addConstraint(this);
                }
              };

              _proto.initialize = function initialize(v) {
                this._com = v;
                this._rigidBody = v.attachedBody;
                this._collided = v.enableCollision;
                this.onComponentSet();
              };

              _proto.onComponentSet = function onComponentSet() {};

              _proto.updateScale0 = function updateScale0() {};

              _proto.updateScale1 = function updateScale1() {};

              _proto.onEnable = function onEnable() {
                var sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.addConstraint(this);
                sb.addJoint(this, 0);
                var connect = this.constraint.connectedBody;

                if (connect) {
                  var sb2 = connect.body.sharedBody;
                  sb2.addJoint(this, 1);
                }
              };

              _proto.onDisable = function onDisable() {
                var sb = this._rigidBody.body.sharedBody;
                sb.wrappedWorld.removeConstraint(this);
                sb.removeJoint(this, 0);
                var connect = this.constraint.connectedBody;

                if (connect) {
                  var sb2 = connect.body.sharedBody;
                  sb2.removeJoint(this, 1);
                }
              };

              _proto.onDestroy = function onDestroy() {
                Ammo$1.destroy(this._impl);
                this._com = null;
                this._rigidBody = null;
                this._impl = null;
              };

              _createClass(AmmoConstraint, [{
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return AmmoConstraint;
            }();

            var AmmoPointToPointConstraint = function (_AmmoConstraint) {
              _inheritsLoose(AmmoPointToPointConstraint, _AmmoConstraint);

              function AmmoPointToPointConstraint() {
                return _AmmoConstraint.apply(this, arguments) || this;
              }

              var _proto = AmmoPointToPointConstraint.prototype;

              _proto.setPivotA = function setPivotA(v) {
                var pivotA = AmmoConstant.instance.VECTOR3_0;
                var cs = this.constraint;
                Vec3.multiply(CC_V3_0, cs.node.worldScale, cs.pivotA);
                cocos2AmmoVec3(pivotA, CC_V3_0);
                this.impl.setPivotA(pivotA);
                if (!cs.connectedBody) this.setPivotB(cs.pivotB);
              };

              _proto.setPivotB = function setPivotB(v) {
                var cs = this.constraint;
                var node = this._rigidBody.node;
                var pivotB = AmmoConstant.instance.VECTOR3_0;
                var cb = cs.connectedBody;

                if (cb) {
                  Vec3.multiply(CC_V3_0, cb.node.worldScale, cs.pivotB);
                  cocos2AmmoVec3(pivotB, CC_V3_0);
                } else {
                  Vec3.multiply(CC_V3_0, node.worldScale, cs.pivotA);
                  Vec3.add(CC_V3_0, CC_V3_0, node.worldPosition);
                  Vec3.add(CC_V3_0, CC_V3_0, cs.pivotB);
                  cocos2AmmoVec3(pivotB, CC_V3_0);
                }

                this.impl.setPivotB(pivotB);
              };

              _proto.onComponentSet = function onComponentSet() {
                var bodyA = this._rigidBody.body.impl;
                var cb = this.constraint.connectedBody;
                var bodyB;

                if (cb) {
                  bodyB = cb.body.impl;
                }

                var pivotA = AmmoConstant.instance.VECTOR3_0;

                if (bodyB) {
                  var pivotB = AmmoConstant.instance.VECTOR3_1;
                  this._impl = new Ammo$1.btPoint2PointConstraint(bodyA, bodyB, pivotA, pivotB);
                } else {
                  this._impl = new Ammo$1.btPoint2PointConstraint(bodyA, pivotA);
                }

                this.setPivotA(this.constraint.pivotA);
                this.setPivotB(this.constraint.pivotB);
              };

              _proto.updateScale0 = function updateScale0() {
                this.setPivotA(this.constraint.pivotA);
              };

              _proto.updateScale1 = function updateScale1() {
                this.setPivotB(this.constraint.pivotB);
              };

              _createClass(AmmoPointToPointConstraint, [{
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return AmmoPointToPointConstraint;
            }(AmmoConstraint);

            var AmmoHingeConstraint = function (_AmmoConstraint) {
              _inheritsLoose(AmmoHingeConstraint, _AmmoConstraint);

              function AmmoHingeConstraint() {
                return _AmmoConstraint.apply(this, arguments) || this;
              }

              var _proto = AmmoHingeConstraint.prototype;

              _proto.setPivotA = function setPivotA(v) {
                this.updateFrames();
              };

              _proto.setPivotB = function setPivotB(v) {
                this.updateFrames();
              };

              _proto.setAxis = function setAxis(v) {
                this.updateFrames();
              };

              _proto.onComponentSet = function onComponentSet() {
                var sb0 = this._rigidBody.body.sharedBody;
                var cb = this.constraint.connectedBody;
                var bodyB = cb ? cb.body.impl : sb0.wrappedWorld.impl.getFixedBody();
                var trans0 = AmmoConstant.instance.TRANSFORM;
                var trans1 = AmmoConstant.instance.TRANSFORM_1;
                this._impl = new Ammo$1.btHingeConstraint(sb0.body, bodyB, trans0, trans1);
                this.updateFrames();
              };

              _proto.updateFrames = function updateFrames() {
                var cs = this.constraint;
                var node = cs.node;
                var v3_0 = CC_V3_0;
                var rot_0 = CC_QUAT_0;
                var trans0 = AmmoConstant.instance.TRANSFORM;
                Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                cocos2AmmoVec3(trans0.getOrigin(), v3_0);
                var quat = AmmoConstant.instance.QUAT_0;
                Quat.rotationTo(rot_0, Vec3.UNIT_Z, cs.axis);
                trans0.setRotation(cocos2AmmoQuat(quat, rot_0));
                var trans1 = AmmoConstant.instance.TRANSFORM_1;
                var cb = this.constraint.connectedBody;

                if (cb) {
                  Vec3.multiply(v3_0, cb.node.worldScale, cs.pivotB);
                } else {
                  Vec3.multiply(v3_0, node.worldScale, cs.pivotA);
                  Vec3.add(v3_0, v3_0, node.worldPosition);
                  Vec3.add(v3_0, v3_0, cs.pivotB);
                  Quat.multiply(rot_0, rot_0, node.worldRotation);
                }

                cocos2AmmoVec3(trans1.getOrigin(), v3_0);
                trans1.setRotation(cocos2AmmoQuat(quat, rot_0));
                this.impl.setFrames(trans0, trans1);
              };

              _proto.updateScale0 = function updateScale0() {
                this.updateFrames();
              };

              _proto.updateScale1 = function updateScale1() {
                this.updateFrames();
              };

              _createClass(AmmoHingeConstraint, [{
                key: "impl",
                get: function get() {
                  return this._impl;
                }
              }, {
                key: "constraint",
                get: function get() {
                  return this._com;
                }
              }]);

              return AmmoHingeConstraint;
            }(AmmoConstraint);

            selector.select('ammo.js', {
              PhysicsWorld: AmmoWorld,
              RigidBody: AmmoRigidBody,
              BoxShape: AmmoBoxShape,
              SphereShape: AmmoSphereShape,
              CapsuleShape: AmmoCapsuleShape,
              TrimeshShape: AmmoTrimeshShape,
              CylinderShape: AmmoCylinderShape,
              ConeShape: AmmoConeShape,
              TerrainShape: AmmoTerrainShape,
              SimplexShape: AmmoSimplexShape,
              PlaneShape: AmmoPlaneShape,
              PointToPointConstraint: AmmoPointToPointConstraint,
              HingeConstraint: AmmoHingeConstraint
            });

            window.Ammo = Ammo$1;
            Ammo$1.CC_CONFIG = {
              ignoreSelfBody: true
            };
            Ammo$1.CC_CACHE = {
              btTriangleMesh: {
                enable: false
              }
            };

            var Counter = function () {
              _createClass(Counter, [{
                key: "value",
                get: function get() {
                  return this._value;
                },
                set: function set(val) {
                  this._value = val;
                }
              }]);

              function Counter(id, opts, now) {
                this._id = void 0;
                this._opts = void 0;
                this._accumStart = void 0;
                this._total = 0;
                this._value = 0;
                this._averageValue = 0;
                this._accumValue = 0;
                this._accumSamples = 0;
                this._id = id;
                this._opts = opts;
                this._accumStart = now;
              }

              var _proto = Counter.prototype;

              _proto.sample = function sample(now) {
                this._average(this._value, now);
              };

              _proto.human = function human() {
                var _this$_opts = this._opts,
                    average = _this$_opts.average,
                    isInteger = _this$_opts.isInteger;
                var v = average ? this._averageValue : this._value;
                return isInteger ? Math.round(v) : Math.round(v * 100) / 100;
              };

              _proto.alarm = function alarm() {
                return this._opts.below && this._value < this._opts.below || this._opts.over && this._value > this._opts.over;
              };

              _proto._average = function _average(v, now) {
                if (now === void 0) {
                  now = 0;
                }

                if (this._opts.average) {
                  this._accumValue += v;
                  ++this._accumSamples;
                  var t = now;

                  if (t - this._accumStart >= this._opts.average) {
                    this._averageValue = this._accumValue / this._accumSamples;
                    this._accumValue = 0;
                    this._accumStart = t;
                    this._accumSamples = 0;
                  }
                }
              };

              return Counter;
            }();

            var _dec$12, _class$12, _temp$X;
            var PerfCounter = (_dec$12 = ccclass('cc.PerfCounter'), _dec$12(_class$12 = (_temp$X = function (_Counter) {
              _inheritsLoose(PerfCounter, _Counter);

              function PerfCounter(id, opts, now) {
                var _this;

                _this = _Counter.call(this, id, opts, now) || this;
                _this._time = void 0;
                _this._time = now;
                return _this;
              }

              var _proto = PerfCounter.prototype;

              _proto.start = function start(now) {
                if (now === void 0) {
                  now = 0;
                }

                this._time = now;
              };

              _proto.end = function end(now) {
                if (now === void 0) {
                  now = 0;
                }

                this._value = now - this._time;

                this._average(this._value);
              };

              _proto.tick = function tick() {
                this.end();
                this.start();
              };

              _proto.frame = function frame(now) {
                var t = now;
                var e = t - this._time;
                this._total++;
                var avg = this._opts.average || 1000;

                if (e > avg) {
                  this._value = this._total * 1000 / e;
                  this._total = 0;
                  this._time = t;

                  this._average(this._value);
                }
              };

              return PerfCounter;
            }(Counter), _temp$X)) || _class$12);

            var _characters = '0123456789. ';
            var _string2offset = {
              0: 0,
              1: 1,
              2: 2,
              3: 3,
              4: 4,
              5: 5,
              6: 6,
              7: 7,
              8: 8,
              9: 9,
              '.': 10
            };
            var _profileInfo = {
              fps: {
                desc: 'Framerate (FPS)',
                below: 30,
                average: 500,
                isInteger: true
              },
              draws: {
                desc: 'Draw call',
                isInteger: true
              },
              frame: {
                desc: 'Frame time (ms)',
                min: 0,
                max: 50,
                average: 500
              },
              instances: {
                desc: 'Instance Count',
                isInteger: true
              },
              tricount: {
                desc: 'Triangle',
                isInteger: true
              },
              logic: {
                desc: 'Game Logic (ms)',
                min: 0,
                max: 50,
                average: 500,
                color: '#080'
              },
              physics: {
                desc: 'Physics (ms)',
                min: 0,
                max: 50,
                average: 500
              },
              render: {
                desc: 'Renderer (ms)',
                min: 0,
                max: 50,
                average: 500,
                color: '#f90'
              },
              textureMemory: {
                desc: 'GFX Texture Mem(M)'
              },
              bufferMemory: {
                desc: 'GFX Buffer Mem(M)'
              }
            };
            var _constants = {
              fontSize: 23,
              quadHeight: 0.4,
              segmentsPerLine: 8,
              textureWidth: 256,
              textureHeight: 256
            };
            var Profiler = exports('Profiler', function () {
              function Profiler() {
                this._stats = null;
                this.id = '__Profiler__';
                this._showFPS = false;
                this._rootNode = null;
                this._device = null;
                this._canvas = null;
                this._ctx = null;
                this._texture = null;
                this._region = new BufferTextureCopy();
                this._canvasArr = [];
                this._regionArr = [this._region];
                this.digitsData = null;
                this.offsetData = null;
                this.pass = null;
                this._canvasDone = false;
                this._statsDone = false;
                this._inited = false;
                this._lineHeight = _constants.textureHeight / (Object.keys(_profileInfo).length + 1);
                this._wordHeight = 0;
                this._eachNumWidth = 0;
                this._totalLines = 0;
                this.lastTime = 0;

                {
                  this._canvas = document.createElement('canvas');
                  this._ctx = this._canvas.getContext('2d');

                  this._canvasArr.push(this._canvas);
                }
              }

              var _proto = Profiler.prototype;

              _proto.isShowingStats = function isShowingStats() {
                return this._showFPS;
              };

              _proto.hideStats = function hideStats() {
                if (this._showFPS) {
                  if (this._rootNode) {
                    this._rootNode.active = false;
                  }

                  legacyCC.game.off(legacyCC.Game.EVENT_RESTART, this.generateNode, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.off(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
                  this._showFPS = false;
                }
              };

              _proto.showStats = function showStats() {
                if (!this._showFPS) {
                  if (!this._device) {
                    this._device = legacyCC.director.root.device;
                  }

                  {
                    this.generateCanvas();
                  }

                  this.generateStats();

                  {
                    legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this.generateNode, this);
                    legacyCC.game.on(legacyCC.Game.EVENT_RESTART, this.generateNode, this);
                  }

                  if (this._rootNode) {
                    this._rootNode.active = true;
                  }

                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_UPDATE, this.beforeUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_UPDATE, this.afterUpdate, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_PHYSICS, this.beforePhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_PHYSICS, this.afterPhysics, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_BEFORE_DRAW, this.beforeDraw, this);
                  legacyCC.director.on(legacyCC.Director.EVENT_AFTER_DRAW, this.afterDraw, this);
                  this._showFPS = true;
                  this._canvasDone = true;
                  this._statsDone = true;
                }
              };

              _proto.generateCanvas = function generateCanvas() {
                if (this._canvasDone) {
                  return;
                }

                var textureWidth = _constants.textureWidth,
                    textureHeight = _constants.textureHeight;

                if (!this._ctx || !this._canvas) {
                  return;
                }

                this._canvas.width = textureWidth;
                this._canvas.height = textureHeight;
                this._canvas.style.width = "" + this._canvas.width;
                this._canvas.style.height = "" + this._canvas.height;
                this._ctx.font = _constants.fontSize + "px Arial";
                this._ctx.textBaseline = 'top';
                this._ctx.fillStyle = '#fff';
                this._texture = this._device.createTexture(new TextureInfo(TextureType.TEX2D, TextureUsageBit.SAMPLED | TextureUsageBit.TRANSFER_DST, Format.RGBA8, textureWidth, textureHeight));
                this._region.texExtent.width = textureWidth;
                this._region.texExtent.height = textureHeight;
              };

              _proto.generateStats = function generateStats() {
                if (this._statsDone || !this._ctx || !this._canvas) {
                  return;
                }

                this._stats = null;
                var now = performance.now();
                this._ctx.textAlign = 'left';
                var i = 0;

                for (var id in _profileInfo) {
                  var element = _profileInfo[id];
                  this._ctx.fillText(element.desc, 0, i * this._lineHeight);
                  element.counter = new PerfCounter(id, element, now);
                  i++;
                }

                this._totalLines = i;
                this._wordHeight = this._totalLines * this._lineHeight / this._canvas.height;

                {
                  for (var j = 0; j < _characters.length; ++j) {
                    var offset = this._ctx.measureText(_characters[j]).width;

                    this._eachNumWidth = Math.max(this._eachNumWidth, offset);
                  }

                  for (var _j = 0; _j < _characters.length; ++_j) {
                    this._ctx.fillText(_characters[_j], _j * this._eachNumWidth, this._totalLines * this._lineHeight);
                  }
                }

                this._eachNumWidth /= this._canvas.width;
                this._stats = _profileInfo;
                this._canvasArr[0] = this._canvas;
                this._device.copyTexImagesToTexture(this._canvasArr, this._texture, this._regionArr);
              };

              _proto.generateNode = function generateNode() {
                if (this._rootNode && this._rootNode.isValid) {
                  return;
                }

                this._rootNode = new Node('PROFILER_NODE');
                legacyCC.game.addPersistRootNode(this._rootNode);
                var cameraNode = new Node('Profiler_Camera');
                cameraNode.setPosition(0, 0, 1.5);
                cameraNode.parent = this._rootNode;
                var camera = cameraNode.addComponent('cc.Camera');
                camera.projection = Camera.ProjectionType.ORTHO;
                camera.orthoHeight = 1;
                camera.near = 1;
                camera.far = 2;
                camera.visibility = Layers.BitMask.PROFILER;
                camera.clearFlags = ClearFlag.NONE;
                camera.priority = 0xffffffff;
                var managerNode = new Node('Profiler_Root');
                managerNode.parent = this._rootNode;
                var height = _constants.quadHeight;
                var rowHeight = height / this._totalLines;
                var lWidth = height / this._wordHeight;
                var scale = rowHeight / _constants.fontSize;
                var columnWidth = this._eachNumWidth * this._canvas.width * scale;
                var vertexPos = [0, height, 0, lWidth, height, 0, lWidth, 0, 0, 0, 0, 0];
                var vertexindices = [0, 2, 1, 0, 3, 2];
                var vertexUV = [0, 0, -1, 0, 1, 0, -1, 0, 1, this._wordHeight, -1, 0, 0, this._wordHeight, -1, 0];
                var offset = 0;

                for (var i = 0; i < this._totalLines; i++) {
                  for (var j = 0; j < _constants.segmentsPerLine; j++) {
                    vertexPos.push(lWidth + j * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - i * rowHeight, 0);
                    vertexPos.push(lWidth + (j + 1) * columnWidth, height - (i + 1) * rowHeight, 0);
                    vertexPos.push(lWidth + j * columnWidth, height - (i + 1) * rowHeight, 0);
                    offset = (i * _constants.segmentsPerLine + j + 1) * 4;
                    vertexindices.push(0 + offset, 2 + offset, 1 + offset, 0 + offset, 3 + offset, 2 + offset);
                    var idx = i * _constants.segmentsPerLine + j;
                    var z = Math.floor(idx / 4);
                    var w = idx - z * 4;
                    vertexUV.push(0, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, this._wordHeight, z, w);
                    vertexUV.push(this._eachNumWidth, 1, z, w);
                    vertexUV.push(0, 1, z, w);
                  }
                }

                var modelCom = managerNode.addComponent(MeshRenderer);
                modelCom.mesh = createMesh({
                  positions: vertexPos,
                  indices: vertexindices,
                  colors: vertexUV
                });

                var _material = new Material();

                _material.initialize({
                  effectName: 'profiler'
                });

                var pass = this.pass = _material.passes[0];
                var hTexture = pass.getBinding('mainTexture');
                var bDigits = pass.getBinding('digits');
                var bOffset = pass.getBinding('offset');
                pass.bindTexture(hTexture, this._texture);
                this.digitsData = pass.blocks[bDigits];
                this.offsetData = pass.blocks[bOffset];
                this.offsetData[3] = -1;
                modelCom.material = _material;
                modelCom.node.layer = Layers.Enum.PROFILER;
                this._inited = true;
              };

              _proto.beforeUpdate = function beforeUpdate() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.frame.counter.end(now);

                this._stats.frame.counter.start(now);

                this._stats.logic.counter.start(now);
              };

              _proto.afterUpdate = function afterUpdate() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                if (legacyCC.director.isPaused()) {
                  this._stats.frame.counter.start(now);
                } else {
                  this._stats.logic.counter.end(now);
                }
              };

              _proto.beforePhysics = function beforePhysics() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.physics.counter.start(now);
              };

              _proto.afterPhysics = function afterPhysics() {
                if (!this._stats) {
                  return;
                }

                var now = performance.now();

                this._stats.physics.counter.end(now);
              };

              _proto.beforeDraw = function beforeDraw() {
                if (!this._stats) {
                  return;
                }

                {
                  var _ref = this._device,
                      screenSpaceSignY = _ref.screenSpaceSignY,
                      surfaceTransform = _ref.surfaceTransform;

                  if (surfaceTransform !== this.offsetData[3]) {
                    var preTransform = preTransforms[surfaceTransform];
                    var x = -0.9;
                    var y = -0.9 * screenSpaceSignY;
                    this.offsetData[0] = x * preTransform[0] + y * preTransform[2];
                    this.offsetData[1] = x * preTransform[1] + y * preTransform[3];
                    this.offsetData[2] = this._eachNumWidth;
                    this.offsetData[3] = surfaceTransform;
                  }

                  this.pass._rootBufferDirty = true;
                }

                var now = performance.now();

                this._stats.render.counter.start(now);
              };

              _proto.afterDraw = function afterDraw() {
                if (!this._stats || !this._inited) {
                  return;
                }

                var now = performance.now();

                this._stats.fps.counter.frame(now);

                this._stats.render.counter.end(now);

                if (now - this.lastTime < 500) {
                  return;
                }

                this.lastTime = now;
                var device = this._device;
                this._stats.draws.counter.value = device.numDrawCalls;
                this._stats.instances.counter.value = device.numInstances;
                this._stats.bufferMemory.counter.value = device.memoryStatus.bufferSize / (1024 * 1024);
                this._stats.textureMemory.counter.value = device.memoryStatus.textureSize / (1024 * 1024);
                this._stats.tricount.counter.value = device.numTris;
                var i = 0;

                {
                  var view = this.digitsData;

                  for (var id in this._stats) {
                    var stat = this._stats[id];
                    stat.counter.sample(now);
                    var result = stat.counter.human().toString();

                    for (var j = _constants.segmentsPerLine - 1; j >= 0; j--) {
                      var index = i * _constants.segmentsPerLine + j;
                      var character = result[result.length - (_constants.segmentsPerLine - j)];
                      var offset = _string2offset[character];

                      if (offset === undefined) {
                        offset = 11;
                      }

                      view[index] = offset;
                    }

                    i++;
                  }
                }
              };

              return Profiler;
            }());
            var profiler = exports('profiler', new Profiler());
            legacyCC.profiler = profiler;

        }
    };
});
